==================== [第一阶段 - 基础框架] ====================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ASSEMBLY-CTRL 系统基础框架

此模块实现了ASSEMBLY-CTRL系统的基础架构组件，包括：
- 错误处理系统（ErrorHandler）
- 消息总线（MessageBus）
- 模块注册表（ModuleRegistry）
- 资源监控（ResourceMonitor）
- 配置管理（Config）

这些组件构成了系统的核心骨架，为其他功能模块提供基础支持。
"""

import os
import sys
import json
import time
import uuid
import logging
import threading
import traceback
import platform
import psutil
from typing import Dict, List, Callable, Optional, Any, Union, Set
from datetime import datetime
from collections import deque
from concurrent.futures import ThreadPoolExecutor

# =================================================================================
# 日志设置
# =================================================================================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('assembly_ctrl.log')
    ]
)

logger = logging.getLogger('ASSEMBLY-CTRL')

# =================================================================================
# 错误处理系统 - 提供统一的错误处理机制
# =================================================================================

class Error(Exception):
    """
    系统错误基类

    所有系统中的错误都应该继承自这个类，以便统一处理

    属性:
        code (int): 错误代码
        message (str): 错误消息
        details (Dict): 错误详情
        module (str): 错误来源模块
        timestamp (str): 错误发生时间
    """

    def __init__(self, code: int, message: str, details: Dict = None, module: str = None):
        """
        初始化一个错误对象

        参数:
            code (int): 错误代码
            message (str): 错误消息
            details (Dict, optional): 错误详情. 默认为None
            module (str, optional): 错误来源模块. 默认为None
        """
        super().__init__(message)
        self.code = code
        self.message = message
        self.details = details or {}
        self.module = module
        self.timestamp = datetime.now().isoformat()

    def to_dict(self) -> Dict:
        """
        将错误对象转换为字典

        返回:
            Dict: 表示错误的字典
        """
        return {
            'code': self.code,
            'message': self.message,
            'details': self.details,
            'module': self.module,
            'timestamp': self.timestamp,
            'traceback': traceback.format_exc() if self.details.get('include_traceback') else None
        }

    def __str__(self) -> str:
        """
        返回错误的字符串表示

        返回:
            str: 错误的字符串表示
        """
        return f"[Error {self.code}] {self.message} in {self.module or 'unknown'}"

# 定义标准错误代码
ERROR_UNKNOWN = 1000
ERROR_CONFIG = 1100
ERROR_MESSAGING = 1200
ERROR_MODULE = 1300
ERROR_RESOURCE = 1400
ERROR_TIMEOUT = 1500
ERROR_PERMISSION = 1600

class ErrorHandler:
    """
    错误处理器

    提供统一的错误处理、记录和回调机制
    """

    def __init__(self):
        """初始化错误处理器"""
        self._callbacks = set()
        self._error_history = deque(maxlen=100)  # 保留最近100个错误
        self._lock = threading.RLock()

    def register_callback(self, callback: Callable[[Error], None]) -> None:
        """
        注册错误回调函数

        参数:
            callback (Callable[[Error], None]): 处理错误的回调函数
        """
        with self._lock:
            self._callbacks.add(callback)

    def unregister_callback(self, callback: Callable[[Error], None]) -> None:
        """
        取消注册错误回调函数

        参数:
            callback (Callable[[Error], None]): 之前注册的回调函数
        """
        with self._lock:
            self._callbacks.discard(callback)

    def handle(self, error: Error) -> None:
        """
        处理错误

        记录错误到历史记录，记录日志，并调用所有注册的回调函数

        参数:
            error (Error): 要处理的错误对象
        """
        with self._lock:
            # 添加到错误历史
            self._error_history.append(error)

            # 记录错误日志
            logger.error(f"{error} - Details: {json.dumps(error.details)}")

            # 调用所有回调
            for callback in self._callbacks:
                try:
                    callback(error)
                except Exception as e:
                    logger.error(f"Error in error callback: {e}")

    def get_recent_errors(self, count: int = 10, module: str = None, code: int = None) -> List[Dict]:
        """
        获取最近的错误

        参数:
            count (int, optional): 返回的错误数量。默认为10
            module (str, optional): 按模块筛选。默认为None
            code (int, optional): 按错误代码筛选。默认为None

        返回:
            List[Dict]: 符合条件的错误列表
        """
        with self._lock:
            errors = list(self._error_history)

            # 应用过滤器
            if module:
                errors = [e for e in errors if e.module == module]
            if code:
                errors = [e for e in errors if e.code == code]

            # 转换为字典并返回指定数量
            return [e.to_dict() for e in errors[-count:]]

# =================================================================================
# 消息总线 - 提供模块间通信机制
# =================================================================================

class Message:
    """
    系统消息类

    用于模块间通信的标准消息格式

    属性:
        message_id (str): 消息唯一标识符
        source (str): 发送源模块标识符
        destination (str): 目标模块标识符
        msg_type (str): 消息类型
        payload (Dict): 消息内容
        priority (str): 消息优先级，可以是 "low", "medium", "high", "critical"
        correlation_id (str): 相关消息ID，用于追踪消息链
        timestamp (str): 消息创建时间
    """

    # 定义优先级常量
    PRIORITY_LOW = "low"
    PRIORITY_MEDIUM = "medium"
    PRIORITY_HIGH = "high"
    PRIORITY_CRITICAL = "critical"

    # 优先级权重映射(用于排序)
    PRIORITY_WEIGHTS = {
        PRIORITY_LOW: 0,
        PRIORITY_MEDIUM: 1,
        PRIORITY_HIGH: 2,
        PRIORITY_CRITICAL: 3
    }

    def __init__(self, source: str, destination: str, msg_type: str,
                 payload: Dict = None, priority: str = PRIORITY_MEDIUM, correlation_id: str = None):
        """
        初始化消息对象

        参数:
            source (str): 发送源模块标识符
            destination (str): 目标模块标识符
            msg_type (str): 消息类型
            payload (Dict, optional): 消息内容。默认为None
            priority (str, optional): 消息优先级。默认为"medium"
            correlation_id (str, optional): 相关消息ID。默认为None
        """
        self.message_id = str(uuid.uuid4())
        self.source = source
        self.destination = destination
        self.msg_type = msg_type
        self.payload = payload or {}

        # 验证优先级
        if priority not in self.PRIORITY_WEIGHTS:
            raise ValueError(f"Invalid priority: {priority}. Must be one of {list(self.PRIORITY_WEIGHTS.keys())}")
        self.priority = priority

        self.correlation_id = correlation_id
        self.timestamp = datetime.now().isoformat()

    def to_dict(self) -> Dict:
        """
        将消息对象转换为字典

        返回:
            Dict: 表示消息的字典
        """
        return {
            "message_id": self.message_id,
            "source": self.source,
            "destination": self.destination,
            "type": self.msg_type,
            "payload": self.payload,
            "priority": self.priority,
            "correlation_id": self.correlation_id,
            "timestamp": self.timestamp
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Message':
        """
        从字典创建消息对象

        参数:
            data (Dict): 表示消息的字典

        返回:
            Message: 创建的消息对象
        """
        msg = cls(
            source=data.get("source"),
            destination=data.get("destination"),
            msg_type=data.get("type"),
            payload=data.get("payload"),
            priority=data.get("priority", cls.PRIORITY_MEDIUM),
            correlation_id=data.get("correlation_id")
        )
        # 保留原始message_id和timestamp(如果有)
        if "message_id" in data:
            msg.message_id = data["message_id"]
        if "timestamp" in data:
            msg.timestamp = data["timestamp"]
        return msg

    def __lt__(self, other):
        """
        比较两个消息的优先级，用于队列排序

        参数:
            other (Message): 比较的另一个消息

        返回:
            bool: 如果self优先级低于other，返回True
        """
        return self.PRIORITY_WEIGHTS[self.priority] < self.PRIORITY_WEIGHTS[other.priority]

class MessageBus:
    """
    系统消息总线

    提供消息发布-订阅机制和路由功能
    """

    def __init__(self):
        """初始化消息总线"""
        # 话题订阅
        self._subscriptions = {}  # type: Dict[str, Set[Callable]]
        # 目标路由
        self._routes = {}  # type: Dict[str, Set[Callable]]
        # 消息队列 - 按优先级排序
        self._message_queue = []  # 使用heapq模块管理
        # 工作线程
        self._worker = None
        # 运行状态标志
        self._running = False
        # 线程池
        self._executor = ThreadPoolExecutor(max_workers=5)
        # 线程锁
        self._lock = threading.RLock()
        # 条件变量 - 用于通知消息队列有新消息
        self._condition = threading.Condition(self._lock)

    def start(self):
        """启动消息总线处理线程"""
        with self._lock:
            if not self._running:
                self._running = True
                self._worker = threading.Thread(target=self._process_queue, daemon=True)
                self._worker.start()
                logger.info("Message bus started")

    def publish(self, message: Message) -> None:
        """
        发布消息到总线

        参数:
            message (Message): 要发布的消息对象
        """
        if not self._running:
            self.start()

        with self._condition:
            import heapq
            # 添加消息到优先级队列
            heapq.heappush(self._message_queue, (self.PRIORITY_WEIGHTS.get(message.priority, 1), message))
            # 通知处理线程有新消息
            self._condition.notify()

    def subscribe(self, topic: str, callback: Callable[[Message], None]) -> None:
        """
        订阅特定话题

        参数:
            topic (str): 要订阅的话题
            callback (Callable[[Message], None]): 处理消息的回调函数
        """
        with self._lock:
            if topic not in self._subscriptions:
                self._subscriptions[topic] = set()
            self._subscriptions[topic].add(callback)

    def unsubscribe(self, topic: str, callback: Callable[[Message], None]) -> None:
        """
        取消订阅话题

        参数:
            topic (str): 之前订阅的话题
            callback (Callable[[Message], None]): 之前注册的回调函数
        """
        with self._lock:
            if topic in self._subscriptions:
                self._subscriptions[topic].discard(callback)
                # 如果没有订阅者了，删除话题
                if not self._subscriptions[topic]:
                    del self._subscriptions[topic]

    def add_route(self, destination: str, callback: Callable[[Message], None]) -> None:
        """
        添加消息路由

        参数:
            destination (str): 目标模块标识符
            callback (Callable[[Message], None]): 处理消息的回调函数
        """
        with self._lock:
            if destination not in self._routes:
                self._routes[destination] = set()
            self._routes[destination].add(callback)

    def remove_route(self, destination: str, callback: Callable[[Message], None]) -> None:
        """
        移除消息路由

        参数:
            destination (str): 目标模块标识符
            callback (Callable[[Message], None]): 之前注册的回调函数
        """
        with self._lock:
            if destination in self._routes:
                self._routes[destination].discard(callback)
                # 如果没有路由了，删除目标
                if not self._routes[destination]:
                    del self._routes[destination]

    def _process_queue(self):
        """
        处理消息队列的工作线程函数
        """
        import heapq

        while self._running:
            with self._condition:
                # 等待消息
                while self._running and not self._message_queue:
                    self._condition.wait()

                if not self._running:
                    break

                # 取出最高优先级的消息
                _, message = heapq.heappop(self._message_queue)

            # 处理消息(不在锁内处理，避免阻塞)
            self._handle_message(message)

    def _handle_message(self, message: Message):
        """
        处理单个消息，将其分发到相应的订阅者和路由

        参数:
            message (Message): 要处理的消息
        """
        callbacks = set()

        with self._lock:
            # 1. 检查目标路由
            if message.destination in self._routes:
                callbacks.update(self._routes[message.destination])

            # 2. 检查话题订阅
            if message.msg_type in self._subscriptions:
                callbacks.update(self._subscriptions[message.msg_type])

        # 在线程池中执行回调
        for callback in callbacks:
            self._executor.submit(self._safe_callback, callback, message)

    def _safe_callback(self, callback, message):
        """
        安全地执行回调函数

        参数:
            callback (Callable): 回调函数
            message (Message): 消息对象
        """
        try:
            callback(message)
        except Exception as e:
            error = Error(
                code=ERROR_MESSAGING,
                message=f"Error in message callback: {str(e)}",
                details={
                    "exception": str(e),
                    "message_id": message.message_id,
                    "include_traceback": True
                },
                module="MessageBus"
            )
            logger.error(f"Error processing message {message.message_id}: {e}")

    def shutdown(self) -> None:
        """
        关闭消息总线

        停止处理线程和线程池
        """
        with self._condition:
            self._running = False
            self._condition.notify_all()

        if self._worker and self._worker.is_alive():
            self._worker.join(timeout=2.0)

        self._executor.shutdown(wait=True)
        logger.info("Message bus shut down")

# =================================================================================
# 模块注册表 - 提供模块注册和发现机制
# =================================================================================

class ModuleCapability:
    """
    模块能力描述

    描述模块提供的功能和能力

    属性:
        name (str): 能力名称
        description (str): 能力描述
        parameters (Dict): 能力参数描述
        resource_requirements (Dict): 能力资源需求
    """

    def __init__(self, name: str, description: str, parameters: Dict = None,
                 resource_requirements: Dict = None):
        """
        初始化模块能力对象

        参数:
            name (str): 能力名称
            description (str): 能力描述
            parameters (Dict, optional): 能力参数描述。默认为None
            resource_requirements (Dict, optional): 能力资源需求。默认为None
        """
        self.name = name
        self.description = description
        self.parameters = parameters or {}
        self.resource_requirements = resource_requirements or {}

    def to_dict(self) -> Dict:
        """
        将模块能力转换为字典

        返回:
            Dict: 表示模块能力的字典
        """
        return {
            "name": self.name,
            "description": self.description,
            "parameters": self.parameters,
            "resource_requirements": self.resource_requirements
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'ModuleCapability':
        """
        从字典创建模块能力对象

        参数:
            data (Dict): 表示模块能力的字典

        返回:
            ModuleCapability: 创建的模块能力对象
        """
        return cls(
            name=data.get("name", ""),
            description=data.get("description", ""),
            parameters=data.get("parameters", {}),
            resource_requirements=data.get("resource_requirements", {})
        )

class ModuleRegistry:
    """
    模块注册与发现机制

    管理系统中的模块注册、状态更新和发现
    """

    # 模块状态常量
    STATUS_ONLINE = "online"
    STATUS_OFFLINE = "offline"
    STATUS_ERROR = "error"
    STATUS_STARTING = "starting"
    STATUS_STOPPING = "stopping"
    STATUS_SUSPENDED = "suspended"

    def __init__(self):
        """初始化模块注册表"""
        self._modules = {}  # type: Dict[str, Dict]
        self._lock = threading.RLock()
        self._message_bus = None  # 需要通过set_message_bus方法设置

    def set_message_bus(self, message_bus: MessageBus):
        """
        设置消息总线实例

        参数:
            message_bus (MessageBus): 消息总线实例
        """
        self._message_bus = message_bus

    def register_module(self, module_id: str, name: str, description: str,
                       capabilities: List[Dict] = None, status: str = STATUS_ONLINE,
                       resources: Dict = None) -> bool:
        """
        注册模块

        参数:
            module_id (str): 模块唯一标识符
            name (str): 模块名称
            description (str): 模块描述
            capabilities (List[Dict], optional): 模块能力列表。默认为None
            status (str, optional): 模块初始状态。默认为"online"
            resources (Dict, optional): 模块资源使用情况。默认为None

        返回:
            bool: 注册是否成功
        """
        if status not in [self.STATUS_ONLINE, self.STATUS_OFFLINE, self.STATUS_ERROR,
                          self.STATUS_STARTING, self.STATUS_STOPPING, self.STATUS_SUSPENDED]:
            raise ValueError(f"Invalid status: {status}")

        capabilities_list = []
        if capabilities:
            for cap in capabilities:
                if isinstance(cap, dict):
                    capabilities_list.append(ModuleCapability.from_dict(cap).to_dict())
                elif isinstance(cap, ModuleCapability):
                    capabilities_list.append(cap.to_dict())

        module_data = {
            "id": module_id,
            "name": name,
            "description": description,
            "capabilities": capabilities_list,
            "status": status,
            "resources": resources or {},
            "last_updated": datetime.now().isoformat(),
            "registration_time": datetime.now().isoformat()
        }

        with self._lock:
            # 检查模块是否已存在
            if module_id in self._modules:
                return False

            self._modules[module_id] = module_data

            # 发布注册事件
            if self._message_bus:
                self._message_bus.publish(Message(
                    source="ModuleRegistry",
                    destination="system",
                    msg_type="module.registered",
                    payload={"module": module_data}
                ))

            return True

    def unregister_module(self, module_id: str) -> bool:
        """
        取消注册模块

        参数:
            module_id (str): 模块唯一标识符

        返回:
            bool: 取消注册是否成功
        """
        with self._lock:
            if module_id not in self._modules:
                return False

            module_data = self._modules.pop(module_id)

            # 发布取消注册事件
            if self._message_bus:
                self._message_bus.publish(Message(
                    source="ModuleRegistry",
                    destination="system",
                    msg_type="module.unregistered",
                    payload={"module_id": module_id, "module": module_data}
                ))

            return True

    def update_module_status(self, module_id: str, status: str,
                           resources: Dict = None) -> bool:
        """
        更新模块状态

        参数:
            module_id (str): 模块唯一标识符
            status (str): 新的模块状态
            resources (Dict, optional): 更新的资源使用情况。默认为None

        返回:
            bool: 更新是否成功
        """
        if status not in [self.STATUS_ONLINE, self.STATUS_OFFLINE, self.STATUS_ERROR,
                          self.STATUS_STARTING, self.STATUS_STOPPING, self.STATUS_SUSPENDED]:
            raise ValueError(f"Invalid status: {status}")

        with self._lock:
            if module_id not in self._modules:
                return False

            # 更新状态
            old_status = self._modules[module_id]["status"]
            self._modules[module_id]["status"] = status
            self._modules[module_id]["last_updated"] = datetime.now().isoformat()

            # 更新资源使用情况
            if resources:
                self._modules[module_id]["resources"] = resources

            # 发布状态更新事件
            if self._message_bus and old_status != status:
                self._message_bus.publish(Message(
                    source="ModuleRegistry",
                    destination="system",
                    msg_type="module.status_changed",
                    payload={
                        "module_id": module_id,
                        "old_status": old_status,
                        "new_status": status
                    }
                ))

            return True

    def get_module(self, module_id: str) -> Optional[Dict]:
        """
        获取模块信息

        参数:
            module_id (str): 模块唯一标识符

        返回:
            Optional[Dict]: 模块信息，如果不存在则返回None
        """
        with self._lock:
            return self._modules.get(module_id)

    def get_all_modules(self) -> Dict[str, Dict]:
        """
        获取所有模块信息

        返回:
            Dict[str, Dict]: 模块ID到模块信息的映射
        """
        with self._lock:
            return self._modules.copy()

    def find_modules_by_capability(self, capability_name: str) -> List[Dict]:
        """
        按能力查找模块

        参数:
            capability_name (str): 能力名称

        返回:
            List[Dict]: 具有指定能力的模块列表
        """
        result = []
        with self._lock:
            for module in self._modules.values():
                for capability in module.get("capabilities", []):
                    if capability.get("name") == capability_name:
                        result.append(module)
                        break
        return result

    def find_modules_by_status(self, status: str) -> List[Dict]:
        """
        按状态查找模块

        参数:
            status (str): 模块状态

        返回:
            List[Dict]: 具有指定状态的模块列表
        """
        with self._lock:
            return [module for module in self._modules.values()
                   if module.get("status") == status]

    def shutdown(self) -> None:
        """关闭模块注册表"""
        # 在这个简单实现中，没有需要关闭的资源
        logger.info("Module registry shut down")

# =================================================================================
# 资源监控 - 监控系统资源使用情况
# =================================================================================

class ResourceMonitor:
    """
    系统资源监控

    监控系统资源使用情况并提供警报机制
    """

    def __init__(self, sample_interval: int = 60, history_size: int = 60):
        """
        初始化资源监控器

        参数:
            sample_interval (int, optional): 采样间隔，单位为秒。默认为60
            history_size (int, optional): 历史记录大小。默认为60
        """
        self._sample_interval = sample_interval
        self._history = deque(maxlen=history_size)
        self._running = False
        self._worker = None
        self._lock = threading.RLock()
        self._message_bus = None

        # 警报阈值
        self._thresholds = {
            "cpu_percent": 80.0,  # CPU使用率超过80%触发警报
            "memory_percent": 80.0,  # 内存使用率超过80%触发警报
            "disk_percent": 90.0,  # 磁盘使用率超过90%触发警报
        }

    def set_message_bus(self, message_bus: MessageBus):
        """
        设置消息总线实例

        参数:
            message_bus (MessageBus): 消息总线实例
        """
        self._message_bus = message_bus

    def start(self):
        """启动资源监控"""
        with self._lock:
            if not self._running:
                self._running = True
                self._worker = threading.Thread(target=self._monitor_loop, daemon=True)
                self._worker.start()
                logger.info("Resource monitor started")

    def _monitor_loop(self):
        """资源监控循环"""
        while self._running:
            try:
                # 获取当前资源使用情况
                resources = self._sample_resources()

                with self._lock:
                    # 添加到历史记录
                    self._history.append(resources)

                    # 检查是否需要触发警报
                    self._check_alerts(resources)

            except Exception as e:
                logger.error(f"Error in resource monitoring: {e}")

            # 等待下一个采样周期
            time.sleep(self._sample_interval)

    def _sample_resources(self) -> Dict:
        """
        采样当前系统资源使用情况

        返回:
            Dict: 当前资源使用情况
        """
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')

        return {
            "timestamp": datetime.now().isoformat(),
            "cpu": {
                "percent": cpu_percent,
                "count": psutil.cpu_count()
            },
            "memory": {
                "total": memory.total,
                "available": memory.available,
                "used": memory.used,
                "percent": memory.percent
            },
            "disk": {
                "total": disk.total,
                "used": disk.used,
                "free": disk.free,
                "percent": disk.percent
            },
            "network": self._get_network_info(),
            "platform": platform.platform()
        }

    def _get_network_info(self) -> Dict:
        """
        获取网络信息

        返回:
            Dict: 网络信息
        """
        try:
            net_io = psutil.net_io_counters()
            return {
                "bytes_sent": net_io.bytes_sent,
                "bytes_recv": net_io.bytes_recv,
                "packets_sent": net_io.packets_sent,
                "packets_recv": net_io.packets_recv
            }
        except Exception:
            return {}

    def _check_alerts(self, resources: Dict):
        """
        检查资源使用情况是否超过阈值，如果超过则发送警报

        参数:
            resources (Dict): 当前资源使用情况
        """
        if not self._message_bus:
            return

        alerts = []

        # 检查CPU使用率
        if resources["cpu"]["percent"] > self._thresholds["cpu_percent"]:
            alerts.append({
                "type": "cpu_high",
                "value": resources["cpu"]["percent"],
                "threshold": self._thresholds["cpu_percent"]
            })

        # 检查内存使用率
        if resources["memory"]["percent"] > self._thresholds["memory_percent"]:
            alerts.append({
                "type": "memory_high",
                "value": resources["memory"]["percent"],
                "threshold": self._thresholds["memory_percent"]
            })

        # 检查磁盘使用率
        if resources["disk"]["percent"] > self._thresholds["disk_percent"]:
            alerts.append({
                "type": "disk_high",
                "value": resources["disk"]["percent"],
                "threshold": self._thresholds["disk_percent"]
            })

        # 发送警报
        for alert in alerts:
            self._message_bus.publish(Message(
                source="ResourceMonitor",
                destination="system",
                msg_type="resource.alert",
                priority=Message.PRIORITY_HIGH,
                payload={
                    "alert": alert,
                    "resources": resources
                }
            ))

            logger.warning(f"Resource alert: {alert['type']} - "
                         f"Current: {alert['value']}%, Threshold: {alert['threshold']}%")

    def get_system_resources(self) -> Dict:
        """
        获取当前系统资源使用情况

        返回:
            Dict: 当前资源使用情况
        """
        return self._sample_resources()

    def get_resource_history(self) -> Dict:
        """
        获取资源使用历史记录

        返回:
            Dict: 包含历史数据的字典
        """
        with self._lock:
            history_list = list(self._history)

        # 提取时间序列数据
        timestamps = [item["timestamp"] for item in history_list]

        cpu = [item["cpu"]["percent"] for item in history_list]
        memory = [item["memory"]["percent"] for item in history_list]
        disk = [item["disk"]["percent"] for item in history_list]

        return {
            "timestamps": timestamps,
            "cpu": cpu,
            "memory": memory,
            "disk": disk,
            "samples": history_list
        }

    def set_alert_threshold(self, resource: str, threshold: float) -> bool:
        """
        设置警报阈值

        参数:
            resource (str): 资源类型，可以是"cpu_percent", "memory_percent", "disk_percent"
            threshold (float): 阈值

        返回:
            bool: 设置是否成功
        """
        if resource not in self._thresholds:
            return False

        with self._lock:
            self._thresholds[resource] = threshold

        return True

    def shutdown(self) -> None:
        """关闭资源监控器"""
        with self._lock:
            self._running = False

        if self._worker and self._worker.is_alive():
            self._worker.join(timeout=2.0)

        logger.info("Resource monitor shut down")

# =================================================================================
# 配置管理 - 管理系统配置
# =================================================================================

class Config:
    """
    系统配置管理

    管理系统配置选项，支持从文件加载和保存到文件
    """

    def __init__(self, config_path: str = "config.json"):
        """
        初始化配置管理器

        参数:
            config_path (str, optional): 配置文件路径。默认为"config.json"
        """
        self._config_path = config_path
        self._config = {}
        self._lock = threading.RLock()

        # 尝试加载配置文件
        self._load()

        # 如果配置为空，创建默认配置
        if not self._config:
            self._create_default_config()
            self._save()

    def _load(self) -> bool:
        """
        从文件加载配置

        返回:
            bool: 加载是否成功
        """
        try:
            if os.path.exists(self._config_path):
                with open(self._config_path, 'r') as f:
                    self._config = json.load(f)
                return True
        except Exception as e:
            logger.error(f"Error loading config: {e}")

        return False

    def _save(self) -> bool:
        """
        保存配置到文件

        返回:
            bool: 保存是否成功
        """
        try:
            with open(self._config_path, 'w') as f:
                json.dump(self._config, f, indent=2)
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")

        return False

    def _create_default_config(self) -> None:
        """创建默认配置"""
        self._config = {
            "system": {
                "name": "ASSEMBLY-CTRL System",
                "version": "1.0.0",
                "log_level": "INFO"
            },
            "modules": {
                "auto_start": ["ErrorHandler", "MessageBus", "ModuleRegistry", "ResourceMonitor"]
            },
            "message_bus": {
                "max_workers": 5,
                "queue_size": 1000
            },
            "resource_monitor": {
                "sample_interval": 60,
                "history_size": 60,
                "thresholds": {
                    "cpu_percent": 80.0,
                    "memory_percent": 80.0,
                    "disk_percent": 90.0
                }
            }
        }

    def get(self, key: str, default: Any = None) -> Any:
        """
        获取配置项

        参数:
            key (str): 配置项的键，支持点号分隔的路径，如"system.name"
            default (Any, optional): 如果配置项不存在，返回的默认值。默认为None

        返回:
            Any: 配置项的值
        """
        with self._lock:
            if not key:
                return default

            # 支持点号分隔的路径
            parts = key.split('.')
            value = self._config

            for part in parts:
                if isinstance(value, dict) and part in value:
                    value = value[part]
                else:
                    return default

            return value

    def set(self, key: str, value: Any, save: bool = True) -> None:
        """
        设置配置项

        参数:
            key (str): 配置项的键，支持点号分隔的路径，如"system.name"
            value (Any): 配置项的值
            save (bool, optional): 是否立即保存配置到文件。默认为True
        """
        if not key:
            return

        with self._lock:
            # 支持点号分隔的路径
            parts = key.split('.')
            config = self._config

            # 导航到最后一级的父节点
            for part in parts[:-1]:
                if part not in config:
                    config[part] = {}
                config = config[part]

            # 设置值
            config[parts[-1]] = value

            # 保存到文件
            if save:
                self._save()

    def get_all(self) -> Dict:
        """
        获取所有配置

        返回:
            Dict: 包含所有配置的字典
        """
        with self._lock:
            return self._config.copy()

    def reload(self) -> bool:
        """
        重新加载配置文件

        返回:
            bool: 重新加载是否成功
        """
        with self._lock:
            return self._load()

    def reset_to_default(self) -> None:
        """重置为默认配置"""
        with self._lock:
            self._create_default_config()
            self._save()

# =================================================================================
# 系统初始化函数 - 创建并连接所有基础组件
# =================================================================================

def initialize_system():
    """
    初始化ASSEMBLY-CTRL系统基础组件

    创建并连接所有基础组件

    返回:
        tuple: 包含所有初始化的组件
    """
    # 创建组件
    config = Config()
    error_handler = ErrorHandler()
    message_bus = MessageBus()
    module_registry = ModuleRegistry()
    resource_monitor = ResourceMonitor(
        sample_interval=config.get("resource_monitor.sample_interval", 60),
        history_size=config.get("resource_monitor.history_size", 60)
    )

    # 连接组件
    module_registry.set_message_bus(message_bus)
    resource_monitor.set_message_bus(message_bus)

    # 启动组件
    message_bus.start()
    resource_monitor.start()

    # 注册错误处理回调
    def log_error(error):
        print(f"ERROR: {error}")

    error_handler.register_callback(log_error)

    # 注册模块
    module_registry.register_module(
        module_id="error_handler",
        name="Error Handler",
        description="处理系统错误",
        status=ModuleRegistry.STATUS_ONLINE
    )

    module_registry.register_module(
        module_id="message_bus",
        name="Message Bus",
        description="模块间通信总线",
        status=ModuleRegistry.STATUS_ONLINE
    )

    module_registry.register_module(
        module_id="module_registry",
        name="Module Registry",
        description="模块注册和发现服务",
        status=ModuleRegistry.STATUS_ONLINE
    )

    module_registry.register_module(
        module_id="resource_monitor",
        name="Resource Monitor",
        description="系统资源监控",
        status=ModuleRegistry.STATUS_ONLINE
    )

    return (config, error_handler, message_bus, module_registry, resource_monitor)

# =================================================================================
# 主函数 - 程序入口点
# =================================================================================

def main():
    """
    ASSEMBLY-CTRL系统主函数

    初始化并运行基础组件
    """
    print("====================================================")
    print("        ASSEMBLY-CTRL System - Phase 1              ")
    print("            基础框架初始化中...                      ")
    print("====================================================")

    try:
        # 初始化系统
        config, error_handler, message_bus, module_registry, resource_monitor = initialize_system()

        print("\n初始化完成！系统基础框架已就绪。")
        print("已启动的模块:")

        for module_id, module in module_registry.get_all_modules().items():
            print(f"  - {module['name']} ({module_id}): {module['status']}")

        print("\n系统资源使用情况:")
        resources = resource_monitor.get_system_resources()
        print(f"  CPU: {resources['cpu']['percent']}% ({resources['cpu']['count']} cores)")
        print(f"  内存: {resources['memory']['percent']}% ({resources['memory']['used'] / (1024**3):.2f} GB / {resources['memory']['total'] / (1024**3):.2f} GB)")
        print(f"  磁盘: {resources['disk']['percent']}% ({resources['disk']['used'] / (1024**3):.2f} GB / {resources['disk']['total'] / (1024**3):.2f} GB)")

        print("\n按Ctrl+C退出...")

        # 保持程序运行，直到用户按下Ctrl+C
        while True:
            time.sleep(1)

    except KeyboardInterrupt:
        print("\n正在关闭系统...")

        # 关闭组件
        resource_monitor.shutdown()
        message_bus.shutdown()
        module_registry.shutdown()

        print("系统已安全关闭。")

    except Exception as e:
        print(f"系统初始化失败: {e}")
        traceback.print_exc()
        return 1

    return 0

if __name__ == "__main__":
    sys.exit(main())

==================== [第二阶段 - 总控模块] ====================
"""
总装窗口模块 - 系统集成中心，负责管理和协调所有其他模块
"""
import json
import logging
import uuid
from typing import Dict, Any, Optional

from core.error_handler import ErrorHandler
from core.message_bus import MessageBus, Message
from core.module_registry import ModuleRegistry
from core.resource_manager import ResourceMonitor
from utils.config import Config

# =================================================================================
# 1. 总装窗口(AC) - 系统集成中心，负责管理和协调所有其他模块
# =================================================================================
class AssemblyCtrl:
    """总装窗口：系统集成中心，负责管理和协调所有其他模块

    该类是系统的中央控制器，负责：
    - 系统的初始化和配置加载
    - 管理所有模块的生命周期（初始化、启动、停止）
    - 监控系统状态
    - 提供命令执行接口
    - 处理关键系统事件
    - 作为任务提交的入口点

    Attributes:
        config (Config): 系统配置对象
        message_bus (MessageBus): 消息总线实例
        error_handler (ErrorHandler): 错误处理器实例
        module_registry (ModuleRegistry): 模块注册表实例
        resource_monitor (ResourceMonitor): 资源监控器实例
        _is_initialized (bool): 系统是否已初始化
        _is_running (bool): 系统是否正在运行
        _registered_modules (Dict): 已注册模块的记录
        _tasks (Dict): 当前任务记录
    """

    def __init__(self, config_path: str = "config.json"):
        """初始化总装窗口

        Args:
            config_path (str): 配置文件的路径，默认为"config.json"
        """
        self.logger = logging.getLogger("AssemblyCtrl")
        self.logger.info("初始化总装窗口...")

        # 系统组件
        self.config = None
        self.message_bus = None
        self.error_handler = None
        self.module_registry = None
        self.resource_monitor = None

        # 状态跟踪
        self._is_initialized = False
        self._is_running = False
        self._registered_modules = {}
        self._tasks = {}

        # 加载配置
        self._config_path = config_path

        self.logger.info("总装窗口初始化完成")

    def initialize(self) -> bool:
        """初始化系统，创建和配置所有核心组件

        Returns:
            bool: 初始化是否成功
        """
        if self._is_initialized:
            self.logger.warning("系统已经初始化，忽略重复操作")
            return True

        try:
            self.logger.info("开始系统初始化...")

            # 1. 加载配置
            self.logger.info("加载系统配置...")
            self.config = Config(self._config_path)

            # 2. 创建错误处理器
            self.logger.info("创建错误处理器...")
            self.error_handler = ErrorHandler(self.config)

            # 3. 创建消息总线
            self.logger.info("创建消息总线...")
            self.message_bus = MessageBus(self.error_handler)

            # 4. 创建模块注册表
            self.logger.info("创建模块注册表...")
            self.module_registry = ModuleRegistry(self.message_bus, self.error_handler)

            # 5. 创建资源监控器
            self.logger.info("创建资源监控器...")
            self.resource_monitor = ResourceMonitor(self.config, self.message_bus, self.error_handler)

            # 6. 注册消息处理器
            self._register_message_handlers()

            self._is_initialized = True
            self.logger.info("系统初始化完成")
            return True

        except Exception as e:
            self.logger.error(f"系统初始化失败: {str(e)}")
            if self.error_handler:
                self.error_handler.handle_error("AssemblyCtrl.initialize", "系统初始化失败", str(e))
            return False

    def _register_message_handlers(self) -> None:
        """注册所有消息处理函数
        """
        self.message_bus.subscribe("system.startup", self._handle_system_startup)
        self.message_bus.subscribe("system.shutdown", self._handle_system_shutdown)
        self.message_bus.subscribe("system.error", self._handle_system_error)
        self.message_bus.subscribe("module.registered", self._handle_module_registered)
        self.message_bus.subscribe("module.unregistered", self._handle_module_unregistered)
        self.message_bus.subscribe("task.submission", self._handle_task_submission)
        self.message_bus.subscribe("task.result", self._handle_task_result)
        self.message_bus.subscribe("direct.assembly_ctrl", self._handle_direct_message)

    def start(self) -> bool:
        """启动系统，初始化并启动所有注册的模块

        Returns:
            bool: 启动是否成功
        """
        if not self._is_initialized:
            self.logger.error("无法启动未初始化的系统")
            return False

        if self._is_running:
            self.logger.warning("系统已经在运行，忽略重复操作")
            return True

        try:
            self.logger.info("开始启动系统...")

            # 1. 启动错误处理器
            self.error_handler.start()

            # 2. 启动消息总线
            self.message_bus.start()

            # 3. 启动模块注册表
            self.module_registry.start()

            # 4. 启动资源监控器
            self.resource_monitor.start()

            # 5. 广播系统启动消息
            startup_message = Message(
                message_id=str(uuid.uuid4()),
                source="assembly_ctrl",
                destination="broadcast",
                priority="high",
                type="system.startup",
                payload={"timestamp": self.resource_monitor.get_current_time()},
                metadata={}
            )
            self.message_bus.send(startup_message)

            self._is_running = True
            self.logger.info("系统启动完成")
            return True

        except Exception as e:
            self.logger.error(f"系统启动失败: {str(e)}")
            self.error_handler.handle_error("AssemblyCtrl.start", "系统启动失败", str(e))
            return False

    def stop(self) -> bool:
        """停止系统，关闭所有模块并释放资源

        Returns:
            bool: 停止是否成功
        """
        if not self._is_running:
            self.logger.warning("系统未运行，忽略停止操作")
            return True

        try:
            self.logger.info("开始停止系统...")

            # 1. 广播系统关闭消息
            shutdown_message = Message(
                message_id=str(uuid.uuid4()),
                source="assembly_ctrl",
                destination="broadcast",
                priority="high",
                type="system.shutdown",
                payload={"timestamp": self.resource_monitor.get_current_time()},
                metadata={}
            )
            self.message_bus.send(shutdown_message)

            # 2. 等待所有任务完成或取消（简化版，实际实现可能需要更复杂的逻辑）
            # 实际实现可能会涉及设置超时，或强制取消任务

            # 3. 停止所有组件，顺序与启动相反
            self.resource_monitor.stop()
            self.module_registry.stop()
            self.message_bus.stop()
            self.error_handler.stop()

            self._is_running = False
            self.logger.info("系统停止完成")
            return True

        except Exception as e:
            self.logger.error(f"系统停止失败: {str(e)}")
            self.error_handler.handle_error("AssemblyCtrl.stop", "系统停止失败", str(e))
            return False

    def get_system_status(self) -> Dict:
        """获取系统当前状态的摘要信息

        Returns:
            Dict: 包含系统状态信息的字典
        """
        status = {
            "is_initialized": self._is_initialized,
            "is_running": self._is_running,
            "registered_modules": len(self._registered_modules),
            "active_tasks": len(self._tasks),
            "resources": self.resource_monitor.get_resource_usage() if self._is_initialized else {},
            "uptime": self.resource_monitor.get_uptime() if self._is_initialized else 0,
            "error_count": self.error_handler.get_error_count() if self._is_initialized else 0,
            "message_count": self.message_bus.get_message_count() if self._is_initialized else 0
        }
        return status

    def execute_command(self, command: str, args: Dict = None) -> Dict:
        """执行系统命令

        Args:
            command (str): 要执行的命令
            args (Dict, optional): 命令参数。默认为None

        Returns:
            Dict: 命令执行结果
        """
        if args is None:
            args = {}

        if not self._is_running and command not in ["initialize", "start"]:
            return {"success": False, "error": "系统未运行，无法执行命令"}

        try:
            result = {"success": True, "command": command, "result": None}

            # 处理不同类型的命令
            if command == "initialize":
                result["result"] = self.initialize()

            elif command == "start":
                result["result"] = self.start()

            elif command == "stop":
                result["result"] = self.stop()

            elif command == "status":
                result["result"] = self.get_system_status()

            elif command == "submit_task":
                if "task_data" not in args:
                    return {"success": False, "error": "缺少任务数据"}
                task_id = self._submit_task(args["task_data"])
                result["result"] = {"task_id": task_id}

            elif command == "get_task_status":
                if "task_id" not in args:
                    return {"success": False, "error": "缺少任务ID"}
                task_id = args["task_id"]
                if task_id in self._tasks:
                    result["result"] = self._tasks[task_id]
                else:
                    result["success"] = False
                    result["error"] = f"找不到任务ID: {task_id}"

            elif command == "list_modules":
                result["result"] = list(self._registered_modules.keys())

            else:
                # 如果命令不是系统内置命令，则转发到对应模块
                if "module" not in args:
                    return {"success": False, "error": "未指定目标模块"}

                module = args["module"]
                if module not in self._registered_modules:
                    return {"success": False, "error": f"模块不存在: {module}"}

                # 构造消息并发送
                message = Message(
                    message_id=str(uuid.uuid4()),
                    source="assembly_ctrl",
                    destination=module,
                    priority="medium",
                    type="command.execute",
                    payload={
                        "command": command,
                        "args": {k: v for k, v in args.items() if k != "module"}
                    },
                    metadata={}
                )

                # 实际实现可能需要等待响应的机制
                # 这里简化处理，只返回消息已发送
                self.message_bus.send(message)
                result["result"] = {"message": "命令已发送至模块"}

            return result

        except Exception as e:
            self.error_handler.handle_error("AssemblyCtrl.execute_command", f"执行命令失败: {command}", str(e))
            return {"success": False, "error": str(e)}

    def _submit_task(self, task_data: Dict) -> str:
        """提交任务到系统

        Args:
            task_data (Dict): 任务数据

        Returns:
            str: 生成的任务ID
        """
        # 生成任务ID
        task_id = str(uuid.uuid4())

        # 记录任务
        task_info = {
            "id": task_id,
            "data": task_data,
            "status": "submitted",
            "submit_time": self.resource_monitor.get_current_time(),
            "update_time": self.resource_monitor.get_current_time(),
            "result": None,
            "error": None
        }

        # 添加到任务列表
        self._tasks[task_id] = task_info

        # 构造任务提交消息
        task_message = Message(
            message_id=str(uuid.uuid4()),
            source="assembly_ctrl",
            destination="nerve_hq",  # 发送到主控平台
            priority="medium",
            type="task.submission",
            payload={
                "task_id": task_id,
                "task_data": task_data
            },
            metadata={}
        )

        # 发送消息
        self.message_bus.send(task_message)
        self.logger.info(f"任务已提交: {task_id}")

        return task_id

    # =================================================================================
    # 消息处理函数
    # =================================================================================

    def _handle_system_startup(self, message: Message) -> None:
        """处理系统启动消息

        Args:
            message (Message): 消息对象
        """
        source = message.source
        self.logger.info(f"接收到系统启动消息，来源: {source}")
        # 如果是自己发送的消息，则忽略
        if source == "assembly_ctrl":
            return

        # 记录其他模块的启动
        if source in self._registered_modules:
            self._registered_modules[source]["status"] = "running"
            self.logger.info(f"模块已启动: {source}")

    def _handle_system_shutdown(self, message: Message) -> None:
        """处理系统关闭消息

        Args:
            message (Message): 消息对象
        """
        source = message.source
        self.logger.info(f"接收到系统关闭消息，来源: {source}")

        # 如果是自己发送的消息，则忽略
        if source == "assembly_ctrl":
            return

        # 记录其他模块的关闭
        if source in self._registered_modules:
            self._registered_modules[source]["status"] = "stopped"
            self.logger.info(f"模块已停止: {source}")

    def _handle_system_error(self, message: Message) -> None:
        """处理系统错误消息

        Args:
            message (Message): 消息对象
        """
        error_data = message.payload
        source = message.source
        error_module = error_data.get("module", "unknown")
        error_type = error_data.get("type", "unknown")
        error_message = error_data.get("message", "no message")

        self.logger.error(f"系统错误: 来源={source}, 模块={error_module}, 类型={error_type}, 消息={error_message}")

        # 更新模块状态
        if error_module in self._registered_modules:
            self._registered_modules[error_module]["last_error"] = {
                "type": error_type,
                "message": error_message,
                "timestamp": self.resource_monitor.get_current_time()
            }

        # 对严重错误可能需要系统级别的响应
        if error_data.get("severity", "medium") == "critical":
            self.logger.critical(f"检测到严重错误: {error_message}")
            # 实际实现可能会有紧急处理逻辑

    def _handle_module_registered(self, message: Message) -> None:
        """处理模块注册消息

        Args:
            message (Message): 消息对象
        """
        module_data = message.payload
        module_name = module_data.get("name", "unknown")
        module_type = module_data.get("type", "unknown")
        module_capabilities = module_data.get("capabilities", [])

        self.logger.info(f"模块已注册: {module_name}, 类型: {module_type}")

        # 记录模块信息
        self._registered_modules[module_name] = {
            "name": module_name,
            "type": module_type,
            "capabilities": module_capabilities,
            "status": "registered",
            "register_time": self.resource_monitor.get_current_time(),
            "last_update": self.resource_monitor.get_current_time(),
            "last_error": None
        }

    def _handle_module_unregistered(self, message: Message) -> None:
        """处理模块注销消息

        Args:
            message (Message): 消息对象
        """
        module_data = message.payload
        module_name = module_data.get("name", "unknown")

        self.logger.info(f"模块已注销: {module_name}")

        # 从记录中移除模块
        if module_name in self._registered_modules:
            del self._registered_modules[module_name]
            self.logger.info(f"已移除模块记录: {module_name}")

    def _handle_task_submission(self, message: Message) -> None:
        """处理任务提交消息

        Args:
            message (Message): 消息对象
        """
        # 此函数主要用于外部任务提交的处理
        # 内部任务已在_submit_task中处理

        # 只处理来自其他模块的任务提交
        if message.source == "assembly_ctrl":
            return

        task_data = message.payload.get("task_data", {})

        # 提交任务并获取任务ID
        task_id = self._submit_task(task_data)

        # 如果消息要求响应，则发送响应
        if message.metadata.get("require_response", False):
            response = Message(
                message_id=str(uuid.uuid4()),
                source="assembly_ctrl",
                destination=message.source,
                priority="medium",
                type="task.submission.response",
                payload={
                    "original_message_id": message.message_id,
                    "task_id": task_id
                },
                metadata={}
            )
            self.message_bus.send(response)

    def _handle_task_result(self, message: Message) -> None:
        """处理任务结果消息

        Args:
            message (Message): 消息对象
        """
        result_data = message.payload
        task_id = result_data.get("task_id", "unknown")
        success = result_data.get("success", False)
        result = result_data.get("result", None)
        error = result_data.get("error", None)

        # 更新任务记录
        if task_id in self._tasks:
            self._tasks[task_id].update({
                "status": "completed" if success else "failed",
                "update_time": self.resource_monitor.get_current_time(),
                "result": result,
                "error": error
            })

            self.logger.info(f"任务完成: {task_id}, 成功: {success}")

            # 检查是否需要通知提交者
            if "notify" in self._tasks[task_id].get("data", {}):
                notify_target = self._tasks[task_id]["data"]["notify"]

                # 发送通知消息
                notification = Message(
                    message_id=str(uuid.uuid4()),
                    source="assembly_ctrl",
                    destination=notify_target,
                    priority="medium",
                    type="task.notification",
                    payload={
                        "task_id": task_id,
                        "success": success,
                        "result": result,
                        "error": error
                    },
                    metadata={}
                )
                self.message_bus.send(notification)
        else:
            self.logger.warning(f"收到未知任务的结果: {task_id}")

    def _handle_direct_message(self, message: Message) -> None:
        """处理直接发送给总装窗口的消息

        Args:
            message (Message): 消息对象
        """
        source = message.source
        message_type = message.type
        payload = message.payload

        self.logger.info(f"收到直接消息: 来源={source}, 类型={message_type}")

        # 处理不同类型的直接消息
        if message_type == "command.execute":
            command = payload.get("command", "")
            args = payload.get("args", {})

            result = self.execute_command(command, args)

            # 发送响应
            response = Message(
                message_id=str(uuid.uuid4()),
                source="assembly_ctrl",
                destination=source,
                priority="medium",
                type="command.response",
                payload={
                    "original_message_id": message.message_id,
                    "result": result
                },
                metadata={}
            )
            self.message_bus.send(response)

        elif message_type == "status.request":
            status = self.get_system_status()

            # 发送响应
            response = Message(
                message_id=str(uuid.uuid4()),
                source="assembly_ctrl",
                destination=source,
                priority="medium",
                type="status.response",
                payload={
                    "original_message_id": message.message_id,
                    "status": status
                },
                metadata={}
            )
            self.message_bus.send(response)
"""
主控平台模块 - 系统控制中心，负责任务调度和模块协调
"""
import logging
import queue
import threading
import time
import uuid
from typing import Dict, Any, Optional

from core.error_handler import ErrorHandler
from core.message_bus import MessageBus, Message
from core.module_registry import ModuleRegistry
from utils.config import Config

# =================================================================================
# 2. 主控平台(NHQ) - 系统控制中心，负责任务调度和模块协调
# =================================================================================
class NerveHQ:
    """主控平台窗口：系统控制中心，负责任务调度和模块协调

    该类是系统的任务处理中枢，负责：
    - 管理任务队列
    - 基于优先级的任务调度
    - 模块能力缓存和发现
    - 任务分发和路由
    - 结果收集和处理
    - 任务状态追踪

    Attributes:
        config (Config): 系统配置对象
        message_bus (MessageBus): 消息总线实例
        error_handler (ErrorHandler): 错误处理器实例
        module_registry (ModuleRegistry): 模块注册表实例 (从ModuleRegistry获取)
        _task_queue (Dict): 任务队列，按优先级分类
        _task_info (Dict): 任务信息记录
        _module_capabilities (Dict): 模块能力缓存
        _workers (List): 工作线程列表
        _running (bool): 平台是否正在运行
    """

    def __init__(self, config: Config = None, message_bus: MessageBus = None,
                 error_handler: ErrorHandler = None):
        """初始化主控平台

        Args:
            config (Config, optional): 配置对象。默认为None
            message_bus (MessageBus, optional): 消息总线实例。默认为None
            error_handler (ErrorHandler, optional): 错误处理器实例。默认为None
        """
        self.logger = logging.getLogger("NerveHQ")
        self.logger.info("初始化主控平台...")

        # 初始化系统组件引用
        self.config = config
        self.message_bus = message_bus
        self.error_handler = error_handler
        self.module_registry = None  # 将在_register_module中获取

        # 初始化任务队列（按优先级）
        self._task_queue = {
            "high": queue.PriorityQueue(),
            "medium": queue.PriorityQueue(),
            "low": queue.PriorityQueue()
        }

        # 任务信息和状态追踪
        self._task_info = {}

        # 模块能力缓存
        self._module_capabilities = {}

        # 工作线程
        self._workers = []
        self._worker_count = 4  # 默认工作线程数
        self._running = False

        # 线程安全锁
        self._task_info_lock = threading.Lock()
        self._module_capabilities_lock = threading.Lock()

        # 任务统计
        self._stats = {
            "submitted": 0,
            "completed": 0,
            "failed": 0,
            "processing": 0
        }
        self._stats_lock = threading.Lock()

        self.logger.info("主控平台初始化完成")

    def _register_module(self) -> None:
        """向模块注册表注册自身，并获取模块注册表引用
        """
        if self.module_registry is None:
            # 从消息总线中获取模块注册表引用
            self.module_registry = self.message_bus.get_module_registry()

        # 注册自身到模块注册表
        capabilities = [
            "task.scheduling",
            "task.routing",
            "task.tracking"
        ]

        self.module_registry.register_module(
            name="nerve_hq",
            module_type="core",
            capabilities=capabilities,
            description="系统控制中心，负责任务调度和模块协调"
        )

        # 注册消息处理函数
        self.message_bus.subscribe("task.submit", self._handle_task_submit)
        self.message_bus.subscribe("task.result", self._handle_task_result)
        self.message_bus.subscribe("module.registered", self._handle_module_registered)
        self.message_bus.subscribe("module.capability.update", self._handle_capability_update)

        self.logger.info("主控平台已注册到模块注册表")

    def start(self) -> bool:
        """启动主控平台，包括任务处理线程

        Returns:
            bool: 启动是否成功
        """
        if self._running:
            self.logger.warning("主控平台已经在运行")
            return True

        try:
            self.logger.info("启动主控平台...")

            # 注册模块
            self._register_module()

            # 启动工作线程
            self._running = True
            for i in range(self._worker_count):
                worker = threading.Thread(
                    target=self._task_worker,
                    name=f"NerveHQ-Worker-{i}",
                    daemon=True
                )
                worker.start()
                self._workers.append(worker)
                self.logger.info(f"启动工作线程: {worker.name}")

            # 发送状态更新消息
            status_message = Message(
                message_id=str(uuid.uuid4()),
                source="nerve_hq",
                destination="broadcast",
                priority="medium",
                type="system.startup",
                payload={"module": "nerve_hq", "status": "running"},
                metadata={}
            )
            self.message_bus.send(status_message)

            self.logger.info("主控平台启动完成")
            return True

        except Exception as e:
            self.logger.error(f"主控平台启动失败: {str(e)}")
            if self.error_handler:
                self.error_handler.handle_error("NerveHQ.start", "主控平台启动失败", str(e))
            return False

    def stop(self) -> bool:
        """停止主控平台，包括任务处理线程

        Returns:
            bool: 停止是否成功
        """
        if not self._running:
            self.logger.warning("主控平台未运行")
            return True

        try:
            self.logger.info("停止主控平台...")

            # 设置停止标志
            self._running = False

            # 等待所有工作线程结束（设置超时）
            wait_timeout = 5.0  # 5秒超时
            start_time = time.time()
            for worker in self._workers:
                remaining_time = wait_timeout - (time.time() - start_time)
                if remaining_time > 0:
                    worker.join(timeout=remaining_time)

            # 清空工作线程列表
            self._workers.clear()

            # 发送状态更新消息
            status_message = Message(
                message_id=str(uuid.uuid4()),
                source="nerve_hq",
                destination="broadcast",
                priority="medium",
                type="system.shutdown",
                payload={"module": "nerve_hq", "status": "stopped"},
                metadata={}
            )
            self.message_bus.send(status_message)

            self.logger.info("主控平台停止完成")
            return True

        except Exception as e:
            self.logger.error(f"主控平台停止失败: {str(e)}")
            if self.error_handler:
                self.error_handler.handle_error("NerveHQ.stop", "主控平台停止失败", str(e))
            return False

    def submit_task(self, task_data: Dict, priority: str = "medium") -> str:
        """提交任务到系统

        Args:
            task_data (Dict): 任务数据
            priority (str, optional): 任务优先级，可选值：high, medium, low。默认为"medium"

        Returns:
            str: 生成的任务ID
        """
        # 验证优先级有效性
        if priority not in self._task_queue:
            priority = "medium"
            self.logger.warning(f"无效的优先级: {priority}，使用默认值: medium")

        # 生成任务ID
        task_id = str(uuid.uuid4())

        # 记录任务信息
        task_info = {
            "id": task_id,
            "data": task_data,
            "priority": priority,
            "status": "pending",
            "submit_time": time.time(),
            "start_time": None,
            "end_time": None,
            "assigned_module": None,
            "result": None,
            "error": None
        }

        # 更新统计数据
        with self._stats_lock:
            self._stats["submitted"] += 1

        # 添加到任务信息记录
        with self._task_info_lock:
            self._task_info[task_id] = task_info

        # 计算任务优先级值（使用提交时间作为排序依据）
        # 数值越小，优先级越高
        priority_value = time.time()

        # 添加到相应的任务队列
        self._task_queue[priority].put((priority_value, task_id))

        self.logger.info(f"任务已提交: {task_id}, 优先级: {priority}")
        return task_id

    def get_task_status(self, task_id: str) -> Dict:
        """获取任务状态信息

        Args:
            task_id (str): 任务ID

        Returns:
            Dict: 任务状态信息，如果任务不存在则返回None
        """
        with self._task_info_lock:
            if task_id in self._task_info:
                return self._task_info[task_id].copy()
            return None

    def get_stats(self) -> Dict:
        """获取任务统计信息

        Returns:
            Dict: 任务统计信息
        """
        with self._stats_lock:
            stats = self._stats.copy()

        # 添加队列长度信息
        stats["queue_length"] = {
            "high": self._task_queue["high"].qsize(),
            "medium": self._task_queue["medium"].qsize(),
            "low": self._task_queue["low"].qsize()
        }

        return stats

    def _task_worker(self) -> None:
        """任务处理工作线程
        """
        thread_name = threading.current_thread().name
        self.logger.info(f"工作线程启动: {thread_name}")

        while self._running:
            try:
                # 按优先级顺序检查队列
                task_id = None
                for priority in ["high", "medium", "low"]:
                    try:
                        # 非阻塞模式检查队列
                        _, task_id = self._task_queue[priority].get(block=False)
                        break  # 找到任务，跳出循环
                    except queue.Empty:
                        continue  # 队列为空，检查下一个队列

                # 如果所有队列都为空，休眠一段时间
                if task_id is None:
                    time.sleep(0.1)
                    continue

                # 获取任务信息
                with self._task_info_lock:
                    if task_id not in self._task_info:
                        self.logger.warning(f"找不到任务信息: {task_id}")
                        continue

                    task_info = self._task_info[task_id]
                    # 更新任务状态
                    task_info["status"] = "processing"
                    task_info["start_time"] = time.time()

                # 处理任务
                self.logger.info(f"开始处理任务: {task_id}")

                # 更新统计数据
                with self._stats_lock:
                    self._stats["processing"] += 1

                # 处理任务
                self._process_task(task_id, task_info)

                # 标记队列任务已完成
                self._task_queue[task_info["priority"]].task_done()

            except Exception as e:
                self.logger.error(f"任务处理线程异常: {str(e)}")
                if self.error_handler:
                    self.error_handler.handle_error("NerveHQ._task_worker", "任务处理线程异常", str(e))
                time.sleep(1)  # 防止异常频繁发生导致CPU占用过高

        self.logger.info(f"工作线程退出: {thread_name}")

    def _process_task(self, task_id: str, task_info: Dict) -> None:
        """处理单个任务

        Args:
            task_id (str): 任务ID
            task_info (Dict): 任务信息
        """
        try:
            task_data = task_info["data"]
            task_type = task_data.get("type", "unknown")

            # 基于任务类型选择目标模块
            target_module = self._select_target_module(task_type, task_data)

            if target_module is None:
                error_msg = f"找不到能处理任务类型的模块: {task_type}"
                self.logger.error(error_msg)
                self._complete_task(task_id, False, error=error_msg)
                return

            # 更新任务分配信息
            with self._task_info_lock:
                if task_id in self._task_info:
                    self._task_info[task_id]["assigned_module"] = target_module

            # 构造任务处理消息
            task_message = Message(
                message_id=str(uuid.uuid4()),
                source="nerve_hq",
                destination=target_module,
                priority=task_info["priority"],
                type="task.process",
                payload={
                    "task_id": task_id,
                    "task_data": task_data
                },
                metadata={"require_response": True}
            )

            # 发送任务处理消息
            self.message_bus.send(task_message)
            self.logger.info(f"任务已分配给模块: {target_module}, 任务ID: {task_id}")

            # 实际实现可能需要设置超时和重试机制
            # 但为简化，这里我们不等待响应，而是依赖异步的任务结果消息

        except Exception as e:
            error_msg = f"任务处理失败: {str(e)}"
            self.logger.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error("NerveHQ._process_task", "任务处理失败", str(e))
            self._complete_task(task_id, False, error=error_msg)

    def _select_target_module(self, task_type: str, task_data: Dict) -> Optional[str]:
        """基于任务类型和数据选择合适的目标模块

        Args:
            task_type (str): 任务类型
            task_data (Dict): 任务数据

        Returns:
            Optional[str]: 目标模块名称，如果没有合适的模块则返回None
        """
        # 如果任务数据中指定了目标模块，优先使用
        if "target_module" in task_data:
            target = task_data["target_module"]
            # 验证模块是否存在
            if self.module_registry.is_module_registered(target):
                return target

        # 基于任务类型查找能力匹配的模块
        with self._module_capabilities_lock:
            for module, capabilities in self._module_capabilities.items():
                # 检查模块是否有处理该任务类型的能力
                # 这里的实现依赖于模块在注册时正确声明其能力
                if f"task.process.{task_type}" in capabilities or "task.process.*" in capabilities:
                    return module

        # 如果没有找到特定的模块，尝试使用通用处理模块
        return self.module_registry.find_module_by_capability("task.process.generic")

    def _complete_task(self, task_id: str, success: bool, result: Any = None, error: str = None) -> None:
        """完成任务，更新状态并通知结果

        Args:
            task_id (str): 任务ID
            success (bool): 任务是否成功
            result (Any, optional): 任务结果。默认为None
            error (str, optional): 错误信息。默认为None
        """
        # 更新任务信息
        with self._task_info_lock:
            if task_id in self._task_info:
                self._task_info[task_id].update({
                    "status": "completed" if success else "failed",
                    "end_time": time.time(),
                    "result": result,
                    "error": error
                })

        # 更新统计数据
        with self._stats_lock:
            self._stats["processing"] -= 1
            if success:
                self._stats["completed"] += 1
            else:
                self._stats["failed"] += 1

        # 构造任务结果消息
        result_message = Message(
            message_id=str(uuid.uuid4()),
            source="nerve_hq",
            destination="assembly_ctrl",  # 发送到总装窗口
            priority="medium",
            type="task.result",
            payload={
                "task_id": task_id,
                "success": success,
                "result": result,
                "error": error
            },
            metadata={}
        )

        # 发送任务结果消息
        self.message_bus.send(result_message)
        self.logger.info(f"任务已完成: {task_id}, 成功: {success}")

    def _get_resource_usage(self) -> Dict:
        """获取系统资源使用情况

        Returns:
            Dict: 资源使用情况
        """
        # 简单实现，实际项目可能需要更详细的资源监控
        stats = self.get_stats()
        resource_usage = {
            "cpu": 0.0,  # 占位，实际实现可能需要真实获取CPU使用率
            "memory": 0.0,  # 占位，实际实现可能需要真实获取内存使用情况
            "tasks": {
                "active": stats["processing"],
                "queued": sum(q.qsize() for q in self._task_queue.values()),
                "completed": stats["completed"],
                "failed": stats["failed"]
            }
        }
        return resource_usage

    # =================================================================================
    # 消息处理函数
    # =================================================================================

    def _handle_message(self, message: Message) -> None:
        """通用消息处理函数

        Args:
            message (Message): 消息对象
        """
        message_type = message.type

        # 根据消息类型分发处理
        if message_type == "task.submit":
            self._handle_task_submit(message)
        elif message_type == "task.result":
            self._handle_task_result(message)
        elif message_type == "module.registered":
            self._handle_module_registered(message)
        elif message_type == "module.capability.update":
            self._handle_capability_update(message)
        else:
            self.logger.debug(f"无法处理的消息类型: {message_type}")

    def _handle_task_submit(self, message: Message) -> None:
        """处理任务提交消息

        Args:
            message (Message): 消息对象
        """
        payload = message.payload
        task_data = payload.get("task_data", {})
        task_id = payload.get("task_id", str(uuid.uuid4()))
        priority = payload.get("priority", "medium")

        # 检查优先级有效性
        if priority not in self._task_queue:
            priority = "medium"

        # 记录任务信息
        task_info = {
            "id": task_id,
            "data": task_data,
            "priority": priority,
            "status": "pending",
            "submit_time": time.time(),
            "start_time": None,
            "end_time": None,
            "assigned_module": None,
            "result": None,
            "error": None,
            "source": message.source
        }

        # 更新统计数据
        with self._stats_lock:
            self._stats["submitted"] += 1

        # 添加到任务信息记录
        with self._task_info_lock:
            self._task_info[task_id] = task_info

        # 计算任务优先级值（使用提交时间作为排序依据）
        priority_value = time.time()

        # 添加到相应的任务队列
        self._task_queue[priority].put((priority_value, task_id))

        self.logger.info(f"接收到任务提交: {task_id}, 来源: {message.source}, 优先级: {priority}")

        # 如果消息要求响应，则发送响应
        if message.metadata.get("require_response", False):
            response = Message(
                message_id=str(uuid.uuid4()),
                source="nerve_hq",
                destination=message.source,
                priority="medium",
                type="task.submit.response",
                payload={
                    "original_message_id": message.message_id,
                    "task_id": task_id,
                    "status": "accepted"
                },
                metadata={}
            )
            self.message_bus.send(response)

    def _handle_task_result(self, message: Message) -> None:
        """处理任务结果消息

        Args:
            message (Message): 消息对象
        """
        payload = message.payload
        task_id = payload.get("task_id", "")
        success = payload.get("success", False)
        result = payload.get("result", None)
        error = payload.get("error", None)

        if not task_id:
            self.logger.warning(f"收到无效的任务结果消息，缺少任务ID")
            return

        self.logger.info(f"收到任务结果: {task_id}, 来源: {message.source}, 成功: {success}")

        # 检查任务是否存在
        with self._task_info_lock:
            if task_id not in self._task_info:
                self.logger.warning(f"收到未知任务的结果: {task_id}")
                return

            assigned_module = self._task_info[task_id].get("assigned_module", "")

            # 验证结果来源
            if assigned_module and message.source != assigned_module:
                self.logger.warning(f"任务结果来源不匹配: 预期={assigned_module}, 实际={message.source}")
                # 实际实现可能需要更严格的验证和处理

            # 更新任务信息
            self._task_info[task_id].update({
                "status": "completed" if success else "failed",
                "end_time": time.time(),
                "result": result,
                "error": error
            })

        # 更新统计数据
        with self._stats_lock:
            self._stats["processing"] -= 1
            if success:
                self._stats["completed"] += 1
            else:
                self._stats["failed"] += 1

        # 转发任务结果消息到总装窗口
        result_message = Message(
            message_id=str(uuid.uuid4()),
            source="nerve_hq",
            destination="assembly_ctrl",
            priority="medium",
            type="task.result",
            payload={
                "task_id": task_id,
                "success": success,
                "result": result,
                "error": error
            },
            metadata={}
        )
        self.message_bus.send(result_message)

    def _handle_module_registered(self, message: Message) -> None:
        """处理模块注册消息

        Args:
            message (Message): 消息对象
        """
        payload = message.payload
        module_name = payload.get("name", "")
        module_capabilities = payload.get("capabilities", [])

        if not module_name:
            return

        self.logger.info(f"模块已注册: {module_name}, 能力: {module_capabilities}")

        # 更新模块能力缓存
        with self._module_capabilities_lock:
            self._module_capabilities[module_name] = module_capabilities

    def _handle_capability_update(self, message: Message) -> None:
        """处理模块能力更新消息

        Args:
            message (Message): 消息对象
        """
        payload = message.payload
        module_name = payload.get("name", "")
        module_capabilities = payload.get("capabilities", [])

        if not module_name:
            return

        self.logger.info(f"模块能力已更新: {module_name}, 能力: {module_capabilities}")

        # 更新模块能力缓存
        with self._module_capabilities_lock:
            self._module_capabilities[module_name] = module_capabilities

==================== [第三阶段 - AI模型集成] ====================
"""
BrainGPT - GPT模型集成接口

本模块实现了与OpenAI GPT模型的集成，提供了文本生成、对话生成和代码生成的功能。
作为ASSEMBLY-CTRL系统的核心AI组件之一，BrainGPT负责处理需要GPT能力的各类任务。
"""

import os
import time
import uuid
import json
import logging
import threading
import requests
from typing import Dict, List, Optional, Any, Tuple
from concurrent.futures import ThreadPoolExecutor

# =================================================================================
# 1. 导入模块 - 系统依赖导入
# =================================================================================
# 这些导入将在实际集成时使用，这里仅作为接口定义
try:
    from core.message_bus import MessageBus, Message
    from core.error_handler import ErrorHandler
    from core.module_registry import ModuleRegistry
    from utils.config import Config
except ImportError:
    # 在独立开发阶段使用模拟类
    class MessageBus:
        def send_message(self, message):
            print(f"[模拟消息总线] 发送消息: {message}")

        def register_handler(self, module_name, message_type, handler):
            print(f"[模拟消息总线] 注册处理器: {module_name} -> {message_type}")

    class Message:
        def __init__(self, message_id=None, source=None, destination=None,
                     message_type=None, priority=None, payload=None, metadata=None):
            self.message_id = message_id or str(uuid.uuid4())
            self.source = source
            self.destination = destination
            self.type = message_type
            self.priority = priority or "normal"
            self.payload = payload or {}
            self.metadata = metadata or {}

        def to_dict(self):
            return {
                "message_id": self.message_id,
                "source": self.source,
                "destination": self.destination,
                "type": self.type,
                "priority": self.priority,
                "payload": self.payload,
                "metadata": self.metadata
            }

    class ErrorHandler:
        def report_error(self, module_name, error_type, details, severity="warning"):
            print(f"[模拟错误处理] [{severity}] {module_name} - {error_type}: {details}")

    class Config:
        def __init__(self):
            self.config = {
                "openai": {
                    "api_key": os.environ.get("OPENAI_API_KEY", ""),
                    "default_model": "gpt-4",
                    "max_tokens": 1000,
                    "temperature": 0.7,
                    "request_timeout": 60,
                    "max_retries": 3,
                    "retry_delay": 2,
                    "max_concurrent_requests": 5
                },
                "simulation_mode": {
                    "enabled": True,
                    "response_delay_min": 0.5,
                    "response_delay_max": 2.0
                }
            }

        def get(self, key, default=None):
            """获取配置项，支持点号分隔的多级路径"""
            if "." in key:
                parts = key.split(".")
                value = self.config
                for part in parts:
                    if isinstance(value, dict) and part in value:
                        value = value[part]
                    else:
                        return default
                return value
            return self.config.get(key, default)

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("BrainGPT")

# =================================================================================
# 2. BrainGPT类 - GPT模型集成实现
# =================================================================================
class BrainGPT:
    """主模型集成窗口：负责GPT模型的集成，处理与OpenAI API的交互"""

    def __init__(self, config: Config = None, message_bus: MessageBus = None,
                 error_handler: ErrorHandler = None):
        """
        初始化BrainGPT模块

        Args:
            config: 配置管理器，用于获取API密钥和其他配置
            message_bus: 消息总线，用于模块间通信
            error_handler: 错误处理器，用于错误上报
        """
        # 注入依赖
        self.config = config or Config()
        self.message_bus = message_bus or MessageBus()
        self.error_handler = error_handler or ErrorHandler()

        # 模块标识
        self.module_name = "brain_gpt"
        self.module_display_name = "BrainGPT"
        self.module_version = "1.0.0"

        # API配置
        self.api_key = self.config.get("openai.api_key", "")
        self.default_model = self.config.get("openai.default_model", "gpt-4")
        self.default_max_tokens = self.config.get("openai.max_tokens", 1000)
        self.default_temperature = self.config.get("openai.temperature", 0.7)
        self.request_timeout = self.config.get("openai.request_timeout", 60)
        self.max_retries = self.config.get("openai.max_retries", 3)
        self.retry_delay = self.config.get("openai.retry_delay", 2)

        # 并发控制
        self.max_concurrent_requests = self.config.get("openai.max_concurrent_requests", 5)
        self.executor = ThreadPoolExecutor(max_workers=self.max_concurrent_requests)
        self._api_call_semaphore = threading.Semaphore(self.max_concurrent_requests)

        # 模拟模式设置
        self.simulation_mode = self.config.get("simulation_mode.enabled", True) or not self.api_key
        self.simulation_delay_min = self.config.get("simulation_mode.response_delay_min", 0.5)
        self.simulation_delay_max = self.config.get("simulation_mode.response_delay_max", 2.0)

        # 统计和状态
        self.status = "initializing"
        self.api_call_count = 0
        self.error_count = 0
        self.token_usage = {"prompt_tokens": 0, "completion_tokens": 0, "total_tokens": 0}
        self.simulation_call_count = 0
        self.start_time = time.time()

        # 注册消息处理器
        self._register_module()
        logger.info(f"{self.module_display_name} 初始化完成，模拟模式：{self.simulation_mode}")

    def _register_module(self) -> None:
        """注册模块到消息总线"""
        self.message_bus.register_handler(
            self.module_name, "task.process", self._handle_task_process
        )
        self.message_bus.register_handler(
            self.module_name, "generate.text", lambda msg: self._handle_generate_text(msg)
        )
        self.message_bus.register_handler(
            self.module_name, "generate.chat", lambda msg: self._handle_generate_chat(msg)
        )
        self.message_bus.register_handler(
            self.module_name, "generate.code", lambda msg: self._handle_generate_code(msg)
        )
        self.message_bus.register_handler(
            self.module_name, "module.control", self._handle_module_control
        )
        logger.info(f"{self.module_display_name} 注册消息处理器完成")

    def start(self) -> bool:
        """启动模块"""
        try:
            self.status = "running"
            # 发送模块启动通知
            self._send_status_update("started")
            logger.info(f"{self.module_display_name} 已启动")
            return True
        except Exception as e:
            self.status = "error"
            self.error_handler.report_error(
                self.module_name, "startup_error", str(e), "critical"
            )
            logger.error(f"{self.module_display_name} 启动失败: {str(e)}")
            return False

    def stop(self) -> bool:
        """停止模块"""
        try:
            self.status = "stopping"
            # 关闭线程池
            self.executor.shutdown(wait=False)
            self.status = "stopped"
            # 发送模块停止通知
            self._send_status_update("stopped")
            logger.info(f"{self.module_display_name} 已停止")
            return True
        except Exception as e:
            self.status = "error"
            self.error_handler.report_error(
                self.module_name, "shutdown_error", str(e), "critical"
            )
            logger.error(f"{self.module_display_name} 停止失败: {str(e)}")
            return False

    def generate_text(self, prompt: str, max_tokens: int = None,
                     temperature: float = None, model: str = None) -> Dict:
        """
        生成文本内容

        Args:
            prompt: 输入提示文本
            max_tokens: 最大生成标记数，None则使用默认值
            temperature: 温度参数，控制随机性，None则使用默认值
            model: 使用的模型名称，None则使用默认模型

        Returns:
            包含生成结果的字典
        """
        # 参数处理
        max_tokens = max_tokens or self.default_max_tokens
        temperature = temperature if temperature is not None else self.default_temperature
        model = model or self.default_model

        # 统计记录
        task_id = str(uuid.uuid4())
        start_time = time.time()

        if self.simulation_mode:
            result = self._simulate_text_generation(prompt, max_tokens, temperature, model)
            self.simulation_call_count += 1
        else:
            try:
                result = self._call_openai_api(prompt, max_tokens, temperature, model)
                self.api_call_count += 1
                # 更新令牌使用统计
                if "usage" in result:
                    self.token_usage["prompt_tokens"] += result["usage"].get("prompt_tokens", 0)
                    self.token_usage["completion_tokens"] += result["usage"].get("completion_tokens", 0)
                    self.token_usage["total_tokens"] += result["usage"].get("total_tokens", 0)
            except Exception as e:
                error_msg = str(e)
                logger.error(f"API调用失败: {error_msg}")
                self.error_count += 1
                # 降级到模拟模式
                result = self._simulate_text_generation(prompt, max_tokens, temperature, model)
                result["error"] = error_msg
                self.simulation_call_count += 1

        # 添加任务元数据
        result["task_id"] = task_id
        result["processing_time"] = time.time() - start_time
        result["simulation_mode"] = self.simulation_mode

        return result

    def generate_chat_response(self, messages: List[Dict], max_tokens: int = None,
                              temperature: float = None, model: str = None) -> Dict:
        """
        生成对话响应

        Args:
            messages: 对话历史，格式为[{"role": "user", "content": "..."}, ...]
            max_tokens: 最大生成标记数，None则使用默认值
            temperature: 温度参数，控制随机性，None则使用默认值
            model: 使用的模型名称，None则使用默认模型

        Returns:
            包含生成结果的字典
        """
        # 参数处理
        max_tokens = max_tokens or self.default_max_tokens
        temperature = temperature if temperature is not None else self.default_temperature
        model = model or self.default_model

        # 统计记录
        task_id = str(uuid.uuid4())
        start_time = time.time()

        if self.simulation_mode:
            result = self._simulate_chat_generation(messages, max_tokens, temperature, model)
            self.simulation_call_count += 1
        else:
            try:
                result = self._call_openai_chat_api(messages, max_tokens, temperature, model)
                self.api_call_count += 1
                # 更新令牌使用统计
                if "usage" in result:
                    self.token_usage["prompt_tokens"] += result["usage"].get("prompt_tokens", 0)
                    self.token_usage["completion_tokens"] += result["usage"].get("completion_tokens", 0)
                    self.token_usage["total_tokens"] += result["usage"].get("total_tokens", 0)
            except Exception as e:
                error_msg = str(e)
                logger.error(f"聊天API调用失败: {error_msg}")
                self.error_count += 1
                # 降级到模拟模式
                result = self._simulate_chat_generation(messages, max_tokens, temperature, model)
                result["error"] = error_msg
                self.simulation_call_count += 1

        # 添加任务元数据
        result["task_id"] = task_id
        result["processing_time"] = time.time() - start_time
        result["simulation_mode"] = self.simulation_mode

        return result

    def generate_code(self, prompt: str, language: str = None,
                     max_tokens: int = None, temperature: float = None) -> Dict:
        """
        生成代码

        Args:
            prompt: 代码生成提示
            language: 目标编程语言
            max_tokens: 最大生成标记数，None则使用默认值
            temperature: 温度参数，控制随机性，None则使用默认值

        Returns:
            包含生成代码的字典
        """
        # 构建优化后的提示，引导模型生成代码
        model = self.default_model

        if language:
            enhanced_prompt = f"请用{language}编程语言生成以下代码：\n\n{prompt}\n\n请只返回代码，不需要解释。"
        else:
            enhanced_prompt = f"请生成以下代码：\n\n{prompt}\n\n请只返回代码，不需要解释。"

        # 构建聊天消息
        messages = [
            {"role": "system", "content": "你是一个专业的代码生成助手，专注于生成高质量、可执行的代码。"},
            {"role": "user", "content": enhanced_prompt}
        ]

        # 使用聊天API生成代码
        result = self.generate_chat_response(messages, max_tokens, temperature, model)

        # 标记为代码生成任务
        result["task_type"] = "code_generation"
        if language:
            result["language"] = language

        return result

    def process_task(self, task_id: str, task_data: Dict) -> Dict:
        """
        处理通用任务

        Args:
            task_id: 任务ID
            task_data: 任务数据，包含任务类型和参数

        Returns:
            包含任务处理结果的字典
        """
        # 提取任务类型和参数
        task_type = task_data.get("task_type", "")
        task_params = task_data.get("params", {})

        start_time = time.time()
        result = {"task_id": task_id, "status": "failed", "error": "未知任务类型"}

        try:
            # 根据任务类型分发处理
            if task_type == "generate_text":
                prompt = task_params.get("prompt", "")
                max_tokens = task_params.get("max_tokens")
                temperature = task_params.get("temperature")
                model = task_params.get("model")

                generation_result = self.generate_text(
                    prompt, max_tokens, temperature, model
                )
                result = {
                    "task_id": task_id,
                    "status": "success",
                    "result": generation_result,
                    "task_type": "generate_text"
                }

            elif task_type == "generate_chat":
                messages = task_params.get("messages", [])
                max_tokens = task_params.get("max_tokens")
                temperature = task_params.get("temperature")
                model = task_params.get("model")

                generation_result = self.generate_chat_response(
                    messages, max_tokens, temperature, model
                )
                result = {
                    "task_id": task_id,
                    "status": "success",
                    "result": generation_result,
                    "task_type": "generate_chat"
                }

            elif task_type == "generate_code":
                prompt = task_params.get("prompt", "")
                language = task_params.get("language")
                max_tokens = task_params.get("max_tokens")
                temperature = task_params.get("temperature")

                generation_result = self.generate_code(
                    prompt, language, max_tokens, temperature
                )
                result = {
                    "task_id": task_id,
                    "status": "success",
                    "result": generation_result,
                    "task_type": "generate_code"
                }

            else:
                self.error_handler.report_error(
                    self.module_name, "unknown_task_type", f"未知任务类型: {task_type}", "warning"
                )

        except Exception as e:
            error_msg = str(e)
            self.error_handler.report_error(
                self.module_name, "task_processing_error", error_msg, "error"
            )
            result = {
                "task_id": task_id,
                "status": "failed",
                "error": error_msg,
                "task_type": task_type
            }

        # 添加处理时间
        result["processing_time"] = time.time() - start_time
        return result

    # =================================================================================
    # 3. API调用 - 与外部服务交互
    # =================================================================================
    def _call_openai_api(self, prompt: str, max_tokens: int,
                       temperature: float, model: str) -> Dict:
        """
        调用OpenAI文本生成API

        Args:
            prompt: 输入提示文本
            max_tokens: 最大生成标记数
            temperature: 温度参数
            model: 模型名称

        Returns:
            API响应结果
        """
        with self._api_call_semaphore:
            url = "https://api.openai.com/v1/completions"
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            data = {
                "model": model,
                "prompt": prompt,
                "max_tokens": max_tokens,
                "temperature": temperature
            }

            # 重试机制
            for attempt in range(self.max_retries):
                try:
                    response = requests.post(
                        url, headers=headers, json=data,
                        timeout=self.request_timeout
                    )
                    response.raise_for_status()
                    return response.json()
                except requests.exceptions.RequestException as e:
                    logger.warning(f"API调用失败 (尝试 {attempt+1}/{self.max_retries}): {str(e)}")
                    if attempt < self.max_retries - 1:
                        time.sleep(self.retry_delay * (2 ** attempt))  # 指数退避
                    else:
                        raise e

    def _call_openai_chat_api(self, messages: List[Dict], max_tokens: int,
                            temperature: float, model: str) -> Dict:
        """
        调用OpenAI聊天生成API

        Args:
            messages: 对话历史
            max_tokens: 最大生成标记数
            temperature: 温度参数
            model: 模型名称

        Returns:
            API响应结果
        """
        with self._api_call_semaphore:
            url = "https://api.openai.com/v1/chat/completions"
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            data = {
                "model": model,
                "messages": messages,
                "max_tokens": max_tokens,
                "temperature": temperature
            }

            # 重试机制
            for attempt in range(self.max_retries):
                try:
                    response = requests.post(
                        url, headers=headers, json=data,
                        timeout=self.request_timeout
                    )
                    response.raise_for_status()
                    return response.json()
                except requests.exceptions.RequestException as e:
                    logger.warning(f"聊天API调用失败 (尝试 {attempt+1}/{self.max_retries}): {str(e)}")
                    if attempt < self.max_retries - 1:
                        time.sleep(self.retry_delay * (2 ** attempt))  # 指数退避
                    else:
                        raise e

    # =================================================================================
    # 4. 模拟模式 - 在API不可用时提供模拟响应
    # =================================================================================
    def _simulate_text_generation(self, prompt: str, max_tokens: int,
                                temperature: float, model: str) -> Dict:
        """
        模拟文本生成，用于API不可用或测试场景

        Args:
            prompt: 输入提示文本
            max_tokens: 最大生成标记数
            temperature: 温度参数
            model: 模型名称

        Returns:
            模拟的生成结果
        """
        # 简单的模拟延迟
        delay = min(max(len(prompt) / 1000, self.simulation_delay_min), self.simulation_delay_max)
        time.sleep(delay)

        # 构建一个简单的响应
        prompt_tokens = len(prompt.split())
        completion_tokens = min(20, max_tokens)  # 模拟生成约20个token

        # 根据prompt生成一个模拟回应
        if len(prompt) < 50:
            response = f"这是对提示"{prompt[:20]}..."的模拟回应。实际使用时，这里将是GPT模型生成的内容。"
        else:
            response = f"这是GPT模型的模拟回应。您提供了一个长度为{len(prompt)}字符的提示。" \
                      f"在实际使用中，模型会根据这个提示生成相关的、流畅的文本内容。"

        return {
            "id": f"simulated-{uuid.uuid4()}",
            "object": "text_completion",
            "created": int(time.time()),
            "model": f"{model}-simulation",
            "choices": [
                {
                    "text": response,
                    "index": 0,
                    "finish_reason": "length"
                }
            ],
            "usage": {
                "prompt_tokens": prompt_tokens,
                "completion_tokens": completion_tokens,
                "total_tokens": prompt_tokens + completion_tokens
            },
            "simulation": True
        }

    def _simulate_chat_generation(self, messages: List[Dict], max_tokens: int,
                                temperature: float, model: str) -> Dict:
        """
        模拟聊天生成，用于API不可用或测试场景

        Args:
            messages: 对话历史
            max_tokens: 最大生成标记数
            temperature: 温度参数
            model: 模型名称

        Returns:
            模拟的聊天生成结果
        """
        # 简单的模拟延迟
        message_length = sum(len(m.get("content", "")) for m in messages)
        delay = min(max(message_length / 2000, self.simulation_delay_min), self.simulation_delay_max)
        time.sleep(delay)

        # 提取最后一条用户消息
        last_user_message = ""
        for message in reversed(messages):
            if message.get("role") == "user":
                last_user_message = message.get("content", "")
                break

        # 计算令牌数
        prompt_tokens = sum(len(m.get("content", "").split()) for m in messages)
        completion_tokens = min(30, max_tokens)  # 模拟生成约30个token

        # 构建一个简单的响应
        if last_user_message and len(last_user_message) < 50:
            response = f"这是对消息"{last_user_message[:20]}..."的模拟对话回应。实际使用时，这里将是GPT模型生成的对话内容。"
        else:
            response = "这是GPT模型的模拟对话回应。在实际使用中，模型会生成与对话历史相关的、上下文连贯的回应。"

        # 检测是否是代码生成请求
        if any("代码" in m.get("content", "") or "code" in m.get("content", "").lower() for m in messages):
            response = "```python\n# 这是模拟生成的代码示例\ndef hello_world():\n    print('Hello, World!')\n\n# 实际使用时，这里将是GPT模型根据您的要求生成的代码\nhello_world()\n```"

        return {
            "id": f"chatcmpl-{uuid.uuid4()}",
            "object": "chat.completion",
            "created": int(time.time()),
            "model": f"{model}-simulation",
            "choices": [
                {
                    "index": 0,
                    "message": {
                        "role": "assistant",
                        "content": response
                    },
                    "finish_reason": "length"
                }
            ],
            "usage": {
                "prompt_tokens": prompt_tokens,
                "completion_tokens": completion_tokens,
                "total_tokens": prompt_tokens + completion_tokens
            },
            "simulation": True
        }

    # =================================================================================
    # 5. 资源管理 - 监控和报告资源使用情况
    # =================================================================================
    def _get_resource_usage(self) -> Dict:
        """获取资源使用情况"""
        running_time = time.time() - self.start_time
        return {
            "module_name": self.module_name,
            "status": self.status,
            "uptime_seconds": running_time,
            "api_call_count": self.api_call_count,
            "simulation_call_count": self.simulation_call_count,
            "error_count": self.error_count,
            "token_usage": self.token_usage,
            "simulation_mode": self.simulation_mode,
            "timestamp": time.time()
        }

    # =================================================================================
    # 6. 消息处理 - 处理来自消息总线的消息
    # =================================================================================
    def _handle_message(self, message: Message) -> None:
        """通用消息处理器"""
        try:
            message_type = message.type
            logger.debug(f"收到消息: {message_type} 从 {message.source}")

            # 根据消息类型分发处理
            if message_type == "task.process":
                self._handle_task_process(message)
            elif message_type == "generate.text":
                self._handle_generate_text(message)
            elif message_type == "generate.chat":
                self._handle_generate_chat(message)
            elif message_type == "generate.code":
                self._handle_generate_code(message)
            elif message_type == "module.control":
                self._handle_module_control(message)
            else:
                logger.warning(f"未处理的消息类型: {message_type}")

        except Exception as e:
            self.error_handler.report_error(
                self.module_name, "message_handling_error",
                f"处理消息时出错: {str(e)}", "error"
            )
            # 发送错误响应
            self._send_error_response(message, str(e))

    def _handle_task_process(self, message: Message) -> None:
        """处理任务处理请求"""
        task_id = message.payload.get("task_id", str(uuid.uuid4()))
        task_data = message.payload.get("task_data", {})

        # 异步处理任务
        future = self.executor.submit(self.process_task, task_id, task_data)

        # 添加回调以发送结果
        def _send_result(future):
            try:
                result = future.result()
                # 发送任务结果消息
                response_message = Message(
                    source=self.module_name,
                    destination=message.source,
                    message_type="task.result",
                    payload=result,
                    metadata={
                        "original_message_id": message.message_id,
                        "task_id": task_id
                    }
                )
                self.message_bus.send_message(response_message)
            except Exception as e:
                self.error_handler.report_error(
                    self.module_name, "task_result_error",
                    f"发送任务结果时出错: {str(e)}", "error"
                )

        future.add_done_callback(_send_result)

    def _handle_generate_text(self, message: Message) -> None:
        """处理文本生成请求"""
        prompt = message.payload.get("prompt", "")
        max_tokens = message.payload.get("max_tokens")
        temperature = message.payload.get("temperature")
        model = message.payload.get("model")

        # 执行生成
        try:
            result = self.generate_text(prompt, max_tokens, temperature, model)

            # 发送响应
            response = Message(
                source=self.module_name,
                destination=message.source,
                message_type="generate.text.response",
                payload=result,
                metadata={
                    "original_message_id": message.message_id
                }
            )
            self.message_bus.send_message(response)

        except Exception as e:
            self.error_handler.report_error(
                self.module_name, "text_generation_error",
                f"文本生成出错: {str(e)}", "error"
            )
            self._send_error_response(message, str(e))

    def _handle_generate_chat(self, message: Message) -> None:
        """处理聊天生成请求"""
        messages = message.payload.get("messages", [])
        max_tokens = message.payload.get("max_tokens")
        temperature = message.payload.get("temperature")
        model = message.payload.get("model")

        # 执行生成
        try:
            result = self.generate_chat_response(messages, max_tokens, temperature, model)

            # 发送响应
            response = Message(
                source=self.module_name,
                destination=message.source,
                message_type="generate.chat.response",
                payload=result,
                metadata={
                    "original_message_id": message.message_id
                }
            )
            self.message_bus.send_message(response)

        except Exception as e:
            self.error_handler.report_error(
                self.module_name, "chat_generation_error",
                f"聊天生成出错: {str(e)}", "error"
            )
            self._send_error_response(message, str(e))

    def _handle_generate_code(self, message: Message) -> None:
        """处理代码生成请求"""
        prompt = message.payload.get("prompt", "")
        language = message.payload.get("language")
        max_tokens = message.payload.get("max_tokens")
        temperature = message.payload.get("temperature")

        # 执行生成
        try:
            result = self.generate_code(prompt, language, max_tokens, temperature)

            # 发送响应
            response = Message(
                source=self.module_name,
                destination=message.source,
                message_type="generate.code.response",
                payload=result,
                metadata={
                    "original_message_id": message.message_id
                }
            )
            self.message_bus.send_message(response)

        except Exception as e:
            self.error_handler.report_error(
                self.module_name, "code_generation_error",
                f"代码生成出错: {str(e)}", "error"
            )
            self._send_error_response(message, str(e))

    def _handle_module_control(self, message: Message) -> None:
        """处理模块控制命令"""
        command = message.payload.get("command", "")

        if command == "start":
            success = self.start()
            status = "started" if success else "start_failed"
        elif command == "stop":
            success = self.stop()
            status = "stopped" if success else "stop_failed"
        elif command == "status":
            status = "status_report"
            self._send_status_update(status)
            return
        else:
            self.error_handler.report_error(
                self.module_name, "unknown_command",
                f"未知控制命令: {command}", "warning"
            )
            status = "unknown_command"

        # 发送状态更新
        self._send_status_update(status)

    # =================================================================================
    # 7. 辅助方法 - 内部工具函数
    # =================================================================================
    def _send_status_update(self, status: str) -> None:
        """发送模块状态更新"""
        message = Message(
            source=self.module_name,
            destination="*",
            message_type="module.status_update",
            payload={
                "module_name": self.module_name,
                "status": status,
                "resource_usage": self._get_resource_usage()
            }
        )
        self.message_bus.send_message(message)

    def _send_error_response(self, original_message: Message, error: str) -> None:
        """发送错误响应"""
        response_type = f"{original_message.type}.error"
        response = Message(
            source=self.module_name,
            destination=original_message.source,
            message_type=response_type,
            payload={
                "error": error,
                "original_message_id": original_message.message_id
            }
        )
        self.message_bus.send_message(response)

# =================================================================================
# 8. 模块测试 - 独立运行时的测试代码
# =================================================================================
if __name__ == "__main__":
    print("BrainGPT模块测试")

    # 初始化模块
    brain_gpt = BrainGPT()
    brain_gpt.start()

    # 测试文本生成
    print("\n测试文本生成:")
    result = brain_gpt.generate_text("解释人工智能的未来发展趋势")
    print(f"文本生成结果: {result['choices'][0]['text']}")

    # 测试聊天生成
    print("\n测试聊天生成:")
    chat_messages = [
        {"role": "system", "content": "你是一个有帮助的助手。"},
        {"role": "user", "content": "解释量子计算的基本原理"}
    ]
    result = brain_gpt.generate_chat_response(chat_messages)
    print(f"聊天生成结果: {result['choices'][0]['message']['content']}")

    # 测试代码生成
    print("\n测试代码生成:")
    result = brain_gpt.generate_code("编写一个计算斐波那契数列的函数", "python")
    print(f"代码生成结果: {result['choices'][0]['message']['content']}")

    # 获取资源使用情况
    print("\n资源使用情况:")
    usage = brain_gpt._get_resource_usage()
    print(json.dumps(usage, indent=2))

    # 停止模块
    brain_gpt.stop()
    print("\n模块已停止")

"""
TechClaude - Claude模型集成接口

本模块实现了与Anthropic Claude模型的集成，提供了文本生成、对话生成和复杂推理的功能。
作为ASSEMBLY-CTRL系统的核心AI组件之一，TechClaude负责处理需要Claude能力的各类任务。
"""

import os
import time
import uuid
import json
import logging
import threading
import requests
from typing import Dict, List, Optional, Any, Tuple
from concurrent.futures import ThreadPoolExecutor

# =================================================================================
# 1. 导入模块 - 系统依赖导入
# =================================================================================
# 这些导入将在实际集成时使用，这里仅作为接口定义
try:
    from core.message_bus import MessageBus, Message
    from core.error_handler import ErrorHandler
    from core.module_registry import ModuleRegistry
    from utils.config import Config
except ImportError:
    # 在独立开发阶段使用模拟类
    class MessageBus:
        def send_message(self, message):
            print(f"[模拟消息总线] 发送消息: {message}")

        def register_handler(self, module_name, message_type, handler):
            print(f"[模拟消息总线] 注册处理器: {module_name} -> {message_type}")

    class Message:
        def __init__(self, message_id=None, source=None, destination=None,
                     message_type=None, priority=None, payload=None, metadata=None):
            self.message_id = message_id or str(uuid.uuid4())
            self.source = source
            self.destination = destination
            self.type = message_type
            self.priority = priority or "normal"
            self.payload = payload or {}
            self.metadata = metadata or {}

        def to_dict(self):
            return {
                "message_id": self.message_id,
                "source": self.source,
                "destination": self.destination,
                "type": self.type,
                "priority": self.priority,
                "payload": self.payload,
                "metadata": self.metadata
            }

    class ErrorHandler:
        def report_error(self, module_name, error_type, details, severity="warning"):
            print(f"[模拟错误处理] [{severity}] {module_name} - {error_type}: {details}")

    class Config:
        def __init__(self):
            self.config = {
                "anthropic": {
                    "api_key": os.environ.get("ANTHROPIC_API_KEY", ""),
                    "default_model": "claude-3-opus-20240229",
                    "max_tokens": 2000,
                    "temperature": 0.7,
                    "request_timeout": 120,
                    "max_retries": 3,
                    "retry_delay": 2,
                    "max_concurrent_requests": 3
                },
                "simulation_mode": {
                    "enabled": True,
                    "response_delay_min": 0.5,
                    "response_delay_max": 3.0
                }
            }

        def get(self, key, default=None):
            """获取配置项，支持点号分隔的多级路径"""
            if "." in key:
                parts = key.split(".")
                value = self.config
                for part in parts:
                    if isinstance(value, dict) and part in value:
                        value = value[part]
                    else:
                        return default
                return value
            return self.config.get(key, default)

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("TechClaude")

# =================================================================================
# 2. TechClaude类 - Claude模型集成实现
# =================================================================================
class TechClaude:
    """副模型集成窗口：负责Claude模型的集成，处理与Anthropic API的交互"""

    def __init__(self, config: Config = None, message_bus: MessageBus = None,
                 error_handler: ErrorHandler = None):
        """
        初始化TechClaude模块

        Args:
            config: 配置管理器，用于获取API密钥和其他配置
            message_bus: 消息总线，用于模块间通信
            error_handler: 错误处理器，用于错误上报
        """
        # 注入依赖
        self.config = config or Config()
        self.message_bus = message_bus or MessageBus()
        self.error_handler = error_handler or ErrorHandler()

        # 模块标识
        self.module_name = "tech_claude"
        self.module_display_name = "TechClaude"
        self.module_version = "1.0.0"

        # API配置
        self.api_key = self.config.get("anthropic.api_key", "")
        self.default_model = self.config.get("anthropic.default_model", "claude-3-opus-20240229")
        self.default_max_tokens = self.config.get("anthropic.max_tokens", 2000)
        self.default_temperature = self.config.get("anthropic.temperature", 0.7)
        self.request_timeout = self.config.get("anthropic.request_timeout", 120)
        self.max_retries = self.config.get("anthropic.max_retries", 3)
        self.retry_delay = self.config.get("anthropic.retry_delay", 2)

        # 并发控制
        self.max_concurrent_requests = self.config.get("anthropic.max_concurrent_requests", 3)
        self.executor = ThreadPoolExecutor(max_workers=self.max_concurrent_requests)
        self._api_call_semaphore = threading.Semaphore(self.max_concurrent_requests)

        # 模拟模式设置
        self.simulation_mode = self.config.get("simulation_mode.enabled", True) or not self.api_key
        self.simulation_delay_min = self.config.get("simulation_mode.response_delay_min", 0.5)
        self.simulation_delay_max = self.config.get("simulation_mode.response_delay_max", 3.0)

        # 统计和状态
        self.status = "initializing"
        self.api_call_count = 0
        self.error_count = 0
        self.token_usage = {"prompt_tokens": 0, "completion_tokens": 0, "total_tokens": 0}
        self.simulation_call_count = 0
        self.start_time = time.time()

        # 注册消息处理器
        self._register_module()
        logger.info(f"{self.module_display_name} 初始化完成，模拟模式：{self.simulation_mode}")

    def _register_module(self) -> None:
        """注册模块到消息总线"""
        self.message_bus.register_handler(
            self.module_name, "task.process", self._handle_task_process
        )
        self.message_bus.register_handler(
            self.module_name, "generate.text", lambda msg: self._handle_generate_text(msg)
        )
        self.message_bus.register_handler(
            self.module_name, "generate.chat", lambda msg: self._handle_generate_chat(msg)
        )
        self.message_bus.register_handler(
            self.module_name, "perform.complex_reasoning",
            lambda msg: self._handle_complex_reasoning(msg)
        )
        self.message_bus.register_handler(
            self.module_name, "module.control", self._handle_module_control
        )
        logger.info(f"{self.module_display_name} 注册消息处理器完成")

    def start(self) -> bool:
        """启动模块"""
        try:
            self.status = "running"
            # 发送模块启动通知
            self._send_status_update("started")
            logger.info(f"{self.module_display_name} 已启动")
            return True
        except Exception as e:
            self.status = "error"
            self.error_handler.report_error(
                self.module_name, "startup_error", str(e), "critical"
            )
            logger.error(f"{self.module_display_name} 启动失败: {str(e)}")
            return False

    def stop(self) -> bool:
        """停止模块"""
        try:
            self.status = "stopping"
            # 关闭线程池
            self.executor.shutdown(wait=False)
            self.status = "stopped"
            # 发送模块停止通知
            self._send_status_update("stopped")
            logger.info(f"{self.module_display_name} 已停止")
            return True
        except Exception as e:
            self.status = "error"
            self.error_handler.report_error(
                self.module_name, "shutdown_error", str(e), "critical"
            )
            logger.error(f"{self.module_display_name} 停止失败: {str(e)}")
            return False

    def generate_text(self, prompt: str, max_tokens: int = None,
                     temperature: float = None, model: str = None) -> Dict:
        """
        生成文本内容

        Args:
            prompt: 输入提示文本
            max_tokens: 最大生成标记数，None则使用默认值
            temperature: 温度参数，控制随机性，None则使用默认值
            model: 使用的模型名称，None则使用默认模型

        Returns:
            包含生成结果的字典
        """
        # 参数处理
        max_tokens = max_tokens or self.default_max_tokens
        temperature = temperature if temperature is not None else self.default_temperature
        model = model or self.default_model

        # 构建消息格式
        messages = [
            {"role": "user", "content": prompt}
        ]

        # 统计记录
        task_id = str(uuid.uuid4())
        start_time = time.time()

        if self.simulation_mode:
            result = self._simulate_text_generation(prompt, max_tokens, temperature, model)
            self.simulation_call_count += 1
        else:
            try:
                result = self._call_anthropic_chat_api(messages, max_tokens, temperature, model)
                self.api_call_count += 1
                # 更新令牌使用统计
                if "usage" in result:
                    self.token_usage["prompt_tokens"] += result["usage"].get("input_tokens", 0)
                    self.token_usage["completion_tokens"] += result["usage"].get("output_tokens", 0)
                    self.token_usage["total_tokens"] += (result["usage"].get("input_tokens", 0) +
                                                       result["usage"].get("output_tokens", 0))
            except Exception as e:
                error_msg = str(e)
                logger.error(f"API调用失败: {error_msg}")
                self.error_count += 1
                # 降级到模拟模式
                result = self._simulate_text_generation(prompt, max_tokens, temperature, model)
                result["error"] = error_msg
                self.simulation_call_count += 1

        # 添加任务元数据
        result["task_id"] = task_id
        result["processing_time"] = time.time() - start_time
        result["simulation_mode"] = self.simulation_mode

        return result

    def generate_chat_response(self, messages: List[Dict], max_tokens: int = None,
                              temperature: float = None, model: str = None) -> Dict:
        """
        生成对话响应

        Args:
            messages: 对话历史，格式为[{"role": "user", "content": "..."}, ...]
            max_tokens: 最大生成标记数，None则使用默认值
            temperature: 温度参数，控制随机性，None则使用默认值
            model: 使用的模型名称，None则使用默认模型

        Returns:
            包含生成结果的字典
        """
        # 参数处理
        max_tokens = max_tokens or self.default_max_tokens
        temperature = temperature if temperature is not None else self.default_temperature
        model = model or self.default_model

        # 统计记录
        task_id = str(uuid.uuid4())
        start_time = time.time()

        if self.simulation_mode:
            result = self._simulate_chat_generation(messages, max_tokens, temperature, model)
            self.simulation_call_count += 1
        else:
            try:
                result = self._call_anthropic_chat_api(messages, max_tokens, temperature, model)
                self.api_call_count += 1
                # 更新令牌使用统计
                if "usage" in result:
                    self.token_usage["prompt_tokens"] += result["usage"].get("input_tokens", 0)
                    self.token_usage["completion_tokens"] += result["usage"].get("output_tokens", 0)
                    self.token_usage["total_tokens"] += (result["usage"].get("input_tokens", 0) +
                                                       result["usage"].get("output_tokens", 0))
            except Exception as e:
                error_msg = str(e)
                logger.error(f"聊天API调用失败: {error_msg}")
                self.error_count += 1
                # 降级到模拟模式
                result = self._simulate_chat_generation(messages, max_tokens, temperature, model)
                result["error"] = error_msg
                self.simulation_call_count += 1

        # 添加任务元数据
        result["task_id"] = task_id
        result["processing_time"] = time.time() - start_time
        result["simulation_mode"] = self.simulation_mode

        return result

    def perform_complex_reasoning(self, query: str, context: str = None,
                                max_tokens: int = None, temperature: float = None) -> Dict:
        """
        执行复杂推理任务

        Args:
            query: 查询问题
            context: 上下文信息，可选
            max_tokens: 最大生成标记数，None则使用默认值
            temperature: 温度参数，控制随机性，None则使用默认值

        Returns:
            包含推理结果的字典
        """
        # 参数处理
        max_tokens = max_tokens or self.default_max_tokens
        temperature = temperature if temperature is not None else self.default_temperature
        model = self.default_model

        # 构建系统提示
        system_message = "你是一个专业的复杂推理助手，能够分析问题，提供深入的思考和合理的结论。"

        # 构建用户消息
        user_content = query
        if context:
            user_content = f"上下文信息:\n\n{context}\n\n问题:\n\n{query}"

        # 构建消息列表
        messages = [
            {"role": "system", "content": system_message},
            {"role": "user", "content": user_content}
        ]

        # 使用聊天API执行推理
        result = self.generate_chat_response(messages, max_tokens, temperature, model)

        # 标记为推理任务
        result["task_type"] = "complex_reasoning"

        return result

    def process_task(self, task_id: str, task_data: Dict) -> Dict:
        """
        处理通用任务

        Args:
            task_id: 任务ID
            task_data: 任务数据，包含任务类型和参数

        Returns:
            包含任务处理结果的字典
        """
        # 提取任务类型和参数
        task_type = task_data.get("task_type", "")
        task_params = task_data.get("params", {})

        start_time = time.time()
        result = {"task_id": task_id, "status": "failed", "error": "未知任务类型"}

        try:
            # 根据任务类型分发处理
            if task_type == "generate_text":
                prompt = task_params.get("prompt", "")
                max_tokens = task_params.get("max_tokens")
                temperature = task_params.get("temperature")
                model = task_params.get("model")

                generation_result = self.generate_text(
                    prompt, max_tokens, temperature, model
                )
                result = {
                    "task_id": task_id,
                    "status": "success",
                    "result": generation_result,
                    "task_type": "generate_text"
                }

            elif task_type == "generate_chat":
                messages = task_params.get("messages", [])
                max_tokens = task_params.get("max_tokens")
                temperature = task_params.get("temperature")
                model = task_params.get("model")

                generation_result = self.generate_chat_response(
                    messages, max_tokens, temperature, model
                )
                result = {
                    "task_id": task_id,
                    "status": "success",
                    "result": generation_result,
                    "task_type": "generate_chat"
                }

            elif task_type == "perform_complex_reasoning":
                query = task_params.get("query", "")
                context = task_params.get("context")
                max_tokens = task_params.get("max_tokens")
                temperature = task_params.get("temperature")

                reasoning_result = self.perform_complex_reasoning(
                    query, context, max_tokens, temperature
                )
                result = {
                    "task_id": task_id,
                    "status": "success",
                    "result": reasoning_result,
                    "task_type": "perform_complex_reasoning"
                }

            else:
                self.error_handler.report_error(
                    self.module_name, "unknown_task_type", f"未知任务类型: {task_type}", "warning"
                )

        except Exception as e:
            error_msg = str(e)
            self.error_handler.report_error(
                self.module_name, "task_processing_error", error_msg, "error"
            )
            result = {
                "task_id": task_id,
                "status": "failed",
                "error": error_msg,
                "task_type": task_type
            }

        # 添加处理时间
        result["processing_time"] = time.time() - start_time
        return result

# =================================================================================
# 3. API调用 - 与外部服务交互
# =================================================================================
    def _call_anthropic_api(self, prompt: str, max_tokens: int,
                          temperature: float, model: str) -> Dict:
        """
        调用Anthropic的旧版完成API（已废弃，仅作参考）

        Args:
            prompt: 输入提示文本
            max_tokens: 最大生成标记数
            temperature: 温度参数
            model: 模型名称

        Returns:
            API响应结果
        """
        # 注意：Anthropic已经不再提供单独的文本完成API，全部迁移到了消息API
        # 这个方法仅作为接口保留，实际功能已迁移到_call_anthropic_chat_api
        logger.warning("使用旧版完成API，已自动转换为消息API")

        # 转换为消息格式调用聊天API
        messages = [
            {"role": "user", "content": prompt}
        ]
        return self._call_anthropic_chat_api(messages, max_tokens, temperature, model)

    def _call_anthropic_chat_api(self, messages: List[Dict], max_tokens: int,
                               temperature: float, model: str) -> Dict:
        """
        调用Anthropic Messages API

        Args:
            messages: 对话历史
            max_tokens: 最大生成标记数
            temperature: 温度参数
            model: 模型名称

        Returns:
            API响应结果
        """
        with self._api_call_semaphore:
            url = "https://api.anthropic.com/v1/messages"
            headers = {
                "x-api-key": self.api_key,
                "anthropic-version": "2023-06-01",
                "content-type": "application/json"
            }

            # 确保消息格式正确
            processed_messages = []
            for msg in messages:
                if msg.get("role") in ["user", "assistant", "system"]:
                    processed_messages.append(msg)

            data = {
                "model": model,
                "messages": processed_messages,
                "max_tokens": max_tokens,
                "temperature": temperature
            }

            # 添加系统消息如果没有
            has_system = any(msg.get("role") == "system" for msg in processed_messages)
            if not has_system:
                data["system"] = "请提供有帮助、准确和符合道德的回答。"

            # 重试机制
            for attempt in range(self.max_retries):
                try:
                    response = requests.post(
                        url, headers=headers, json=data,
                        timeout=self.request_timeout
                    )
                    response.raise_for_status()

                    # 转换响应格式为统一格式
                    api_response = response.json()

                    # 构建统一响应格式
                    unified_response = {
                        "id": api_response.get("id", ""),
                        "object": "message",
                        "created": int(time.time()),
                        "model": api_response.get("model", model),
                        "choices": [
                            {
                                "index": 0,
                                "message": {
                                    "role": "assistant",
                                    "content": api_response.get("content", [{"type": "text", "text": ""}])[0].get("text", "")
                                },
                                "finish_reason": api_response.get("stop_reason", "stop")
                            }
                        ],
                        "usage": {
                            "input_tokens": api_response.get("usage", {}).get("input_tokens", 0),
                            "output_tokens": api_response.get("usage", {}).get("output_tokens", 0)
                        }
                    }

                    return unified_response

                except requests.exceptions.RequestException as e:
                    logger.warning(f"API调用失败 (尝试 {attempt+1}/{self.max_retries}): {str(e)}")
                    if attempt < self.max_retries - 1:
                        time.sleep(self.retry_delay * (2 ** attempt))  # 指数退避
                    else:
                        raise e

    # =================================================================================
    # 4. 模拟模式 - 在API不可用时提供模拟响应
    # =================================================================================
    def _simulate_text_generation(self, prompt: str, max_tokens: int,
                                temperature: float, model: str) -> Dict:
        """
        模拟文本生成，用于API不可用或测试场景

        Args:
            prompt: 输入提示文本
            max_tokens: 最大生成标记数
            temperature: 温度参数
            model: 模型名称

        Returns:
            模拟的生成结果
        """
        # 简单的模拟延迟
        delay = min(max(len(prompt) / 1000, self.simulation_delay_min), self.simulation_delay_max)
        time.sleep(delay)

        # 构建一个简单的响应
        prompt_tokens = len(prompt.split())
        completion_tokens = min(25, max_tokens)  # 模拟生成约25个token

        # 根据prompt生成一个模拟回应
        if len(prompt) < 50:
            response = f"这是对提示"{prompt[:20]}..."的模拟回应。实际使用时，这里将是Claude模型生成的内容。"
        else:
            response = f"这是Claude模型的模拟回应。您提供了一个长度为{len(prompt)}字符的提示。" \
                      f"在实际使用中，模型会根据这个提示生成相关的、流畅的文本内容，并可能包含复杂的推理分析。"

        return {
            "id": f"simulated-{uuid.uuid4()}",
            "object": "message",
            "created": int(time.time()),
            "model": f"{model}-simulation",
            "choices": [
                {
                    "index": 0,
                    "message": {
                        "role": "assistant",
                        "content": response
                    },
                    "finish_reason": "length"
                }
            ],
            "usage": {
                "input_tokens": prompt_tokens,
                "output_tokens": completion_tokens
            },
            "simulation": True
        }

    def _simulate_chat_generation(self, messages: List[Dict], max_tokens: int,
                                temperature: float, model: str) -> Dict:
        """
        模拟聊天生成，用于API不可用或测试场景

        Args:
            messages: 对话历史
            max_tokens: 最大生成标记数
            temperature: 温度参数
            model: 模型名称

        Returns:
            模拟的聊天生成结果
        """
        # 简单的模拟延迟
        message_length = sum(len(m.get("content", "")) for m in messages)
        delay = min(max(message_length / 2000, self.simulation_delay_min), self.simulation_delay_max)
        time.sleep(delay)

        # 提取最后一条用户消息
        last_user_message = ""
        for message in reversed(messages):
            if message.get("role") == "user":
                last_user_message = message.get("content", "")
                break

        # 检查是否有系统消息
        system_message = ""
        for message in messages:
            if message.get("role") == "system":
                system_message = message.get("content", "")
                break

        # 计算令牌数
        prompt_tokens = sum(len(m.get("content", "").split()) for m in messages)
        completion_tokens = min(35, max_tokens)  # 模拟生成约35个token

        # 构建一个简单的响应
        if system_message and "推理" in system_message:
            response = "作为复杂推理助手，我需要分析这个问题的多个方面。首先，我们应该考虑...\n\n" \
                       "这是一个模拟的复杂推理回应。在实际使用时，Claude模型会提供详细的分析和合理的结论。"
        elif last_user_message and len(last_user_message) < 50:
            response = f"这是对问题"{last_user_message[:20]}..."的模拟对话回应。实际使用时，这里将是Claude模型生成的对话内容。"
        else:
            response = "这是Claude模型的模拟对话回应。在实际使用中，模型会生成与对话历史相关的、上下文连贯的回应，并能处理复杂的推理任务。"

        return {
            "id": f"simulated-{uuid.uuid4()}",
            "object": "message",
            "created": int(time.time()),
            "model": f"{model}-simulation",
            "choices": [
                {
                    "index": 0,
                    "message": {
                        "role": "assistant",
                        "content": response
                    },
                    "finish_reason": "stop"
                }
            ],
            "usage": {
                "input_tokens": prompt_tokens,
                "output_tokens": completion_tokens
            },
            "simulation": True
        }

    # =================================================================================
    # 5. 资源管理 - 监控和报告资源使用情况
    # =================================================================================
    def _get_resource_usage(self) -> Dict:
        """获取资源使用情况"""
        running_time = time.time() - self.start_time
        return {
            "module_name": self.module_name,
            "status": self.status,
            "uptime_seconds": running_time,
            "api_call_count": self.api_call_count,
            "simulation_call_count": self.simulation_call_count,
            "error_count": self.error_count,
            "token_usage": self.token_usage,
            "simulation_mode": self.simulation_mode,
            "timestamp": time.time()
        }

    # =================================================================================
    # 6. 消息处理 - 处理来自消息总线的消息
    # =================================================================================
    def _handle_message(self, message: Message) -> None:
        """通用消息处理器"""
        try:
            message_type = message.type
            logger.debug(f"收到消息: {message_type} 从 {message.source}")

            # 根据消息类型分发处理
            if message_type == "task.process":
                self._handle_task_process(message)
            elif message_type == "generate.text":
                self._handle_generate_text(message)
            elif message_type == "generate.chat":
                self._handle_generate_chat(message)
            elif message_type == "perform.complex_reasoning":
                self._handle_complex_reasoning(message)
            elif message_type == "module.control":
                self._handle_module_control(message)
            else:
                logger.warning(f"未处理的消息类型: {message_type}")

        except Exception as e:
            self.error_handler.report_error(
                self.module_name, "message_handling_error",
                f"处理消息时出错: {str(e)}", "error"
            )
            # 发送错误响应
            self._send_error_response(message, str(e))

    def _handle_task_process(self, message: Message) -> None:
        """处理任务处理请求"""
        task_id = message.payload.get("task_id", str(uuid.uuid4()))
        task_data = message.payload.get("task_data", {})

        # 异步处理任务
        future = self.executor.submit(self.process_task, task_id, task_data)

        # 添加回调以发送结果
        def _send_result(future):
            try:
                result = future.result()
                # 发送任务结果消息
                response_message = Message(
                    source=self.module_name,
                    destination=message.source,
                    message_type="task.result",
                    payload=result,
                    metadata={
                        "original_message_id": message.message_id,
                        "task_id": task_id
                    }
                )
                self.message_bus.send_message(response_message)
            except Exception as e:
                self.error_handler.report_error(
                    self.module_name, "task_result_error",
                    f"发送任务结果时出错: {str(e)}", "error"
                )

        future.add_done_callback(_send_result)

    def _handle_generate_text(self, message: Message) -> None:
        """处理文本生成请求"""
        prompt = message.payload.get("prompt", "")
        max_tokens = message.payload.get("max_tokens")
        temperature = message.payload.get("temperature")
        model = message.payload.get("model")

        # 执行生成
        try:
            result = self.generate_text(prompt, max_tokens, temperature, model)

            # 发送响应
            response = Message(
                source=self.module_name,
                destination=message.source,
                message_type="generate.text.response",
                payload=result,
                metadata={
                    "original_message_id": message.message_id
                }
            )
            self.message_bus.send_message(response)

        except Exception as e:
            self.error_handler.report_error(
                self.module_name, "text_generation_error",
                f"文本生成出错: {str(e)}", "error"
            )
            self._send_error_response(message, str(e))

    def _handle_generate_chat(self, message: Message) -> None:
        """处理聊天生成请求"""
        messages = message.payload.get("messages", [])
        max_tokens = message.payload.get("max_tokens")
        temperature = message.payload.get("temperature")
        model = message.payload.get("model")

        # 执行生成
        try:
            result = self.generate_chat_response(messages, max_tokens, temperature, model)

            # 发送响应
            response = Message(
                source=self.module_name,
                destination=message.source,
                message_type="generate.chat.response",
                payload=result,
                metadata={
                    "original_message_id": message.message_id
                }
            )
            self.message_bus.send_message(response)

        except Exception as e:
            self.error_handler.report_error(
                self.module_name, "chat_generation_error",
                f"聊天生成出错: {str(e)}", "error"
            )
            self._send_error_response(message, str(e))

    def _handle_complex_reasoning(self, message: Message) -> None:
        """处理复杂推理请求"""
        query = message.payload.get("query", "")
        context = message.payload.get("context")
        max_tokens = message.payload.get("max_tokens")
        temperature = message.payload.get("temperature")

        # 执行推理
        try:
            result = self.perform_complex_reasoning(query, context, max_tokens, temperature)

            # 发送响应
            response = Message(
                source=self.module_name,
                destination=message.source,
                message_type="perform.complex_reasoning.response",
                payload=result,
                metadata={
                    "original_message_id": message.message_id
                }
            )
            self.message_bus.send_message(response)

        except Exception as e:
            self.error_handler.report_error(
                self.module_name, "complex_reasoning_error",
                f"复杂推理出错: {str(e)}", "error"
            )
            self._send_error_response(message, str(e))

    def _handle_module_control(self, message: Message) -> None:
        """处理模块控制命令"""
        command = message.payload.get("command", "")

        if command == "start":
            success = self.start()
            status = "started" if success else "start_failed"
        elif command == "stop":
            success = self.stop()
            status = "stopped" if success else "stop_failed"
        elif command == "status":
            status = "status_report"
            self._send_status_update(status)
            return
        else:
            self.error_handler.report_error(
                self.module_name, "unknown_command",
                f"未知控制命令: {command}", "warning"
            )
            status = "unknown_command"

        # 发送状态更新
        self._send_status_update(status)

    # =================================================================================
    # 7. 辅助方法 - 内部工具函数
    # =================================================================================
    def _send_status_update(self, status: str) -> None:
        """发送模块状态更新"""
        message = Message(
            source=self.module_name,
            destination="*",
            message_type="module.status_update",
            payload={
                "module_name": self.module_name,
                "status": status,
                "resource_usage": self._get_resource_usage()
            }
        )
        self.message_bus.send_message(message)

    def _send_error_response(self, original_message: Message, error: str) -> None:
        """发送错误响应"""
        response_type = f"{original_message.type}.error"
        response = Message(
            source=self.module_name,
            destination=original_message.source,
            message_type=response_type,
            payload={
                "error": error,
                "original_message_id": original_message.message_id
            }
        )
        self.message_bus.send_message(response)

# =================================================================================
# 8. 模块测试 - 独立运行时的测试代码
# =================================================================================
if __name__ == "__main__":
    print("TechClaude模块测试")

    # 初始化模块
    tech_claude = TechClaude()
    tech_claude.start()

    # 测试文本生成
    print("\n测试文本生成:")
    result = tech_claude.generate_text("解释量子计算的优势和局限性")
    print(f"文本生成结果: {result['choices'][0]['message']['content']}")

    # 测试聊天生成
    print("\n测试聊天生成:")
    chat_messages = [
        {"role": "system", "content": "你是一个专业的技术顾问。"},
        {"role": "user", "content": "比较一下机器学习和深度学习的差异"}
    ]
    result = tech_claude.generate_chat_response(chat_messages)
    print(f"聊天生成结果: {result['choices'][0]['message']['content']}")

    # 测试复杂推理
    print("\n测试复杂推理:")
    query = "如果自动驾驶汽车面临一个无法避免的碰撞情况，它应该如何做出伦理决策？"
    context = "假设有多种可能的碰撞选择，每种选择涉及不同的风险和伤害对象。"
    result = tech_claude.perform_complex_reasoning(query, context)
    print(f"复杂推理结果: {result['choices'][0]['message']['content']}")

    # 获取资源使用情况
    print("\n资源使用情况:")
    usage = tech_claude._get_resource_usage()
    print(json.dumps(usage, indent=2))

    # 停止模块
    tech_claude.stop()
    print("\n模块已停止")

==================== [第四阶段 - 用户界面] ====================

"""
ASSEMBLY-CTRL System - UI Dashboard Components
提供系统的UI组件实现，包括各种面板、控件和可视化元素
"""

import tkinter as tk
from tkinter import ttk, scrolledtext
from tkinter import messagebox
import threading
import time
from typing import Dict, List, Callable, Optional, Any, Tuple
import datetime

# =================================================================================
# 1. 基础UI组件(BASE_COMP) - 提供基础UI构建块
# =================================================================================

class StatusIndicator(tk.Canvas):
    """状态指示器组件，显示系统或模块的运行状态"""

    COLORS = {
        "running": "#4CAF50",  # 绿色
        "stopped": "#F44336",  # 红色
        "warning": "#FFC107",  # 黄色
        "error": "#FF5722",    # 橙色
        "inactive": "#9E9E9E"  # 灰色
    }

    def __init__(self, parent, status="inactive", size=15, **kwargs):
        """
        初始化状态指示器

        Args:
            parent: 父容器
            status: 初始状态，可选值为running, stopped, warning, error, inactive
            size: 指示器大小
            **kwargs: 传递给Canvas的其他参数
        """
        super().__init__(parent, width=size, height=size,
                         highlightthickness=0, **kwargs)
        self.size = size
        self._status = status
        self._draw_indicator()

    def set_status(self, status):
        """
        设置状态指示器的状态

        Args:
            status: 新状态，可选值为running, stopped, warning, error, inactive
        """
        if status in self.COLORS:
            self._status = status
            self._draw_indicator()

    def _draw_indicator(self):
        """绘制状态指示器"""
        self.delete("all")
        color = self.COLORS.get(self._status, self.COLORS["inactive"])
        padding = 2
        self.create_oval(padding, padding,
                         self.size - padding, self.size - padding,
                         fill=color, outline="")

class LogPanel(tk.Frame):
    """日志面板组件，用于显示系统日志和消息"""

    def __init__(self, parent, **kwargs):
        """
        初始化日志面板

        Args:
            parent: 父容器
            **kwargs: 传递给Frame的其他参数
        """
        super().__init__(parent, **kwargs)

        # 创建滚动文本区域
        self.log_text = scrolledtext.ScrolledText(self, wrap=tk.WORD,
                                                 height=10, width=50)
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.log_text.config(state=tk.DISABLED)

        # 日志级别颜色
        self.log_colors = {
            "INFO": "black",
            "WARNING": "#FF8C00",  # 暗橙色
            "ERROR": "#FF0000",    # 红色
            "DEBUG": "#808080",    # 灰色
            "SUCCESS": "#008000"   # 绿色
        }

        # 添加标签配置
        for level, color in self.log_colors.items():
            self.log_text.tag_configure(level, foreground=color)

    def log(self, message, level="INFO"):
        """
        添加日志消息

        Args:
            message: 日志消息
            level: 日志级别，用于确定消息颜色
        """
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}\n"

        level_tag = level if level in self.log_colors else "INFO"

        self.log_text.config(state=tk.NORMAL)
        self.log_text.insert(tk.END, log_entry, level_tag)
        self.log_text.see(tk.END)  # 自动滚动到底部
        self.log_text.config(state=tk.DISABLED)

class ControlButton(tk.Button):
    """增强型按钮，具有加载状态和禁用功能"""

    def __init__(self, parent, text, command=None, **kwargs):
        """
        初始化控制按钮

        Args:
            parent: 父容器
            text: 按钮文本
            command: 点击回调函数
            **kwargs: 传递给Button的其他参数
        """
        self.normal_text = text
        self.original_command = command
        super().__init__(parent, text=text, command=self._on_click, **kwargs)

        self._loading = False
        self.loading_text = "处理中..."

    def _on_click(self):
        """按钮点击处理"""
        if self._loading or self.original_command is None:
            return

        # 执行命令
        if callable(self.original_command):
            self.original_command()

    def set_loading(self, is_loading):
        """
        设置按钮加载状态

        Args:
            is_loading: 是否处于加载中状态
        """
        self._loading = is_loading

        if is_loading:
            self.config(text=self.loading_text, state=tk.DISABLED)
        else:
            self.config(text=self.normal_text, state=tk.NORMAL)

class ResourceBar(tk.Frame):
    """资源使用条，显示CPU、内存等资源使用情况"""

    def __init__(self, parent, label_text="资源", **kwargs):
        """
        初始化资源使用条

        Args:
            parent: 父容器
            label_text: 标签文本
            **kwargs: 传递给Frame的其他参数
        """
        super().__init__(parent, **kwargs)

        # 创建标签
        self.label = ttk.Label(self, text=label_text)
        self.label.pack(side=tk.LEFT, padx=(0, 5))

        # 创建进度条
        self.progressbar = ttk.Progressbar(self, orient=tk.HORIZONTAL,
                                          length=150, mode='determinate')
        self.progressbar.pack(side=tk.LEFT, expand=True, fill=tk.X)

        # 创建百分比标签
        self.percent_label = ttk.Label(self, text="0%", width=5)
        self.percent_label.pack(side=tk.LEFT, padx=(5, 0))

    def set_value(self, value):
        """
        设置资源使用值

        Args:
            value: 0-100之间的数值
        """
        normalized_value = max(0, min(100, value))
        self.progressbar['value'] = normalized_value
        self.percent_label.config(text=f"{normalized_value:.0f}%")

class TaskTable(tk.Frame):
    """任务表格组件，显示系统中的任务列表"""

    def __init__(self, parent, columns=None, **kwargs):
        """
        初始化任务表格

        Args:
            parent: 父容器
            columns: 列配置 [(id, text, width), ...]
            **kwargs: 传递给Frame的其他参数
        """
        super().__init__(parent, **kwargs)

        if columns is None:
            columns = [
                ("id", "任务ID", 80),
                ("type", "类型", 100),
                ("status", "状态", 80),
                ("submit_time", "提交时间", 150),
                ("complete_time", "完成时间", 150)
            ]

        # 创建树状表格
        self.tree = ttk.Treeview(self, columns=[col[0] for col in columns],
                                 show='headings')

        # 设置列
        for col_id, col_text, col_width in columns:
            self.tree.heading(col_id, text=col_text)
            self.tree.column(col_id, width=col_width)

        # 添加滚动条
        scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)

        # 布局
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # 双击事件绑定
        self.on_double_click = None
        self.tree.bind("<Double-1>", self._on_double_click)

    def add_task(self, task_id, values):
        """
        添加任务到表格

        Args:
            task_id: 任务唯一标识符
            values: 任务属性值列表
        """
        # 检查任务是否已存在
        existing_items = self.tree.get_children()
        for item in existing_items:
            if self.tree.item(item, 'values')[0] == task_id:
                # 更新已存在的任务
                self.tree.item(item, values=values)
                return

        # 添加新任务
        self.tree.insert('', 'end', values=values)

    def update_task(self, task_id, values):
        """
        更新任务信息

        Args:
            task_id: 任务唯一标识符
            values: 任务属性值列表
        """
        items = self.tree.get_children()
        for item in items:
            if self.tree.item(item, 'values')[0] == task_id:
                self.tree.item(item, values=values)
                return

    def clear(self):
        """清空任务表格"""
        for item in self.tree.get_children():
            self.tree.delete(item)

    def _on_double_click(self, event):
        """双击事件处理"""
        item = self.tree.identify('item', event.x, event.y)
        if item and callable(self.on_double_click):
            values = self.tree.item(item, 'values')
            self.on_double_click(values)

class ModuleStatusPanel(tk.LabelFrame):
    """模块状态面板，显示系统中各模块的状态"""

    def __init__(self, parent, title="模块状态", **kwargs):
        """
        初始化模块状态面板

        Args:
            parent: 父容器
            title: 面板标题
            **kwargs: 传递给LabelFrame的其他参数
        """
        super().__init__(parent, text=title, **kwargs)

        # 创建滚动容器
        self.canvas = tk.Canvas(self, borderwidth=0)
        self.frame = tk.Frame(self.canvas)
        self.scrollbar = ttk.Scrollbar(self, orient="vertical",
                                      command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.canvas.create_window((0, 0), window=self.frame, anchor="nw")

        self.frame.bind("<Configure>", self._on_frame_configure)

        # 模块控制回调
        self.on_start_module = None
        self.on_stop_module = None

        # 模块状态记录
        self.module_frames = {}

    def _on_frame_configure(self, event):
        """配置滚动区域"""
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def update_module(self, module_id, status, description=None):
        """
        更新模块状态

        Args:
            module_id: 模块ID
            status: 模块状态，可选值为running, stopped, warning, error, inactive
            description: 模块描述，如果为None则保持不变
        """
        if module_id in self.module_frames:
            # 更新现有模块
            frame, indicator, desc_label = self.module_frames[module_id]
            indicator.set_status(status)
            if description is not None:
                desc_label.config(text=description)
        else:
            # 创建新模块条目
            frame = tk.Frame(self.frame)
            frame.pack(fill=tk.X, padx=5, pady=3)

            # 模块状态指示器
            indicator = StatusIndicator(frame, status=status)
            indicator.pack(side=tk.LEFT, padx=(0, 5))

            # 模块名称
            name_label = ttk.Label(frame, text=module_id, width=15)
            name_label.pack(side=tk.LEFT, padx=(0, 5))

            # 模块描述
            desc_text = description or ""
            desc_label = ttk.Label(frame, text=desc_text)
            desc_label.pack(side=tk.LEFT, padx=(0, 5), fill=tk.X, expand=True)

            # 控制按钮
            control_frame = tk.Frame(frame)
            control_frame.pack(side=tk.RIGHT)

            # 启动按钮
            start_btn = ControlButton(control_frame, text="启动", width=6,
                              command=lambda: self._start_module(module_id))
            start_btn.pack(side=tk.LEFT, padx=(0, 2))

            # 停止按钮
            stop_btn = ControlButton(control_frame, text="停止", width=6,
                             command=lambda: self._stop_module(module_id))
            stop_btn.pack(side=tk.LEFT)

            # 保存引用
            self.module_frames[module_id] = (frame, indicator, desc_label)

    def clear(self):
        """清空所有模块状态"""
        for frame, _, _ in self.module_frames.values():
            frame.destroy()
        self.module_frames.clear()

    def _start_module(self, module_id):
        """
        启动模块

        Args:
            module_id: 模块ID
        """
        if callable(self.on_start_module):
            self.on_start_module(module_id)

    def _stop_module(self, module_id):
        """
        停止模块

        Args:
            module_id: 模块ID
        """
        if callable(self.on_stop_module):
            self.on_stop_module(module_id)

# =================================================================================
# 2. 面板组件(PANEL_COMP) - 提供复合UI面板
# =================================================================================

class ControlPanel(tk.LabelFrame):
    """控制面板，提供系统控制功能"""

    def __init__(self, parent, **kwargs):
        """
        初始化控制面板

        Args:
            parent: 父容器
            **kwargs: 传递给LabelFrame的其他参数
        """
        super().__init__(parent, text="系统控制", **kwargs)

        # 状态指示区域
        status_frame = tk.Frame(self)
        status_frame.pack(fill=tk.X, padx=10, pady=10)

        # 状态指示器
        self.status_label = ttk.Label(status_frame, text="系统状态:")
        self.status_label.pack(side=tk.LEFT, padx=(0, 5))

        self.status_indicator = StatusIndicator(status_frame, size=20)
        self.status_indicator.pack(side=tk.LEFT)

        self.status_text = ttk.Label(status_frame, text="未启动")
        self.status_text.pack(side=tk.LEFT, padx=(5, 0))

        # 按钮区域
        button_frame = tk.Frame(self)
        button_frame.pack(fill=tk.X, padx=10, pady=(0, 10))

        # 启动系统按钮
        self.start_button = ControlButton(button_frame, text="启动系统",
                                 width=12, command=self._on_start)
        self.start_button.pack(side=tk.LEFT, padx=(0, 5))

        # 停止系统按钮
        self.stop_button = ControlButton(button_frame, text="停止系统",
                                width=12, command=self._on_stop)
        self.stop_button.pack(side=tk.LEFT, padx=(0, 5))

        # 重启系统按钮
        self.restart_button = ControlButton(button_frame, text="重启系统",
                                  width=12, command=self._on_restart)
        self.restart_button.pack(side=tk.LEFT)

        # 资源监控区域
        resource_frame = tk.LabelFrame(self, text="资源监控")
        resource_frame.pack(fill=tk.X, padx=10, pady=(0, 10))

        # CPU使用率
        self.cpu_bar = ResourceBar(resource_frame, label_text="CPU:")
        self.cpu_bar.pack(fill=tk.X, padx=5, pady=3)

        # 内存使用率
        self.memory_bar = ResourceBar(resource_frame, label_text="内存:")
        self.memory_bar.pack(fill=tk.X, padx=5, pady=3)

        # 网络使用率
        self.network_bar = ResourceBar(resource_frame, label_text="网络:")
        self.network_bar.pack(fill=tk.X, padx=5, pady=3)

        # 回调函数
        self.on_start = None
        self.on_stop = None
        self.on_restart = None

    def set_system_status(self, status, status_text=None):
        """
        设置系统状态

        Args:
            status: 系统状态，可选值为running, stopped, warning, error, inactive
            status_text: 状态文本描述
        """
        self.status_indicator.set_status(status)

        if status_text is not None:
            self.status_text.config(text=status_text)
        else:
            status_mapping = {
                "running": "运行中",
                "stopped": "已停止",
                "warning": "警告",
                "error": "错误",
                "inactive": "未启动"
            }
            self.status_text.config(text=status_mapping.get(status, "未知"))

    def update_resources(self, cpu_percent, memory_percent, network_percent):
        """
        更新资源使用情况

        Args:
            cpu_percent: CPU使用百分比(0-100)
            memory_percent: 内存使用百分比(0-100)
            network_percent: 网络使用百分比(0-100)
        """
        self.cpu_bar.set_value(cpu_percent)
        self.memory_bar.set_value(memory_percent)
        self.network_bar.set_value(network_percent)

    def _on_start(self):
        """启动系统回调"""
        if callable(self.on_start):
            self.on_start()

    def _on_stop(self):
        """停止系统回调"""
        if callable(self.on_stop):
            self.on_stop()

    def _on_restart(self):
        """重启系统回调"""
        if callable(self.on_restart):
            self.on_restart()

class ConsolePanel(tk.LabelFrame):
    """控制台面板，提供命令输入和执行功能"""

    def __init__(self, parent, **kwargs):
        """
        初始化控制台面板

        Args:
            parent: 父容器
            **kwargs: 传递给LabelFrame的其他参数
        """
        super().__init__(parent, text="命令控制台", **kwargs)

        # 日志面板
        self.log_panel = LogPanel(self)
        self.log_panel.pack(fill=tk.BOTH, expand=True, padx=5, pady=(5, 0))

        # 命令输入区域
        command_frame = tk.Frame(self)
        command_frame.pack(fill=tk.X, padx=5, pady=5)

        self.command_label = ttk.Label(command_frame, text="命令:")
        self.command_label.pack(side=tk.LEFT, padx=(0, 5))

        self.command_entry = ttk.Entry(command_frame)
        self.command_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        self.command_entry.bind("<Return>", self._on_command_enter)

        self.send_button = ControlButton(command_frame, text="发送",
                                width=10, command=self._on_send_command)
        self.send_button.pack(side=tk.LEFT)

        # 命令历史
        self.command_history = []
        self.history_position = -1

        # 绑定上下键用于浏览历史命令
        self.command_entry.bind("<Up>", self._on_up_key)
        self.command_entry.bind("<Down>", self._on_down_key)

        # 命令执行回调
        self.on_command = None

    def log(self, message, level="INFO"):
        """
        添加日志消息

        Args:
            message: 日志消息
            level: 日志级别，可选值为INFO, WARNING, ERROR, DEBUG, SUCCESS
        """
        self.log_panel.log(message, level)

    def _on_command_enter(self, event):
        """处理回车键输入"""
        self._execute_command()

    def _on_send_command(self):
        """处理发送按钮点击"""
        self._execute_command()

    def _execute_command(self):
        """执行命令逻辑"""
        command = self.command_entry.get().strip()
        if not command:
            return

        # 记录命令到历史
        self.log(f"$ {command}", "INFO")
        self.command_history.append(command)
        self.history_position = len(self.command_history)

        # 清空输入框
        self.command_entry.delete(0, tk.END)

        # 调用命令回调
        if callable(self.on_command):
            try:
                result = self.on_command(command)
                if result:
                    self.log(str(result), "SUCCESS")
            except Exception as e:
                self.log(f"错误: {str(e)}", "ERROR")

    def _on_up_key(self, event):
        """向上浏览历史命令"""
        if not self.command_history:
            return "break"

        if self.history_position > 0:
            self.history_position -= 1
            self.command_entry.delete(0, tk.END)
            self.command_entry.insert(0, self.command_history[self.history_position])
        return "break"

    def _on_down_key(self, event):
        """向下浏览历史命令"""
        if not self.command_history:
            return "break"

        if self.history_position < len(self.command_history) - 1:
            self.history_position += 1
            self.command_entry.delete(0, tk.END)
            self.command_entry.insert(0, self.command_history[self.history_position])
        else:
            self.history_position = len(self.command_history)
            self.command_entry.delete(0, tk.END)
        return "break"

class TaskPanel(tk.LabelFrame):
    """任务面板，用于显示和管理系统任务"""

    def __init__(self, parent, **kwargs):
        """
        初始化任务面板

        Args:
            parent: 父容器
            **kwargs: 传递给LabelFrame的其他参数
        """
        super().__init__(parent, text="任务管理", **kwargs)

        # 顶部按钮区域
        button_frame = tk.Frame(self)
        button_frame.pack(fill=tk.X, padx=5, pady=(5, 0))

        self.refresh_button = ControlButton(button_frame, text="刷新",
                                  width=10, command=self._on_refresh)
        self.refresh_button.pack(side=tk.LEFT, padx=(0, 5))

        self.view_button = ControlButton(button_frame, text="查看详情",
                               width=10, command=self._on_view_details)
        self.view_button.pack(side=tk.LEFT, padx=(0, 5))

        self.cancel_button = ControlButton(button_frame, text="取消任务",
                                width=10, command=self._on_cancel_task)
        self.cancel_button.pack(side=tk.LEFT)

        # 任务表格
        columns = [
            ("id", "任务ID", 80),
            ("type", "类型", 100),
            ("status", "状态", 80),
            ("submit_time", "提交时间", 150),
            ("complete_time", "完成时间", 150)
        ]
        self.task_table = TaskTable(self, columns=columns)
        self.task_table.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # 设置双击处理
        self.task_table.on_double_click = self._on_double_click

        # 回调函数
        self.on_refresh = None
        self.on_view_details = None
        self.on_cancel_task = None

    def add_task(self, task_id, task_type, status, submit_time, complete_time=""):
        """
        添加或更新任务

        Args:
            task_id: 任务ID
            task_type: 任务类型
            status: 任务状态
            submit_time: 提交时间
            complete_time: 完成时间，默认为空
        """
        values = (task_id, task_type, status, submit_time, complete_time)
        self.task_table.add_task(task_id, values)

    def update_task(self, task_id, task_type, status, submit_time, complete_time=""):
        """
        更新任务信息

        Args:
            task_id: 任务ID
            task_type: 任务类型
            status: 任务状态
            submit_time: 提交时间
            complete_time: 完成时间，默认为空
        """
        values = (task_id, task_type, status, submit_time, complete_time)
        self.task_table.update_task(task_id, values)

    def clear(self):
        """清空任务列表"""
        self.task_table.clear()

    def _on_refresh(self):
        """刷新任务列表"""
        if callable(self.on_refresh):
            self.on_refresh()

    def _on_view_details(self):
        """查看任务详情"""
        selected_items = self.task_table.tree.selection()
        if not selected_items:
            messagebox.showinfo("提示", "请选择一个任务")
            return

        item = selected_items[0]
        values = self.task_table.tree.item(item, 'values')

        if callable(self.on_view_details):
            self.on_view_details(values)

    def _on_cancel_task(self):
        """取消任务"""
        selected_items = self.task_table.tree.selection()
        if not selected_items:
            messagebox.showinfo("提示", "请选择一个任务")
            return

        item = selected_items[0]
        values = self.task_table.tree.item(item, 'values')
        task_id = values[0]

        if callable(self.on_cancel_task):
            self.on_cancel_task(task_id)

    def _on_double_click(self, values):
        """双击任务行"""
        if values and callable(self.on_view_details):
            self.on_view_details(values)

class StatusPanel(tk.LabelFrame):
    """状态面板，显示系统和模块状态"""

    def __init__(self, parent, **kwargs):
        """
        初始化状态面板

        Args:
            parent: 父容器
            **kwargs: 传递给LabelFrame的其他参数
        """
        super().__init__(parent, text="系统状态", **kwargs)

        # 创建多标签页
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # 系统总览页
        self.overview_frame = tk.Frame(self.notebook)
        self.notebook.add(self.overview_frame, text="系统总览")

        # 基本系统信息
        system_info_frame = tk.LabelFrame(self.overview_frame, text="系统信息")
        system_info_frame.pack(fill=tk.X, padx=5, pady=5)

        # 版本信息
        version_frame = tk.Frame(system_info_frame)
        version_frame.pack(fill=tk.X, padx=5, pady=2)

        version_label = ttk.Label(version_frame, text="系统版本:", width=15)
        version_label.pack(side=tk.LEFT)

        self.version_value = ttk.Label(version_frame, text="v1.0.0")
        self.version_value.pack(side=tk.LEFT, fill=tk.X, expand=True)

        # 运行时间
        uptime_frame = tk.Frame(system_info_frame)
        uptime_frame.pack(fill=tk.X, padx=5, pady=2)

        uptime_label = ttk.Label(uptime_frame, text="运行时间:", width=15)
        uptime_label.pack(side=tk.LEFT)

        self.uptime_value = ttk.Label(uptime_frame, text="00:00:00")
        self.uptime_value.pack(side=tk.LEFT, fill=tk.X, expand=True)

        # 启动时间
        starttime_frame = tk.Frame(system_info_frame)
        starttime_frame.pack(fill=tk.X, padx=5, pady=2)

        starttime_label = ttk.Label(starttime_frame, text="启动时间:", width=15)
        starttime_label.pack(side=tk.LEFT)

        self.starttime_value = ttk.Label(starttime_frame, text="未启动")
        self.starttime_value.pack(side=tk.LEFT, fill=tk.X, expand=True)

        # 模块状态页
        self.modules_frame = tk.Frame(self.notebook)
        self.notebook.add(self.modules_frame, text="模块状态")

        # 模块状态面板
        self.module_panel = ModuleStatusPanel(self.modules_frame)
        self.module_panel.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # 日志页
        self.logs_frame = tk.Frame(self.notebook)
        self.notebook.add(self.logs_frame, text="系统日志")

        # 系统日志面板
        self.log_panel = LogPanel(self.logs_frame)
        self.log_panel.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # 回调函数
        self.module_panel.on_start_module = self._on_start_module
        self.module_panel.on_stop_module = self._on_stop_module

        # 内部回调
        self.on_start_module = None
        self.on_stop_module = None

    def set_version(self, version):
        """
        设置系统版本

        Args:
            version: 版本字符串
        """
        self.version_value.config(text=version)

    def set_uptime(self, uptime):
        """
        设置系统运行时间

        Args:
            uptime: 运行时间字符串
        """
        self.uptime_value.config(text=uptime)

    def set_start_time(self, start_time):
        """
        设置系统启动时间

        Args:
            start_time: 启动时间字符串
        """
        self.starttime_value.config(text=start_time)

    def update_module(self, module_id, status, description=None):
        """
        更新模块状态

        Args:
            module_id: 模块ID
            status: 模块状态
            description: 模块描述
        """
        self.module_panel.update_module(module_id, status, description)

    def log(self, message, level="INFO"):
        """
        添加日志消息

        Args:
            message: 日志消息
            level: 日志级别
        """
        self.log_panel.log(message, level)

    def _on_start_module(self, module_id):
        """启动模块回调"""
        if callable(self.on_start_module):
            self.on_start_module(module_id)

    def _on_stop_module(self, module_id):
        """停止模块回调"""
        if callable(self.on_stop_module):
            self.on_stop_module(module_id)

"""
ASSEMBLY-CTRL System - UI Service
实现系统的用户交互界面服务，包括控制台界面和图形用户界面
"""

import cmd
import os
import sys
import time
import threading
import tkinter as tk
from tkinter import ttk, messagebox
import datetime
import json
from typing import Dict, List, Optional, Any, Callable, Union, Tuple

# =================================================================================
# 1. 控制台界面(CONSOLE_UI) - 提供命令行交互界面
# =================================================================================

class ConsoleUI(cmd.Cmd):
    """简单的控制台UI界面，通过命令行进行系统操作"""

    intro = """
    =====================================
        ASSEMBLY-CTRL 控制台界面
    =====================================
    输入 'help' 或 '?' 获取命令帮助
    输入 'exit' 退出控制台
    """
    prompt = "ASSEMBLY-CTRL> "

    def __init__(self, assembly_ctrl=None):
        """
        初始化控制台UI

        Args:
            assembly_ctrl: 总控模块实例，用于系统控制和状态查询
        """
        super().__init__()
        self.assembly_ctrl = assembly_ctrl
        self.running = False

    def start(self) -> None:
        """启动控制台UI循环"""
        self.running = True
        self._display_header()

        try:
            self.cmdloop()
        except KeyboardInterrupt:
            print("\n控制台已退出")
        finally:
            self.running = False

    def _display_header(self) -> None:
        """显示系统信息头"""
        print(self.intro)

        if self.assembly_ctrl:
            status = self.assembly_ctrl.get_system_status()
            print(f"系统状态: {status.get('status', '未知')}")
            print(f"版本: {status.get('version', 'v1.0.0')}")
            print(f"启动时间: {status.get('start_time', '未启动')}")
            print("-------------------------------------")

    def do_exit(self, arg) -> bool:
        """退出控制台"""
        print("正在退出控制台...")
        return True

    def do_quit(self, arg) -> bool:
        """退出控制台"""
        return self.do_exit(arg)

    def do_status(self, arg) -> None:
        """显示系统状态信息"""
        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        status = self.assembly_ctrl.get_system_status()
        self._display_status(status)

    def do_start(self, arg) -> None:
        """启动系统"""
        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            result = self.assembly_ctrl.start_system()
            if result.get('success'):
                print("系统已启动")
            else:
                print(f"启动失败: {result.get('message', '未知错误')}")
        except Exception as e:
            print(f"启动错误: {str(e)}")

    def do_stop(self, arg) -> None:
        """停止系统"""
        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            result = self.assembly_ctrl.stop_system()
            if result.get('success'):
                print("系统已停止")
            else:
                print(f"停止失败: {result.get('message', '未知错误')}")
        except Exception as e:
            print(f"停止错误: {str(e)}")

    def do_restart(self, arg) -> None:
        """重启系统"""
        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            result = self.assembly_ctrl.restart_system()
            if result.get('success'):
                print("系统已重启")
            else:
                print(f"重启失败: {result.get('message', '未知错误')}")
        except Exception as e:
            print(f"重启错误: {str(e)}")

    def do_modules(self, arg) -> None:
        """显示模块列表及状态"""
        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            modules = self.assembly_ctrl.get_modules()
            self._display_modules(modules)
        except Exception as e:
            print(f"获取模块信息错误: {str(e)}")

    def do_startmod(self, arg) -> None:
        """启动指定模块 (用法: startmod 模块ID)"""
        if not arg:
            print("错误: 缺少模块ID参数")
            return

        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            module_id = arg.strip()
            result = self.assembly_ctrl.start_module(module_id)
            if result.get('success'):
                print(f"模块 {module_id} 已启动")
            else:
                print(f"启动模块失败: {result.get('message', '未知错误')}")
        except Exception as e:
            print(f"启动模块错误: {str(e)}")

    def do_stopmod(self, arg) -> None:
        """停止指定模块 (用法: stopmod 模块ID)"""
        if not arg:
            print("错误: 缺少模块ID参数")
            return

        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            module_id = arg.strip()
            result = self.assembly_ctrl.stop_module(module_id)
            if result.get('success'):
                print(f"模块 {module_id} 已停止")
            else:
                print(f"停止模块失败: {result.get('message', '未知错误')}")
        except Exception as e:
            print(f"停止模块错误: {str(e)}")

    def do_tasks(self, arg) -> None:
        """显示任务列表"""
        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            tasks = self.assembly_ctrl.get_tasks()
            self._display_tasks(tasks)
        except Exception as e:
            print(f"获取任务信息错误: {str(e)}")

    def do_task(self, arg) -> None:
        """显示任务详情 (用法: task 任务ID)"""
        if not arg:
            print("错误: 缺少任务ID参数")
            return

        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            task_id = arg.strip()
            task = self._get_task_status(task_id)
            self._display_task_details(task)
        except Exception as e:
            print(f"获取任务详情错误: {str(e)}")

def do_gpt(self, arg) -> None:
        """提交GPT生成任务 (用法: gpt "提示文本")"""
        if not arg:
            print("错误: 缺少提示文本参数")
            return

        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            prompt = arg.strip()
            task_params = {
                "model": "gpt",
                "prompt": prompt,
                "max_tokens": 500
            }
            result = self.assembly_ctrl.execute_command("submit_task", task_params)

            if result.get('success'):
                task_id = result.get('task_id')
                print(f"任务已提交，任务ID: {task_id}")
                print("任务正在处理中，请稍候...")

                # 等待任务完成
                completed = False
                for _ in range(30):  # 最多等待30秒
                    task = self._get_task_status(task_id)
                    if task.get('status') == 'completed':
                        completed = True
                        result = task.get('result', '无结果')
                        print("\n--- 生成结果 ---")
                        print(result)
                        print("---------------")
                        break
                    elif task.get('status') == 'failed':
                        print(f"任务失败: {task.get('error', '未知错误')}")
                        break
                    time.sleep(1)

                if not completed:
                    print("任务处理超时，请使用 'task 任务ID' 查看结果")
            else:
                print(f"提交任务失败: {result.get('message', '未知错误')}")
        except Exception as e:
            print(f"提交任务错误: {str(e)}")

    def do_claude(self, arg) -> None:
        """提交Claude生成任务 (用法: claude "提示文本")"""
        if not arg:
            print("错误: 缺少提示文本参数")
            return

        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            prompt = arg.strip()
            task_params = {
                "model": "claude",
                "prompt": prompt,
                "max_tokens": 500
            }
            result = self.assembly_ctrl.execute_command("submit_task", task_params)

            if result.get('success'):
                task_id = result.get('task_id')
                print(f"任务已提交，任务ID: {task_id}")
                print("任务正在处理中，请稍候...")

                # 等待任务完成
                completed = False
                for _ in range(30):  # 最多等待30秒
                    task = self._get_task_status(task_id)
                    if task.get('status') == 'completed':
                        completed = True
                        result = task.get('result', '无结果')
                        print("\n--- 生成结果 ---")
                        print(result)
                        print("---------------")
                        break
                    elif task.get('status') == 'failed':
                        print(f"任务失败: {task.get('error', '未知错误')}")
                        break
                    time.sleep(1)

                if not completed:
                    print("任务处理超时，请使用 'task 任务ID' 查看结果")
            else:
                print(f"提交任务失败: {result.get('message', '未知错误')}")
        except Exception as e:
            print(f"提交任务错误: {str(e)}")

    def do_cancel(self, arg) -> None:
        """取消任务 (用法: cancel 任务ID)"""
        if not arg:
            print("错误: 缺少任务ID参数")
            return

        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            task_id = arg.strip()
            result = self.assembly_ctrl.cancel_task(task_id)
            if result.get('success'):
                print(f"任务 {task_id} 已取消")
            else:
                print(f"取消任务失败: {result.get('message', '未知错误')}")
        except Exception as e:
            print(f"取消任务错误: {str(e)}")

    def do_exec(self, arg) -> None:
        """执行自定义命令 (用法: exec 命令名称 参数)"""
        if not arg:
            print("错误: 缺少命令参数")
            return

        if not self.assembly_ctrl:
            print("错误: 系统控制器未连接")
            return

        try:
            parts = arg.split(maxsplit=1)
            cmd_name = parts[0]
            cmd_args = json.loads(parts[1]) if len(parts) > 1 else {}

            result = self.assembly_ctrl.execute_command(cmd_name, cmd_args)
            print(json.dumps(result, indent=2))
        except json.JSONDecodeError:
            print("错误: 命令参数必须是有效的JSON格式")
        except Exception as e:
            print(f"执行命令错误: {str(e)}")

    def _get_task_status(self, task_id: str) -> Dict:
        """
        获取任务状态

        Args:
            task_id: 任务ID

        Returns:
            任务状态信息字典
        """
        if not self.assembly_ctrl:
            return {'error': '系统控制器未连接'}

        try:
            return self.assembly_ctrl.get_task(task_id)
        except Exception as e:
            return {'error': str(e)}

    def _display_status(self, status: Dict) -> None:
        """
        显示系统状态信息

        Args:
            status: 状态信息字典
        """
        print("\n--- 系统状态 ---")
        print(f"状态: {status.get('status', '未知')}")
        print(f"版本: {status.get('version', 'v1.0.0')}")
        print(f"启动时间: {status.get('start_time', '未启动')}")
        print(f"运行时间: {status.get('uptime', '00:00:00')}")

        # 显示资源使用情况
        resources = status.get('resources', {})
        print("\n资源使用情况:")
        print(f"CPU使用率: {resources.get('cpu', 0)}%")
        print(f"内存使用率: {resources.get('memory', 0)}%")
        print(f"网络使用率: {resources.get('network', 0)}%")
        print("---------------")

    def _display_modules(self, modules: Dict) -> None:
        """
        显示模块列表及状态

        Args:
            modules: 模块信息字典
        """
        print("\n--- 模块列表 ---")
        fmt = "{:<15} {:<10} {:<40}"
        print(fmt.format("模块ID", "状态", "描述"))
        print("-" * 65)

        for module_id, module_info in modules.items():
            status = module_info.get('status', '未知')
            desc = module_info.get('description', '')
            print(fmt.format(module_id, status, desc))
        print("---------------")

def _display_tasks(self, tasks: List[Dict]) -> None:
        """
        显示任务列表

        Args:
            tasks: 任务信息列表
        """
        print("\n--- 任务列表 ---")
        fmt = "{:<15} {:<10} {:<15} {:<20} {:<20}"
        print(fmt.format("任务ID", "类型", "状态", "提交时间", "完成时间"))
        print("-" * 80)

        for task in tasks:
            task_id = task.get('id', '')
            task_type = task.get('type', '')
            status = task.get('status', '')
            submit_time = task.get('submit_time', '')
            complete_time = task.get('complete_time', '')
            print(fmt.format(task_id, task_type, status, submit_time, complete_time))
        print("---------------")

    def _display_task_details(self, task: Dict) -> None:
        """
        显示任务详情

        Args:
            task: 任务信息字典
        """
        if 'error' in task:
            print(f"错误: {task['error']}")
            return

        print("\n--- 任务详情 ---")
        print(f"任务ID: {task.get('id', '')}")
        print(f"类型: {task.get('type', '')}")
        print(f"状态: {task.get('status', '')}")
        print(f"提交时间: {task.get('submit_time', '')}")
        print(f"完成时间: {task.get('complete_time', '')}")

        # 显示任务参数
        print("\n任务参数:")
        params = task.get('params', {})
        for key, value in params.items():
            if isinstance(value, str) and len(value) > 50:
                value = value[:47] + "..."
            print(f"  {key}: {value}")

        # 显示任务结果或错误
        if task.get('status') == 'completed':
            print("\n任务结果:")
            result = task.get('result', '')
            if isinstance(result, str) and len(result) > 500:
                print(result[:500] + "...(结果已截断)")
            else:
                print(result)
        elif task.get('status') == 'failed':
            print(f"\n任务失败: {task.get('error', '未知错误')}")

        print("---------------")

# =================================================================================
# 2. 图形用户界面(SIMPLE_GUI) - 提供图形化交互界面
# =================================================================================

# 导入UI组件
try:
    from ui.dashboard.components import (
        ControlPanel, ConsolePanel, TaskPanel, StatusPanel,
        LogPanel, TaskTable, ModuleStatusPanel, StatusIndicator
    )
except ImportError:
    # 路径处理：当直接运行此文件时
    import sys
    from pathlib import Path
    root_dir = Path(__file__).resolve().parent.parent.parent
    if str(root_dir) not in sys.path:
        sys.path.append(str(root_dir))
    try:
        from ui.dashboard.components import (
            ControlPanel, ConsolePanel, TaskPanel, StatusPanel,
            LogPanel, TaskTable, ModuleStatusPanel, StatusIndicator
        )
    except ImportError:
        print("错误: 无法导入UI组件")

class SimpleGUI:
    """简单的图形用户界面，使用Tkinter实现"""

    def __init__(self, assembly_ctrl=None):
        """
        初始化图形用户界面

        Args:
            assembly_ctrl: 总控模块实例，用于系统控制和状态查询
        """
        self.assembly_ctrl = assembly_ctrl
        self.root = None
        self.running = False
        self.update_thread = None
        self.start_time = None

        # 资源数据
        self.resources = {
            'cpu': 0,
            'memory': 0,
            'network': 0
        }

    def start(self) -> None:
        """启动图形用户界面"""
        self.root = tk.Tk()
        self.root.title("ASSEMBLY-CTRL 系统控制台")
        self.root.geometry("1000x700")
        self.root.minsize(800, 600)

        # 设置图标（如果有）
        # self.root.iconbitmap('path/to/icon.ico')

        # 创建主框架
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # 创建左侧控制面板框架
        left_frame = tk.Frame(main_frame, width=300)
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, padx=(0, 5))

        # 创建右侧内容面板框架
        right_frame = tk.Frame(main_frame)
        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))

        # 设置左侧控制面板
        self._setup_control_panel(left_frame)

        # 设置右侧选项卡面板
        notebook = ttk.Notebook(right_frame)
        notebook.pack(fill=tk.BOTH, expand=True)

        # 创建状态面板页
        status_frame = tk.Frame(notebook)
        notebook.add(status_frame, text="系统状态")
        self._setup_status_panel(status_frame)

        # 创建控制台面板页
        console_frame = tk.Frame(notebook)
        notebook.add(console_frame, text="命令控制台")
        self._setup_console_panel(console_frame)

        # 创建任务面板页
        tasks_frame = tk.Frame(notebook)
        notebook.add(tasks_frame, text="任务管理")
        self._setup_tasks_panel(tasks_frame)

        # 启动状态更新线程
        self.running = True
        self.update_thread = threading.Thread(target=self._update_loop)
        self.update_thread.daemon = True
        self.update_thread.start()

        # 设置关闭事件处理
        self.root.protocol("WM_DELETE_WINDOW", self._on_close)

        # 启动主循环
        self.root.mainloop()

def _setup_control_panel(self, parent):
        """
        设置系统控制面板

        Args:
            parent: 父容器
        """
        self.control_panel = ControlPanel(parent)
        self.control_panel.pack(fill=tk.X, padx=5, pady=5)

        # 设置回调函数
        self.control_panel.on_start = self._start_system
        self.control_panel.on_stop = self._stop_system
        self.control_panel.on_restart = self._restart_system

        # 初始化系统状态
        if self.assembly_ctrl:
            status = self.assembly_ctrl.get_system_status()
            self.control_panel.set_system_status(
                status.get('status', 'inactive'),
                status.get('status_text', '未启动')
            )

    def _setup_status_panel(self, parent):
        """
        设置系统状态面板

        Args:
            parent: 父容器
        """
        self.status_panel = StatusPanel(parent)
        self.status_panel.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # 设置回调函数
        self.status_panel.on_start_module = self._start_module
        self.status_panel.on_stop_module = self._stop_module

        # 初始化系统信息
        if self.assembly_ctrl:
            status = self.assembly_ctrl.get_system_status()
            self.status_panel.set_version(status.get('version', 'v1.0.0'))
            self.status_panel.set_start_time(status.get('start_time', '未启动'))
            self.status_panel.set_uptime(status.get('uptime', '00:00:00'))

            # 初始化模块状态
            modules = self.assembly_ctrl.get_modules()
            for module_id, module_info in modules.items():
                self.status_panel.update_module(
                    module_id,
                    module_info.get('status', 'inactive'),
                    module_info.get('description', '')
                )

    def _setup_console_panel(self, parent):
        """
        设置命令控制台面板

        Args:
            parent: 父容器
        """
        self.console_panel = ConsolePanel(parent)
        self.console_panel.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # 设置命令执行回调
        self.console_panel.on_command = self._on_command_enter

        # 添加欢迎消息
        self.console_panel.log("欢迎使用 ASSEMBLY-CTRL 系统控制台", "INFO")
        self.console_panel.log("输入命令以控制系统", "INFO")

    def _setup_tasks_panel(self, parent):
        """
        设置任务管理面板

        Args:
            parent: 父容器
        """
        self.task_panel = TaskPanel(parent)
        self.task_panel.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # 设置回调函数
        self.task_panel.on_refresh = self._refresh_tasks
        self.task_panel.on_view_details = self._view_task_details
        self.task_panel.on_cancel_task = self._cancel_task

        # 初始化任务列表
        if self.assembly_ctrl:
            self._refresh_tasks()

    def _update_loop(self):
        """状态更新循环"""
        last_update_time = 0

        while self.running:
            # 控制更新频率
            current_time = time.time()
            if current_time - last_update_time < 1.0:  # 每秒更新一次
                time.sleep(0.1)
                continue

            last_update_time = current_time

            # 只有在系统控制器可用时才更新
            if not self.assembly_ctrl:
                time.sleep(1.0)
                continue

            try:
                # 更新系统状态
                status = self.assembly_ctrl.get_system_status()

                # 更新控制面板
                self.control_panel.set_system_status(
                    status.get('status', 'inactive'),
                    status.get('status_text', '未启动')
                )

                # 更新资源使用情况
                resources = status.get('resources', {})
                self.resources = {
                    'cpu': resources.get('cpu', 0),
                    'memory': resources.get('memory', 0),
                    'network': resources.get('network', 0)
                }

                self.control_panel.update_resources(
                    self.resources['cpu'],
                    self.resources['memory'],
                    self.resources['network']
                )

                # 更新运行时间
                self.status_panel.set_uptime(status.get('uptime', '00:00:00'))

                # 更新系统日志
                logs = self.assembly_ctrl.get_logs(max_count=5)
                for log in logs:
                    if log.get('is_new', False):
                        self.status_panel.log(
                            log.get('message', ''),
                            log.get('level', 'INFO')
                        )

                # 每隔10秒更新一次任务列表
                if int(current_time) % 10 == 0:
                    self._refresh_tasks()

            except Exception as e:
                # 记录错误但不中断循环
                print(f"状态更新错误: {str(e)}")

            time.sleep(0.1)

    def _on_close(self):
        """关闭窗口处理"""
        self.running = False
        if self.update_thread and self.update_thread.is_alive():
            self.update_thread.join(2.0)  # 等待更新线程结束，最多2秒

        self.root.destroy()

def _start_system(self):
        """启动系统"""
        if not self.assembly_ctrl:
            self.console_panel.log("错误: 系统控制器未连接", "ERROR")
            return

        try:
            self.console_panel.log("正在启动系统...", "INFO")
            self.control_panel.start_button.set_loading(True)

            result = self.assembly_ctrl.start_system()

            if result.get('success'):
                self.console_panel.log("系统已成功启动", "SUCCESS")
                self.start_time = datetime.datetime.now()
            else:
                self.console_panel.log(
                    f"启动失败: {result.get('message', '未知错误')}",
                    "ERROR"
                )
        except Exception as e:
            self.console_panel.log(f"启动错误: {str(e)}", "ERROR")
        finally:
            self.control_panel.start_button.set_loading(False)

    def _stop_system(self):
        """停止系统"""
        if not self.assembly_ctrl:
            self.console_panel.log("错误: 系统控制器未连接", "ERROR")
            return

        try:
            self.console_panel.log("正在停止系统...", "INFO")
            self.control_panel.stop_button.set_loading(True)

            result = self.assembly_ctrl.stop_system()

            if result.get('success'):
                self.console_panel.log("系统已成功停止", "SUCCESS")
                self.start_time = None
            else:
                self.console_panel.log(
                    f"停止失败: {result.get('message', '未知错误')}",
                    "ERROR"
                )
        except Exception as e:
            self.console_panel.log(f"停止错误: {str(e)}", "ERROR")
        finally:
            self.control_panel.stop_button.set_loading(False)

    def _restart_system(self):
        """重启系统"""
        if not self.assembly_ctrl:
            self.console_panel.log("错误: 系统控制器未连接", "ERROR")
            return

        try:
            self.console_panel.log("正在重启系统...", "INFO")
            self.control_panel.restart_button.set_loading(True)

            result = self.assembly_ctrl.restart_system()

            if result.get('success'):
                self.console_panel.log("系统已成功重启", "SUCCESS")
                self.start_time = datetime.datetime.now()
            else:
                self.console_panel.log(
                    f"重启失败: {result.get('message', '未知错误')}",
                    "ERROR"
                )
        except Exception as e:
            self.console_panel.log(f"重启错误: {str(e)}", "ERROR")
        finally:
            self.control_panel.restart_button.set_loading(False)

    def _start_module(self, module_id):
        """
        启动指定模块

        Args:
            module_id: 模块ID
        """
        if not self.assembly_ctrl:
            self.console_panel.log("错误: 系统控制器未连接", "ERROR")
            return

        try:
            self.console_panel.log(f"正在启动模块 {module_id}...", "INFO")

            result = self.assembly_ctrl.start_module(module_id)

            if result.get('success'):
                self.console_panel.log(f"模块 {module_id} 已成功启动", "SUCCESS")
            else:
                self.console_panel.log(
                    f"启动模块失败: {result.get('message', '未知错误')}",
                    "ERROR"
                )
        except Exception as e:
            self.console_panel.log(f"启动模块错误: {str(e)}", "ERROR")

    def _stop_module(self, module_id):
        """
        停止指定模块

        Args:
            module_id: 模块ID
        """
        if not self.assembly_ctrl:
            self.console_panel.log("错误: 系统控制器未连接", "ERROR")
            return

        try:
            self.console_panel.log(f"正在停止模块 {module_id}...", "INFO")

            result = self.assembly_ctrl.stop_module(module_id)

            if result.get('success'):
                self.console_panel.log(f"模块 {module_id} 已成功停止", "SUCCESS")
            else:
                self.console_panel.log(
                    f"停止模块失败: {result.get('message', '未知错误')}",
                    "ERROR"
                )
        except Exception as e:
            self.console_panel.log(f"停止模块错误: {str(e)}", "ERROR")

    def _on_command_enter(self, command):
        """
        处理控制台命令输入

        Args:
            command: 命令字符串

        Returns:
            命令执行结果
        """
        if not command:
            return

        if not self.assembly_ctrl:
            return "错误: 系统控制器未连接"

        try:
            # 解析命令
            parts = command.split(maxsplit=1)
            cmd_name = parts[0].lower()
            cmd_args = parts[1] if len(parts) > 1 else ""

            # 处理内置命令
            if cmd_name == "start":
                self._start_system()
                return None
            elif cmd_name == "stop":
                self._stop_system()
                return None
            elif cmd_name == "restart":
                self._restart_system()
                return None
            elif cmd_name == "startmod":
                if not cmd_args:
                    return "错误: 缺少模块ID参数"
                self._start_module(cmd_args.strip())
                return None
            elif cmd_name == "stopmod":
                if not cmd_args:
                    return "错误: 缺少模块ID参数"
                self._stop_module(cmd_args.strip())
                return None

            # 执行自定义命令
            try:
                # 尝试解析JSON参数
                if cmd_args:
                    try:
                        args = json.loads(cmd_args)
                    except json.JSONDecodeError:
                        # 如果不是JSON，将参数作为字符串处理
                        args = cmd_args
                else:
                    args = {}

                result = self.assembly_ctrl.execute_command(cmd_name, args)
                return json.dumps(result, indent=2, ensure_ascii=False)
            except Exception as e:
                return f"命令执行错误: {str(e)}"

        except Exception as e:
            return f"命令处理错误: {str(e)}"

    def _refresh_tasks(self):
        """刷新任务列表"""
        if not self.assembly_ctrl:
            return

        try:
            tasks = self.assembly_ctrl.get_tasks()

            # 清空现有任务
            self.task_panel.clear()

            # 添加新任务
            for task in tasks:
                self.task_panel.add_task(
                    task.get('id', ''),
                    task.get('type', ''),
                    task.get('status', ''),
                    task.get('submit_time', ''),
                    task.get('complete_time', '')
                )
        except Exception as e:
            self.console_panel.log(f"刷新任务列表错误: {str(e)}", "ERROR")

    def _view_task_details(self, task_values):
        """
        查看任务详情

        Args:
            task_values: 任务属性值列表
        """
        if not task_values or not self.assembly_ctrl:
            return

        try:
            task_id = task_values[0]
            task = self.assembly_ctrl.get_task(task_id)

            # 创建详情窗口
            details_window = tk.Toplevel(self.root)
            details_window.title(f"任务详情 - {task_id}")
            details_window.geometry("600x500")
            details_window.minsize(500, 400)

            # 任务基本信息
            info_frame = tk.LabelFrame(details_window, text="基本信息")
            info_frame.pack(fill=tk.X, padx=10, pady=(10, 5))

            # 基本信息表格
            info_items = [
                ("任务ID:", task.get('id', '')),
                ("类型:", task.get('type', '')),
                ("状态:", task.get('status', '')),
                ("提交时间:", task.get('submit_time', '')),
                ("完成时间:", task.get('complete_time', ''))
            ]

            for i, (label_text, value_text) in enumerate(info_items):
                frame = tk.Frame(info_frame)
                frame.pack(fill=tk.X, padx=5, pady=2)

                label = ttk.Label(frame, text=label_text, width=15)
                label.pack(side=tk.LEFT)

                value = ttk.Label(frame, text=value_text)
                value.pack(side=tk.LEFT, fill=tk.X, expand=True)

            # 任务参数
            params_frame = tk.LabelFrame(details_window, text="任务参数")
            params_frame.pack(fill=tk.X, padx=10, pady=5)

            params = task.get('params', {})
            for key, value in params.items():
                frame = tk.Frame(params_frame)
                frame.pack(fill=tk.X, padx=5, pady=2)

                label = ttk.Label(frame, text=f"{key}:", width=15)
                label.pack(side=tk.LEFT)

                # 如果值太长，显示简短版本
                if isinstance(value, str) and len(value) > 50:
                    value_text = value[:47] + "..."
                else:
                    value_text = str(value)

                value_label = ttk.Label(frame, text=value_text)
                value_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            # 任务结果
            result_frame = tk.LabelFrame(details_window, text="任务结果")
            result_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=(5, 10))

            result_text = scrolledtext.ScrolledText(result_frame, wrap=tk.WORD)
            result_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

            # 设置结果文本
            if task.get('status') == 'completed':
                result = task.get('result', '')
                result_text.insert(tk.END, result)
            elif task.get('status') == 'failed':
                error = task.get('error', '未知错误')
                result_text.insert(tk.END, f"任务失败: {error}")
                result_text.tag_configure("error", foreground="red")
                result_text.tag_add("error", "1.0", "end")
            else:
                result_text.insert(tk.END, "任务尚未完成")

            result_text.config(state=tk.DISABLED)

            # 按钮区域
            button_frame = tk.Frame(details_window)
            button_frame.pack(fill=tk.X, padx=10, pady=(0, 10))

            close_button = ttk.Button(button_frame, text="关闭",
                                    command=details_window.destroy)
            close_button.pack(side=tk.RIGHT)

            # 如果任务正在运行，添加取消按钮
            if task.get('status') == 'running' or task.get('status') == 'pending':
                cancel_button = ttk.Button(button_frame, text="取消任务",
                                         command=lambda: self._cancel_task_and_close(task_id, details_window))
                cancel_button.pack(side=tk.RIGHT, padx=(0, 5))

        except Exception as e:
            self.console_panel.log(f"查看任务详情错误: {str(e)}", "ERROR")

    def _cancel_task(self, task_id):
        """
        取消任务

        Args:
            task_id: 任务ID
        """
        if not self.assembly_ctrl:
            self.console_panel.log("错误: 系统控制器未连接", "ERROR")
            return

        try:
            self.console_panel.log(f"正在取消任务 {task_id}...", "INFO")

            result = self.assembly_ctrl.cancel_task(task_id)

            if result.get('success'):
                self.console_panel.log(f"任务 {task_id} 已成功取消", "SUCCESS")
                self._refresh_tasks()
            else:
                self.console_panel.log(
                    f"取消任务失败: {result.get('message', '未知错误')}",
                    "ERROR"
                )
        except Exception as e:
            self.console_panel.log(f"取消任务错误: {str(e)}", "ERROR")

    def _cancel_task_and_close(self, task_id, window):
        """
        取消任务并关闭窗口

        Args:
            task_id: 任务ID
            window: 要关闭的窗口
        """
        self._cancel_task(task_id)
        window.destroy()

# =================================================================================
# 3. UI服务初始化和导出函数
# =================================================================================

def create_console_ui(assembly_ctrl=None):
    """
    创建控制台UI实例

    Args:
        assembly_ctrl: 总控模块实例

    Returns:
        ConsoleUI实例
    """
    return ConsoleUI(assembly_ctrl)

def create_gui(assembly_ctrl=None):
    """
    创建图形用户界面实例

    Args:
        assembly_ctrl: 总控模块实例

    Returns:
        SimpleGUI实例
    """
    return SimpleGUI(assembly_ctrl)

def start_ui(ui_type="console", assembly_ctrl=None):
    """
    启动用户界面

    Args:
        ui_type: 界面类型，可选值为'console'或'gui'
        assembly_ctrl: 总控模块实例

    Returns:
        界面实例
    """
    if ui_type.lower() == "gui":
        ui = create_gui(assembly_ctrl)
    else:
        ui = create_console_ui(assembly_ctrl)

    ui.start()
    return ui
==================== [第五阶段 - 支持服务] ====================
"""
修复备份模块：负责系统备份、恢复和模块修复功能

此模块提供系统状态的备份和恢复功能，以及模块级别的故障检测和修复能力。
它实现了定时备份调度，系统健康检查，以及针对性的模块修复策略。
"""

import os
import json
import time
import shutil
import uuid
import threading
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# 假设这些导入已经在系统中定义
from utils.config import Config
from core.message_bus import MessageBus, Message
from core.error_handler import ErrorHandler
from core.module_registry import ModuleRegistry

# =================================================================================
# 1. 修复备份模块(RepairBackup) - 负责系统备份、恢复和模块修复
# =================================================================================

class RepairBackup:
    """修复模块窗口：负责系统备份、恢复和模块修复

    此类提供系统状态的完整备份和恢复功能，包括定时备份调度、
    系统健康检查以及针对性的模块故障检测和修复能力。

    Attributes:
        config (Config): 系统配置对象
        message_bus (MessageBus): 消息总线，用于模块间通信
        error_handler (ErrorHandler): 错误处理器
        backup_directory (str): 备份文件存储目录
        backup_schedule (Dict): 备份调度配置
        scheduler_thread (threading.Thread): 定时备份线程
        running (bool): 模块运行状态标志
        module_id (str): 模块唯一标识符
    """

    def __init__(self, config: Optional[Config] = None,
                 message_bus: Optional[MessageBus] = None,
                 error_handler: Optional[ErrorHandler] = None):
        """初始化修复备份模块

        Args:
            config: 系统配置对象，若为None则使用默认配置
            message_bus: 消息总线对象，用于模块间通信
            error_handler: 错误处理器对象
        """
        self.config = config if config else Config()
        self.message_bus = message_bus
        self.error_handler = error_handler
        self.module_id = "repair_backup"
        self.running = False

        # 备份存储目录
        self.backup_directory = os.path.join("data", "backups")
        os.makedirs(self.backup_directory, exist_ok=True)

        # 备份调度配置
        self.backup_schedule = {
            "interval": 3600,  # 默认1小时
            "retain_count": 5,  # 默认保留5个备份
            "enabled": False,
            "last_backup": None,
            "next_backup": None
        }

        self.scheduler_thread = None
        self._register_module()

        logging.info(f"RepairBackup模块初始化完成")

    def _register_module(self) -> None:
        """向系统注册模块，并订阅相关消息"""
        if self.message_bus:
            # 注册模块
            self.message_bus.register_handler(
                source="*",
                message_type="backup_request",
                handler=self._handle_backup_request
            )
            self.message_bus.register_handler(
                source="*",
                message_type="restore_request",
                handler=self._handle_restore_request
            )
            self.message_bus.register_handler(
                source="*",
                message_type="repair_request",
                handler=self._handle_repair_request
            )
            self.message_bus.register_handler(
                source="*",
                message_type="health_check",
                handler=self._handle_health_check
            )

            # 向ModuleRegistry注册
            registry_message = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": "module_registry",
                "priority": "high",
                "type": "register_module",
                "payload": {
                    "module_id": self.module_id,
                    "module_type": "support_service",
                    "capabilities": ["backup", "restore", "repair", "health_check"],
                    "status": "initialized"
                },
                "metadata": {}
            }
            self.message_bus.send_message(registry_message)
            logging.info(f"RepairBackup模块已注册到系统")

    def start(self) -> bool:
        """启动修复备份模块

        初始化资源并开始定时备份任务（如果已配置）

        Returns:
            bool: 启动是否成功
        """
        try:
            self.running = True

            # 恢复模块状态
            self._restore_module_state()

            # 如果启用了定时备份，启动调度线程
            if self.backup_schedule["enabled"]:
                self._start_backup_scheduler()

            # 向总控发送启动成功消息
            if self.message_bus:
                status_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "module_status",
                    "payload": {
                        "module_id": self.module_id,
                        "status": "running",
                        "resources": self._get_resource_usage()
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(status_message)

            logging.info(f"RepairBackup模块已启动")
            return True
        except Exception as e:
            self.running = False
            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="startup_error",
                    error_message=str(e)
                )
            logging.error(f"RepairBackup模块启动失败: {str(e)}")
            return False

    def stop(self) -> bool:
        """停止修复备份模块

        保存状态，停止定时备份，释放资源

        Returns:
            bool: 停止是否成功
        """
        try:
            # 保存模块状态
            self._save_module_state()

            # 停止备份调度线程
            if self.scheduler_thread and self.scheduler_thread.is_alive():
                self.running = False
                self.scheduler_thread.join(timeout=5)

            # 向总控发送停止消息
            if self.message_bus:
                status_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "module_status",
                    "payload": {
                        "module_id": self.module_id,
                        "status": "stopped",
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(status_message)

            logging.info(f"RepairBackup模块已停止")
            return True
        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="shutdown_error",
                    error_message=str(e)
                )
            logging.error(f"RepairBackup模块停止失败: {str(e)}")
            return False

    def create_backup(self, backup_name: str = None) -> Dict:
        """创建系统状态备份

        Args:
            backup_name: 备份名称，如未提供则使用时间戳

        Returns:
            Dict: 包含备份信息的字典，包括id和创建时间
        """
        try:
            return self._perform_backup(backup_name)
        except Exception as e:
            error_msg = f"创建备份失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="backup_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

    def list_backups(self) -> List[Dict]:
        """列出所有可用备份

        Returns:
            List[Dict]: 备份信息列表，每项包含id、名称、创建时间等
        """
        backups = []
        try:
            for item in os.listdir(self.backup_directory):
                if item.endswith('.backup'):
                    backup_path = os.path.join(self.backup_directory, item)
                    # 读取备份元数据
                    with open(backup_path, 'r') as f:
                        try:
                            backup_data = json.load(f)
                            backups.append({
                                "backup_id": backup_data.get("backup_id"),
                                "name": backup_data.get("name"),
                                "created_at": backup_data.get("created_at"),
                                "size": os.path.getsize(backup_path),
                                "modules": backup_data.get("modules", [])
                            })
                        except json.JSONDecodeError:
                            logging.warning(f"无法解析备份文件: {backup_path}")

            # 按创建时间排序，最新的在前
            backups.sort(key=lambda x: x["created_at"], reverse=True)
            return backups
        except Exception as e:
            error_msg = f"列出备份失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="list_backups_error",
                    error_message=error_msg
                )
            return []

    def restore_backup(self, backup_id: str) -> bool:
        """从备份恢复系统状态

        Args:
            backup_id: 要恢复的备份ID

        Returns:
            bool: 恢复是否成功
        """
        try:
            return self._perform_restore(backup_id)
        except Exception as e:
            error_msg = f"恢复备份{backup_id}失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="restore_error",
                    error_message=error_msg
                )
            return False

    def verify_system_health(self) -> Dict:
        """执行系统健康检查

        检查所有注册模块的状态，系统资源使用情况，以及关键服务

        Returns:
            Dict: 包含健康状态信息的字典
        """
        health_info = {
            "overall_status": "unknown",
            "check_time": datetime.now().isoformat(),
            "modules": {},
            "resources": self._get_resource_usage(),
            "issues_detected": [],
            "recommendations": []
        }

        try:
            # 获取所有模块状态
            if self.message_bus:
                # 请求模块注册表信息
                registry_request = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "module_registry",
                    "priority": "high",
                    "type": "get_modules",
                    "payload": {},
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }

                # 这里假设同步获取模块列表(实际实现可能需要异步)
                modules_response = self.message_bus.send_message(registry_request, wait_response=True)

                if modules_response and "modules" in modules_response.get("payload", {}):
                    modules = modules_response["payload"]["modules"]

                    # 检查每个模块的健康状态
                    issues_count = 0
                    for module_id, module_info in modules.items():
                        # 对每个模块进行诊断
                        module_diagnosis = self._diagnose_module(module_id)
                        health_info["modules"][module_id] = module_diagnosis

                        if module_diagnosis.get("status") != "healthy":
                            issues_count += 1
                            health_info["issues_detected"].append({
                                "module": module_id,
                                "issue": module_diagnosis.get("issues", ["未知问题"])[0],
                                "severity": module_diagnosis.get("severity", "high")
                            })

                            # 添加修复建议
                            if module_diagnosis.get("fix_available", False):
                                health_info["recommendations"].append({
                                    "module": module_id,
                                    "action": "repair",
                                    "description": f"修复模块 {module_id} 中的问题"
                                })

                    # 设置整体状态
                    if issues_count == 0:
                        health_info["overall_status"] = "healthy"
                    elif issues_count < len(modules) * 0.2:  # 少于20%的模块有问题
                        health_info["overall_status"] = "warning"
                    else:
                        health_info["overall_status"] = "critical"

                    # 检查最后备份时间，如果过久则建议备份
                    last_backup = None
                    backups = self.list_backups()
                    if backups:
                        last_backup = backups[0]["created_at"]
                        last_backup_time = datetime.fromisoformat(last_backup)
                        now = datetime.now()
                        hours_since_backup = (now - last_backup_time).total_seconds() / 3600

                        if hours_since_backup > 24:  # 超过24小时未备份
                            health_info["recommendations"].append({
                                "action": "backup",
                                "description": f"系统已超过{int(hours_since_backup)}小时未备份，建议立即创建备份"
                            })
                    else:
                        health_info["recommendations"].append({
                            "action": "backup",
                            "description": "系统未发现任何备份，建议立即创建首个备份"
                        })

            return health_info
        except Exception as e:
            error_msg = f"系统健康检查失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="health_check_error",
                    error_message=error_msg
                )
            health_info["overall_status"] = "error"
            health_info["issues_detected"].append({
                "module": "repair_backup",
                "issue": f"健康检查过程中出错: {str(e)}",
                "severity": "high"
            })
            return health_info

    def repair_module(self, module_id: str) -> Dict:
        """修复特定模块的问题

        Args:
            module_id: 需要修复的模块ID

        Returns:
            Dict: 包含修复结果的字典
        """
        try:
            # 先诊断模块
            diagnosis = self._diagnose_module(module_id)

            # 如果模块健康，无需修复
            if diagnosis.get("status") == "healthy":
                return {
                    "success": True,
                    "module_id": module_id,
                    "status": "healthy",
                    "message": "模块运行正常，无需修复",
                    "actions_taken": []
                }

            # 尝试修复模块问题
            fix_result = self._fix_module_issues(module_id, diagnosis)

            # 再次诊断，确认修复效果
            post_diagnosis = self._diagnose_module(module_id)

            result = {
                "success": fix_result.get("success", False),
                "module_id": module_id,
                "pre_status": diagnosis.get("status"),
                "post_status": post_diagnosis.get("status"),
                "issues_fixed": fix_result.get("fixed_issues", []),
                "remaining_issues": post_diagnosis.get("issues", []),
                "actions_taken": fix_result.get("actions", []),
                "timestamp": datetime.now().isoformat()
            }

            # 如果修复成功，通知相关模块
            if result["success"] and self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "high",
                    "type": "module_repaired",
                    "payload": {
                        "module_id": module_id,
                        "repair_result": result
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)

            return result
        except Exception as e:
            error_msg = f"修复模块{module_id}失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="repair_error",
                    error_message=error_msg
                )
            return {
                "success": False,
                "module_id": module_id,
                "error": error_msg,
                "timestamp": datetime.now().isoformat()
            }

    def schedule_backup(self, interval: int, retain_count: int = 5) -> bool:
        """设置定时备份计划

        Args:
            interval: 备份间隔(秒)
            retain_count: 保留的备份数量

        Returns:
            bool: 设置是否成功
        """
        try:
            # 更新备份配置
            self.backup_schedule["interval"] = interval
            self.backup_schedule["retain_count"] = retain_count
            self.backup_schedule["enabled"] = True
            self.backup_schedule["next_backup"] = time.time() + interval

            # 如果已有线程在运行，停止它
            if self.scheduler_thread and self.scheduler_thread.is_alive():
                self.running = False
                self.scheduler_thread.join(timeout=5)

            # 启动新的调度线程
            self._start_backup_scheduler()

            # 保存配置
            self._save_module_state()

            logging.info(f"已设置定时备份: 间隔{interval}秒, 保留{retain_count}个备份")
            return True
        except Exception as e:
            error_msg = f"设置定时备份失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="schedule_error",
                    error_message=error_msg
                )
            return False

    def _perform_backup(self, backup_name: str = None) -> Dict:
        """执行系统备份操作

        Args:
            backup_name: 备份名称

        Returns:
            Dict: 备份结果信息
        """
        # 生成备份ID和名称
        backup_id = str(uuid.uuid4())
        if not backup_name:
            backup_name = f"系统备份-{datetime.now().strftime('%Y%m%d-%H%M%S')}"

        timestamp = datetime.now().isoformat()
        backup_filename = os.path.join(self.backup_directory, f"{backup_id}.backup")

        try:
            # 收集系统状态
            system_state = {}
            module_states = {}

            # 请求各模块状态
            if self.message_bus:
                # 获取模块列表
                registry_request = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "module_registry",
                    "priority": "high",
                    "type": "get_modules",
                    "payload": {},
                    "metadata": {"timestamp": timestamp}
                }

                # 同步获取模块列表
                modules_response = self.message_bus.send_message(registry_request, wait_response=True)

                if modules_response and "modules" in modules_response.get("payload", {}):
                    modules = modules_response["payload"]["modules"]

                    # 对每个模块请求状态
                    for module_id in modules:
                        state_request = {
                            "message_id": str(uuid.uuid4()),
                            "source": self.module_id,
                            "destination": module_id,
                            "priority": "high",
                            "type": "get_state",
                            "payload": {"for_backup": True},
                            "metadata": {"timestamp": timestamp}
                        }

                        # 同步获取模块状态
                        state_response = self.message_bus.send_message(state_request, wait_response=True)
                        if state_response and "state" in state_response.get("payload", {}):
                            module_states[module_id] = state_response["payload"]["state"]

            # 收集系统配置
            system_state = {
                "config": self.config.get_all() if self.config else {},
                "modules": module_states,
                "timestamp": timestamp
            }

            # 创建备份记录
            backup_data = {
                "backup_id": backup_id,
                "name": backup_name,
                "created_at": timestamp,
                "modules": list(module_states.keys()),
                "system_state": system_state
            }

            # 写入备份文件
            with open(backup_filename, 'w') as f:
                json.dump(backup_data, f, indent=2)

            # 更新最后备份时间
            self.backup_schedule["last_backup"] = time.time()

            # 清理旧备份
            self._cleanup_old_backups()

            # 通知备份完成
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "backup_completed",
                    "payload": {
                        "backup_id": backup_id,
                        "name": backup_name,
                        "created_at": timestamp,
                        "size": os.path.getsize(backup_filename),
                        "modules": list(module_states.keys())
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)

            return {
                "success": True,
                "backup_id": backup_id,
                "name": backup_name,
                "created_at": timestamp,
                "size": os.path.getsize(backup_filename),
                "modules": list(module_states.keys())
            }
        except Exception as e:
            error_msg = f"执行备份操作失败: {str(e)}"
            logging.error(error_msg)
            if os.path.exists(backup_filename):
                os.remove(backup_filename)  # 清理失败的备份文件

            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="backup_operation_error",
                    error_message=error_msg
                )

            return {"success": False, "error": error_msg}

    def _perform_restore(self, backup_id: str) -> bool:
        """执行系统恢复操作

        Args:
            backup_id: 备份ID

        Returns:
            bool: 恢复是否成功
        """
        backup_filename = os.path.join(self.backup_directory, f"{backup_id}.backup")

        # 验证备份是否存在
        if not os.path.exists(backup_filename):
            error_msg = f"备份{backup_id}不存在"
            logging.error(error_msg)
            return False

        try:
            # 验证备份完整性
            if not self._verify_backup(backup_id):
                error_msg = f"备份{backup_id}验证失败，可能已损坏"
                logging.error(error_msg)
                return False

            # 读取备份数据
            with open(backup_filename, 'r') as f:
                backup_data = json.load(f)

            # 通知系统即将恢复
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "critical",
                    "type": "restore_starting",
                    "payload": {
                        "backup_id": backup_id,
                        "name": backup_data.get("name"),
                        "created_at": backup_data.get("created_at")
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)

            # 恢复系统配置
            system_state = backup_data.get("system_state", {})
            if self.config and "config" in system_state:
                self.config.update(system_state["config"])

            # 恢复各模块状态
            module_states = system_state.get("modules", {})
            restore_results = {}

            if self.message_bus:
                for module_id, module_state in module_states.items():
                    restore_request = {
                        "message_id": str(uuid.uuid4()),
                        "source": self.module_id,
                        "destination": module_id,
                        "priority": "critical",
                        "type": "restore_state",
                        "payload": {"state": module_state},
                        "metadata": {"timestamp": datetime.now().isoformat()}
                    }

                    # 同步恢复每个模块
                    response = self.message_bus.send_message(restore_request, wait_response=True)
                    restore_results[module_id] = response.get("payload", {}).get("success", False) if response else False

            # 检查恢复结果
            all_success = all(restore_results.values())

            # 通知恢复完成
            if self.message_bus:
                complete_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "critical",
                    "type": "restore_completed",
                    "payload": {
                        "backup_id": backup_id,
                        "success": all_success,
                        "module_results": restore_results
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(complete_message)

            logging.info(f"系统恢复完成: 备份{backup_id}，总体结果：{'成功' if all_success else '部分失败'}")
            return all_success
        except Exception as e:
            error_msg = f"执行恢复操作失败: {str(e)}"
            logging.error(error_msg)

            if self.error_handler:
                self.error_handler.handle_error(
                    module="repair_backup",
                    error_type="restore_operation_error",
                    error_message=error_msg
                )

            # 通知恢复失败
            if self.message_bus:
                error_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "critical",
                    "type": "restore_failed",
                    "payload": {
                        "backup_id": backup_id,
                        "error": str(e)
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(error_message)

            return False

    def _verify_backup(self, backup_id: str) -> bool:
        """验证备份完整性

        Args:
            backup_id: 备份ID

        Returns:
            bool: 备份是否完整有效
        """
        backup_filename = os.path.join(self.backup_directory, f"{backup_id}.backup")

        if not os.path.exists(backup_filename):
            return False

        try:
            # 尝试加载JSON文件来验证格式
            with open(backup_filename, 'r') as f:
                backup_data = json.load(f)

            # 验证必要字段
            required_fields = ["backup_id", "created_at", "system_state"]
            for field in required_fields:
                if field not in backup_data:
                    logging.warning(f"备份验证失败: 缺少字段 {field}")
                    return False

            # 验证系统状态数据
            system_state = backup_data.get("system_state", {})
            if not isinstance(system_state, dict):
                logging.warning("备份验证失败: 系统状态格式错误")
                return False

            # 验证模块数据
            modules = system_state.get("modules", {})
            if not isinstance(modules, dict):
                logging.warning("备份验证失败: 模块状态格式错误")
                return False

            return True
        except json.JSONDecodeError:
            logging.warning(f"备份验证失败: 无法解析JSON文件")
            return False
        except Exception as e:
            logging.warning(f"备份验证失败: {str(e)}")
            return False

    def _diagnose_module(self, module_id: str) -> Dict:
        """诊断模块健康状态

        Args:
            module_id: 模块ID

        Returns:
            Dict: 包含诊断结果的字典
        """
        diagnosis = {
            "module_id": module_id,
            "status": "unknown",
            "check_time": datetime.now().isoformat(),
            "issues": [],
            "severity": "unknown",
            "fix_available": False,
            "resource_usage": {}
        }

        try:
            if not self.message_bus:
                diagnosis["status"] = "unknown"
                diagnosis["issues"].append("无法与消息总线通信")
                diagnosis["severity"] = "high"
                return diagnosis

            # 向模块发送健康检查请求
            health_request = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": module_id,
                "priority": "high",
                "type": "health_check",
                "payload": {},
                "metadata": {"timestamp": datetime.now().isoformat()}
            }

            # 同步获取模块健康状态
            response = self.message_bus.send_message(health_request, wait_response=True, timeout=5)

            if not response:
                # 模块未响应
                diagnosis["status"] = "critical"
                diagnosis["issues"].append("模块未响应健康检查请求")
                diagnosis["severity"] = "high"
                diagnosis["fix_available"] = True
                return diagnosis

            # 分析响应，确定健康状态
            payload = response.get("payload", {})
            diagnosis["status"] = payload.get("status", "unknown")
            diagnosis["resource_usage"] = payload.get("resources", {})

            if diagnosis["status"] != "healthy":
                diagnosis["issues"] = payload.get("issues", ["未知问题"])
                diagnosis["severity"] = payload.get("severity", "medium")
                diagnosis["fix_available"] = payload.get("fix_available", False)

            return diagnosis
        except Exception as e:
            logging.error(f"诊断模块{module_id}失败: {str(e)}")
            diagnosis["status"] = "error"
            diagnosis["issues"].append(f"诊断过程中出错: {str(e)}")
            diagnosis["severity"] = "high"
            return diagnosis

    def _fix_module_issues(self, module_id: str, diagnosis: Dict) -> Dict:
        """修复模块问题

        Args:
            module_id: 模块ID
            diagnosis: 诊断结果

        Returns:
            Dict: 修复结果
        """
        result = {
            "success": False,
            "module_id": module_id,
            "fixed_issues": [],
            "remaining_issues": diagnosis.get("issues", []).copy(),
            "actions": []
        }

        # 如果模块无问题，直接返回成功
        if diagnosis.get("status") == "healthy":
            result["success"] = True
            result["remaining_issues"] = []
            return result

        try:
            # 根据问题类型采取不同修复策略
            issues = diagnosis.get("issues", [])

            # 1. 尝试重启模块
            if "模块未响应" in str(issues) or "模块崩溃" in str(issues):
                if self.message_bus:
                    restart_request = {
                        "message_id": str(uuid.uuid4()),
                        "source": self.module_id,
                        "destination": "assembly_ctrl",  # 向总控发送重启请求
                        "priority": "high",
                        "type": "restart_module",
                        "payload": {"module_id": module_id},
                        "metadata": {"timestamp": datetime.now().isoformat()}
                    }

                    response = self.message_bus.send_message(restart_request, wait_response=True)

                    if response and response.get("payload", {}).get("success", False):
                        result["actions"].append("重启模块")
                        result["fixed_issues"].append("模块未响应/崩溃")
                        result["remaining_issues"].remove("模块未响应健康检查请求") if "模块未响应健康检查请求" in result["remaining_issues"] else None

            # 2. 检查资源问题
            if "资源不足" in str(issues) or "内存泄漏" in str(issues):
                # 请求释放资源
                if self.message_bus:
                    resource_request = {
                        "message_id": str(uuid.uuid4()),
                        "source": self.module_id,
                        "destination": module_id,
                        "priority": "high",
                        "type": "release_resources",
                        "payload": {},
                        "metadata": {"timestamp": datetime.now().isoformat()}
                    }

                    response = self.message_bus.send_message(resource_request, wait_response=True)

                    if response and response.get("payload", {}).get("success", False):
                        result["actions"].append("释放模块资源")
                        result["fixed_issues"].append("资源问题")
                        # 从剩余问题中移除已修复的
                        for issue in list(result["remaining_issues"]):
                            if "资源" in issue or "内存" in issue:
                                result["remaining_issues"].remove(issue)

            # 3. 恢复配置问题
            if "配置错误" in str(issues) or "状态不一致" in str(issues):
                # 从最近的备份恢复此模块的配置
                backups = self.list_backups()
                if backups:
                    latest_backup_id = backups[0]["backup_id"]

                    # 读取备份
                    backup_filename = os.path.join(self.backup_directory, f"{latest_backup_id}.backup")
                    with open(backup_filename, 'r') as f:
                        backup_data = json.load(f)

                    # 获取模块状态
                    module_state = backup_data.get("system_state", {}).get("modules", {}).get(module_id, None)

                    if module_state and self.message_bus:
                        restore_request = {
                            "message_id": str(uuid.uuid4()),
                            "source": self.module_id,
                            "destination": module_id,
                            "priority": "high",
                            "type": "restore_state",
                            "payload": {"state": module_state, "partial": True},
                            "metadata": {"timestamp": datetime.now().isoformat()}
                        }

                        response = self.message_bus.send_message(restore_request, wait_response=True)

                        if response and response.get("payload", {}).get("success", False):
                            result["actions"].append("从备份恢复模块配置")
                            result["fixed_issues"].append("配置/状态问题")
                            # 从剩余问题中移除已修复的
                            for issue in list(result["remaining_issues"]):
                                if "配置" in issue or "状态" in issue:
                                    result["remaining_issues"].remove(issue)

            # 4. 其他未知问题，尝试重置模块
            if result["remaining_issues"] and self.message_bus:
                reset_request = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": module_id,
                    "priority": "high",
                    "type": "reset_module",
                    "payload": {},
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }

                response = self.message_bus.send_message(reset_request, wait_response=True)

                if response and response.get("payload", {}).get("success", False):
                    result["actions"].append("重置模块")
                    result["fixed_issues"].append("未知问题")
                    result["remaining_issues"] = []

            # 评估修复结果
            result["success"] = len(result["fixed_issues"]) > 0 and len(result["remaining_issues"]) == 0

            return result
        except Exception as e:
            logging.error(f"修复模块{module_id}问题失败: {str(e)}")
            result["actions"].append(f"修复失败: {str(e)}")
            return result

    def _get_resource_usage(self) -> Dict:
        """获取资源使用情况

        Returns:
            Dict: 包含资源使用信息的字典
        """
        try:
            import psutil

            # 获取系统资源信息
            cpu_percent = psutil.cpu_percent(interval=0.1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')

            return {
                "cpu_percent": cpu_percent,
                "memory_percent": memory.percent,
                "memory_used_mb": memory.used / (1024 * 1024),
                "disk_percent": disk.percent,
                "disk_free_gb": disk.free / (1024 * 1024 * 1024),
                "timestamp": datetime.now().isoformat()
            }
        except ImportError:
            # 如果无法导入psutil，返回最小信息
            return {
                "note": "psutil未安装，无法获取详细资源信息",
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logging.warning(f"获取资源使用信息失败: {str(e)}")
            return {
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }

    def _handle_message(self, message: Message) -> None:
        """处理接收到的消息

        Args:
            message: 接收到的消息对象
        """
        message_type = message.get("type", "")

        # 根据消息类型调用不同的处理方法
        handlers = {
            "backup_request": self._handle_backup_request,
            "restore_request": self._handle_restore_request,
            "repair_request": self._handle_repair_request,
            "health_check": self._handle_health_check
        }

        if message_type in handlers:
            handlers[message_type](message)
        else:
            logging.warning(f"收到未知类型消息: {message_type}")

    def _handle_backup_request(self, message: Message) -> None:
        """处理备份请求消息

        Args:
            message: 备份请求消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        backup_name = payload.get("backup_name", None)

        # 执行备份
        result = self.create_backup(backup_name)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "backup_response",
                "payload": result,
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_restore_request(self, message: Message) -> None:
        """处理恢复请求消息

        Args:
            message: 恢复请求消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        backup_id = payload.get("backup_id", "")

        if not backup_id:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "restore_response",
                    "payload": {
                        "success": False,
                        "error": "未提供备份ID"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行恢复
        result = self.restore_backup(backup_id)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "restore_response",
                "payload": {
                    "success": result,
                    "backup_id": backup_id
                },
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_repair_request(self, message: Message) -> None:
        """处理修复请求消息

        Args:
            message: 修复请求消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        module_id = payload.get("module_id", "")

        if not module_id:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "repair_response",
                    "payload": {
                        "success": False,
                        "error": "未提供模块ID"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行修复
        result = self.repair_module(module_id)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "repair_response",
                "payload": result,
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_health_check(self, message: Message) -> None:
        """处理健康检查消息

        Args:
            message: 健康检查消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")

        # 如果是针对此模块的健康检查
        if message.get("destination", "") == self.module_id:
            # 返回此模块的健康状态
            health_status = {
                "status": "healthy" if self.running else "stopped",
                "resources": self._get_resource_usage(),
                "backups_count": len(self.list_backups()),
                "last_backup": self.backup_schedule["last_backup"],
                "next_backup": self.backup_schedule["next_backup"] if self.backup_schedule["enabled"] else None
            }

            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "health_response",
                    "payload": health_status,
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
        else:
            # 完整系统健康检查
            result = self.verify_system_health()

            # 返回响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "health_response",
                    "payload": result,
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)

    def _start_backup_scheduler(self) -> None:
        """启动定时备份调度线程"""
        def scheduler_loop():
            while self.running and self.backup_schedule["enabled"]:
                current_time = time.time()

                # 检查是否到达下一次备份时间
                if current_time >= self.backup_schedule["next_backup"]:
                    logging.info("执行定时备份...")
                    try:
                        self._perform_backup()
                        self.backup_schedule["last_backup"] = current_time
                        self.backup_schedule["next_backup"] = current_time + self.backup_schedule["interval"]
                        self._save_module_state()
                    except Exception as e:
                        logging.error(f"定时备份失败: {str(e)}")
                        # 尽管失败，仍设置下一次备份时间
                        self.backup_schedule["next_backup"] = current_time + self.backup_schedule["interval"]

                # 等待一段时间再检查
                time.sleep(min(60, self.backup_schedule["interval"] / 10))  # 最多等待60秒

        self.scheduler_thread = threading.Thread(target=scheduler_loop, daemon=True)
        self.scheduler_thread.start()
        logging.info("备份调度线程已启动")

    def _cleanup_old_backups(self) -> None:
        """清理旧备份，保持备份数量在配置范围内"""
        backups = self.list_backups()

        # 如果备份数量超过限制，删除最旧的
        retain_count = self.backup_schedule["retain_count"]
        if len(backups) > retain_count:
            # 按创建时间排序，删除最旧的备份
            backups_to_delete = backups[retain_count:]

            for backup in backups_to_delete:
                backup_id = backup["backup_id"]
                backup_file = os.path.join(self.backup_directory, f"{backup_id}.backup")

                try:
                    if os.path.exists(backup_file):
                        os.remove(backup_file)
                        logging.info(f"已删除旧备份: {backup_id}")
                except Exception as e:
                    logging.error(f"删除旧备份{backup_id}失败: {str(e)}")

    def _save_module_state(self) -> None:
        """保存模块状态到持久化存储"""
        state_file = os.path.join("data", "repair_backup_state.json")

        try:
            # 确保目录存在
            os.makedirs(os.path.dirname(state_file), exist_ok=True)

            state = {
                "backup_schedule": self.backup_schedule,
                "timestamp": datetime.now().isoformat()
            }

            with open(state_file, 'w') as f:
                json.dump(state, f, indent=2)

            logging.debug("模块状态已保存")
        except Exception as e:
            logging.error(f"保存模块状态失败: {str(e)}")

    def _restore_module_state(self) -> None:
        """从持久化存储恢复模块状态"""
        state_file = os.path.join("data", "repair_backup_state.json")

        if not os.path.exists(state_file):
            logging.info("没有找到状态文件，使用默认配置")
            return

        try:
            with open(state_file, 'r') as f:
                state = json.load(f)

            if "backup_schedule" in state:
                self.backup_schedule = state["backup_schedule"]
                logging.info("已恢复模块状态")
        except Exception as e:
            logging.error(f"恢复模块状态失败: {str(e)}")

"""
知识库模块：负责知识存储、检索和学习记录管理

此模块提供系统的知识管理功能，包括知识数据的存储、索引、查询和更新，
以及系统学习过程中的记录管理和跨会话知识保持。
"""

import os
import json
import uuid
import time
import logging
import shutil
import threading
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple

# 假设这些导入已经在系统中定义
from utils.config import Config
from core.message_bus import MessageBus, Message
from core.error_handler import ErrorHandler

# =================================================================================
# 2. 知识库模块(KnowledgeCore) - 负责知识存储、检索和学习记录管理
# =================================================================================

class KnowledgeCore:
    """知识库与学习窗口：负责知识存储、检索和学习记录

    此类提供系统的知识管理功能，包括知识的存储、索引、查询和更新，
    以及学习记录的管理和跨会话知识保持。

    Attributes:
        config (Config): 系统配置对象
        message_bus (MessageBus): 消息总线，用于模块间通信
        error_handler (ErrorHandler): 错误处理器
        knowledge_directory (str): 知识库存储目录
        learning_directory (str): 学习记录存储目录
        index_directory (str): 索引存储目录
        running (bool): 模块运行状态标志
        module_id (str): 模块唯一标识符
        knowledge_index (Dict): 知识索引，用于快速检索
        learning_stats (Dict): 学习统计信息
    """

    def __init__(self, config: Optional[Config] = None,
                 message_bus: Optional[MessageBus] = None,
                 error_handler: Optional[ErrorHandler] = None):
        """初始化知识库模块

        Args:
            config: 系统配置对象，若为None则使用默认配置
            message_bus: 消息总线对象，用于模块间通信
            error_handler: 错误处理器对象
        """
        self.config = config if config else Config()
        self.message_bus = message_bus
        self.error_handler = error_handler
        self.module_id = "knowledge_core"
        self.running = False

        # 存储目录设置
        self.knowledge_directory = os.path.join("data", "knowledge_base", "items")
        self.learning_directory = os.path.join("data", "knowledge_base", "learning")
        self.index_directory = os.path.join("data", "knowledge_base", "index")

        # 创建必要的目录
        for directory in [self.knowledge_directory, self.learning_directory, self.index_directory]:
            os.makedirs(directory, exist_ok=True)

        # 知识索引
        self.knowledge_index = {}

        # 学习统计
        self.learning_stats = {
            "total_entries": 0,
            "total_queries": 0,
            "last_update": None,
            "categories": {},
            "interactions": []
        }

        # 索引锁，防止并发写入
        self._index_lock = threading.RLock()

        self._register_module()

        logging.info(f"KnowledgeCore模块初始化完成")

    def _register_module(self) -> None:
        """向系统注册模块，并订阅相关消息"""
        if self.message_bus:
            # 注册消息处理器
            self.message_bus.register_handler(
                source="*",
                message_type="knowledge_query",
                handler=self._handle_query
            )
            self.message_bus.register_handler(
                source="*",
                message_type="knowledge_add",
                handler=self._handle_add
            )
            self.message_bus.register_handler(
                source="*",
                message_type="knowledge_update",
                handler=self._handle_update
            )
            self.message_bus.register_handler(
                source="*",
                message_type="knowledge_delete",
                handler=self._handle_delete
            )
            self.message_bus.register_handler(
                source="*",
                message_type="learning_record",
                handler=self._handle_learning
            )

            # 向ModuleRegistry注册
            registry_message = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": "module_registry",
                "priority": "high",
                "type": "register_module",
                "payload": {
                    "module_id": self.module_id,
                    "module_type": "support_service",
                    "capabilities": ["knowledge_management", "learning_records"],
                    "status": "initialized"
                },
                "metadata": {}
            }
            self.message_bus.send_message(registry_message)
            logging.info(f"KnowledgeCore模块已注册到系统")

    def start(self) -> bool:
        """启动知识库模块

        加载知识索引和学习记录，初始化必要资源

        Returns:
            bool: 启动是否成功
        """
        try:
            self.running = True

            # 加载知识索引
            self._load_knowledge_index()

            # 加载学习统计
            self._load_learning_stats()

            # 向总控发送启动成功消息
            if self.message_bus:
                status_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "module_status",
                    "payload": {
                        "module_id": self.module_id,
                        "status": "running",
                        "knowledge_count": len(self.knowledge_index),
                        "resources": self._get_resource_usage()
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(status_message)

            logging.info(f"KnowledgeCore模块已启动，已加载{len(self.knowledge_index)}条知识记录")
            return True
        except Exception as e:
            self.running = False
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="startup_error",
                    error_message=str(e)
                )
            logging.error(f"KnowledgeCore模块启动失败: {str(e)}")
            return False

    def stop(self) -> bool:
        """停止知识库模块

        保存索引和统计数据，释放资源

        Returns:
            bool: 停止是否成功
        """
        try:
            # 保存知识索引
            self._save_knowledge_index()

            # 保存学习统计
            self._save_learning_stats()

            self.running = False

            # 向总控发送停止消息
            if self.message_bus:
                status_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "module_status",
                    "payload": {
                        "module_id": self.module_id,
                        "status": "stopped"
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(status_message)

            logging.info(f"KnowledgeCore模块已停止")
            return True
        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="shutdown_error",
                    error_message=str(e)
                )
            logging.error(f"KnowledgeCore模块停止失败: {str(e)}")
            return False

def query_knowledge(self, query: str, max_results: int = 5) -> List[Dict]:
        """查询知识库

        Args:
            query: 查询字符串
            max_results: 最大返回结果数

        Returns:
            List[Dict]: 匹配的知识项列表
        """
        try:
            if not self.running:
                logging.warning("模块未启动，无法执行查询")
                return []

            # 更新查询统计
            self.learning_stats["total_queries"] += 1

            # 执行搜索
            results = self._search_index(query)

            # 限制最大返回数量
            results = results[:max_results]

            # 获取完整知识项
            knowledge_items = []
            for knowledge_id in results:
                try:
                    item = self._retrieve_knowledge(knowledge_id)
                    if item:
                        knowledge_items.append(item)
                except Exception as e:
                    logging.error(f"检索知识项{knowledge_id}失败: {str(e)}")

            # 记录查询
            self._log_query(query, len(results))

            return knowledge_items
        except Exception as e:
            error_msg = f"查询知识库失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="query_error",
                    error_message=error_msg
                )
            return []

    def add_knowledge(self, content: str, metadata: Dict = None) -> Dict:
        """添加新知识到知识库

        Args:
            content: 知识内容
            metadata: 知识元数据，如分类、来源等

        Returns:
            Dict: 添加的知识项信息
        """
        try:
            if not self.running:
                error_msg = "模块未启动，无法添加知识"
                logging.warning(error_msg)
                return {"success": False, "error": error_msg}

            if not metadata:
                metadata = {}

            # 生成唯一ID
            knowledge_id = str(uuid.uuid4())

            # 创建知识项
            timestamp = datetime.now().isoformat()
            knowledge_item = {
                "knowledge_id": knowledge_id,
                "content": content,
                "metadata": metadata,
                "created_at": timestamp,
                "updated_at": timestamp,
                "access_count": 0
            }

            # 存储知识项
            self._store_knowledge(knowledge_item)

            # 更新索引
            with self._index_lock:
                self.knowledge_index[knowledge_id] = self._index_knowledge(content, metadata)
                self._save_knowledge_index()

            # 更新统计信息
            self.learning_stats["total_entries"] += 1
            self.learning_stats["last_update"] = timestamp

            # 如果存在分类，更新分类统计
            category = metadata.get("category", "未分类")
            if category in self.learning_stats["categories"]:
                self.learning_stats["categories"][category] += 1
            else:
                self.learning_stats["categories"][category] = 1

            self._save_learning_stats()

            # 通知添加成功
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "knowledge_added",
                    "payload": {
                        "knowledge_id": knowledge_id,
                        "metadata": metadata
                    },
                    "metadata": {"timestamp": timestamp}
                }
                self.message_bus.send_message(notify_message)

            logging.info(f"已添加新知识项: {knowledge_id}")
            return {
                "success": True,
                "knowledge_id": knowledge_id,
                "created_at": timestamp
            }
        except Exception as e:
            error_msg = f"添加知识失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="add_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

    def update_knowledge(self, knowledge_id: str, content: str, metadata: Dict = None) -> Dict:
        """更新已有知识项

        Args:
            knowledge_id: 知识项ID
            content: 更新后的内容
            metadata: 更新后的元数据

        Returns:
            Dict: 更新结果
        """
        try:
            if not self.running:
                error_msg = "模块未启动，无法更新知识"
                logging.warning(error_msg)
                return {"success": False, "error": error_msg}

            # 检查知识项是否存在
            existing_item = self._retrieve_knowledge(knowledge_id)
            if not existing_item:
                error_msg = f"知识项{knowledge_id}不存在"
                logging.warning(error_msg)
                return {"success": False, "error": error_msg}

            # 更新内容和元数据
            timestamp = datetime.now().isoformat()
            updated_item = existing_item.copy()
            updated_item["content"] = content
            updated_item["updated_at"] = timestamp

            if metadata:
                # 如果提供了新元数据，则更新
                updated_item["metadata"].update(metadata)

            # 保存更新后的知识项
            self._store_knowledge(updated_item)

            # 更新索引
            with self._index_lock:
                self.knowledge_index[knowledge_id] = self._index_knowledge(content, updated_item["metadata"])
                self._save_knowledge_index()

            # 更新学习统计中的分类信息（如果分类改变）
            if metadata and "category" in metadata:
                old_category = existing_item["metadata"].get("category", "未分类")
                new_category = metadata["category"]

                if old_category != new_category:
                    # 减少旧分类计数
                    if old_category in self.learning_stats["categories"]:
                        self.learning_stats["categories"][old_category] -= 1

                    # 增加新分类计数
                    if new_category in self.learning_stats["categories"]:
                        self.learning_stats["categories"][new_category] += 1
                    else:
                        self.learning_stats["categories"][new_category] = 1

                self.learning_stats["last_update"] = timestamp
                self._save_learning_stats()

            # 通知更新成功
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "knowledge_updated",
                    "payload": {
                        "knowledge_id": knowledge_id,
                        "metadata": updated_item["metadata"]
                    },
                    "metadata": {"timestamp": timestamp}
                }
                self.message_bus.send_message(notify_message)

            logging.info(f"已更新知识项: {knowledge_id}")
            return {
                "success": True,
                "knowledge_id": knowledge_id,
                "updated_at": timestamp
            }
        except Exception as e:
            error_msg = f"更新知识项{knowledge_id}失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="update_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

def delete_knowledge(self, knowledge_id: str) -> bool:
        """从知识库中删除知识项

        Args:
            knowledge_id: 要删除的知识项ID

        Returns:
            bool: 删除是否成功
        """
        try:
            if not self.running:
                logging.warning("模块未启动，无法删除知识")
                return False

            # 检查知识项是否存在
            existing_item = self._retrieve_knowledge(knowledge_id)
            if not existing_item:
                logging.warning(f"知识项{knowledge_id}不存在，无法删除")
                return False

            # 获取分类信息，用于更新统计
            category = existing_item["metadata"].get("category", "未分类")

            # 删除知识文件
            knowledge_file = os.path.join(self.knowledge_directory, f"{knowledge_id}.json")
            if os.path.exists(knowledge_file):
                os.remove(knowledge_file)

            # 更新索引
            with self._index_lock:
                if knowledge_id in self.knowledge_index:
                    del self.knowledge_index[knowledge_id]
                    self._save_knowledge_index()

            # 更新统计信息
            self.learning_stats["total_entries"] -= 1
            self.learning_stats["last_update"] = datetime.now().isoformat()

            # 更新分类统计
            if category in self.learning_stats["categories"]:
                self.learning_stats["categories"][category] -= 1
                # 如果分类为空，删除分类
                if self.learning_stats["categories"][category] <= 0:
                    del self.learning_stats["categories"][category]

            self._save_learning_stats()

            # 通知删除成功
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "knowledge_deleted",
                    "payload": {
                        "knowledge_id": knowledge_id
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)

            logging.info(f"已删除知识项: {knowledge_id}")
            return True
        except Exception as e:
            error_msg = f"删除知识项{knowledge_id}失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="delete_error",
                    error_message=error_msg
                )
            return False

    def search_knowledge(self, query: str, filters: Dict = None) -> List[Dict]:
        """搜索知识库

        Args:
            query: 搜索关键词
            filters: 过滤条件，如分类、时间范围等

        Returns:
            List[Dict]: 符合条件的知识项列表
        """
        try:
            if not self.running:
                logging.warning("模块未启动，无法执行搜索")
                return []

            # 执行搜索
            knowledge_ids = self._search_index(query, filters)

            # 获取完整知识项
            results = []
            for knowledge_id in knowledge_ids:
                item = self._retrieve_knowledge(knowledge_id)
                if item:
                    # 更新访问计数
                    item["access_count"] += 1
                    self._store_knowledge(item)
                    results.append(item)

            # 记录查询
            self._log_query(query, len(results))

            logging.info(f"搜索知识库: 查询[{query}], 找到{len(results)}条结果")
            return results
        except Exception as e:
            error_msg = f"搜索知识库失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="search_error",
                    error_message=error_msg
                )
            return []

    def learn_from_interaction(self, interaction: Dict) -> Dict:
        """从交互中学习，记录有价值的信息

        Args:
            interaction: 交互信息，包含问题、回答和反馈等

        Returns:
            Dict: 学习结果
        """
        try:
            if not self.running:
                error_msg = "模块未启动，无法学习交互"
                logging.warning(error_msg)
                return {"success": False, "error": error_msg}

            # 处理学习记录
            learning_result = self._process_learning(interaction)

            # 如果交互被评为有价值，可能需要添加到知识库
            if learning_result.get("valuable", False):
                # 提取内容
                content = learning_result.get("content", "")
                metadata = {
                    "source": "interaction",
                    "category": learning_result.get("category", "交互学习"),
                    "confidence": learning_result.get("confidence", 0.5),
                    "interaction_id": learning_result.get("interaction_id")
                }

                # 添加到知识库
                if content and learning_result.get("add_to_knowledge", False):
                    self.add_knowledge(content, metadata)

            # 更新学习统计
            timestamp = datetime.now().isoformat()
            self.learning_stats["interactions"].append({
                "interaction_id": learning_result.get("interaction_id"),
                "timestamp": timestamp,
                "valuable": learning_result.get("valuable", False),
                "category": learning_result.get("category", "交互学习")
            })

            # 仅保留最近的100条交互记录
            if len(self.learning_stats["interactions"]) > 100:
                self.learning_stats["interactions"] = self.learning_stats["interactions"][-100:]

            self._save_learning_stats()

            # 通知学习完成
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "learning_completed",
                    "payload": {
                        "interaction_id": learning_result.get("interaction_id"),
                        "valuable": learning_result.get("valuable", False)
                    },
                    "metadata": {"timestamp": timestamp}
                }
                self.message_bus.send_message(notify_message)

            logging.info(f"已从交互学习: {learning_result.get('interaction_id')}")
            return {
                "success": True,
                "learning_id": learning_result.get("learning_id"),
                "valuable": learning_result.get("valuable", False),
                "added_to_knowledge": learning_result.get("add_to_knowledge", False)
            }
        except Exception as e:
            error_msg = f"从交互学习失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="learning_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

    def get_learning_stats(self) -> Dict:
        """获取学习统计信息

        Returns:
            Dict: 学习统计信息
        """
        try:
            if not self.running:
                logging.warning("模块未启动，返回缓存的统计信息")

            # 补充实时统计信息
            stats = self.learning_stats.copy()
            stats["knowledge_count"] = len(self.knowledge_index)
            stats["timestamp"] = datetime.now().isoformat()

            return stats
        except Exception as e:
            error_msg = f"获取学习统计失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="stats_error",
                    error_message=error_msg
                )
            return {"error": error_msg}

def _index_knowledge(self, content: str, metadata: Dict) -> Dict:
        """为知识内容创建索引记录

        Args:
            content: 知识内容
            metadata: 知识元数据

        Returns:
            Dict: 索引记录，包含关键词、向量等
        """
        # 简单的索引实现，生产环境可能需要更复杂的向量索引
        try:
            # 提取关键词 (简化实现)
            keywords = []
            words = content.lower().split()

            # 常见停用词
            stop_words = {"的", "了", "和", "是", "在", "有", "与", "这", "那", "如何", "为什么", "什么", "如果", "或者", "可以"}

            # 添加所有非停用词作为关键词，并计算频率
            word_freq = {}
            for word in words:
                if word and word not in stop_words and len(word) > 1:
                    if word in word_freq:
                        word_freq[word] += 1
                    else:
                        word_freq[word] = 1

            # 选择频率最高的最多30个词作为关键词
            sorted_words = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)
            keywords = [word for word, freq in sorted_words[:30]]

            # 从元数据中添加额外关键词
            for key, value in metadata.items():
                if isinstance(value, str):
                    for word in value.lower().split():
                        if word and word not in stop_words and len(word) > 1 and word not in keywords:
                            keywords.append(word)

            # 创建索引记录
            index_record = {
                "keywords": keywords,
                "categories": metadata.get("category", ["未分类"]) if isinstance(metadata.get("category"), list) else [metadata.get("category", "未分类")],
                "created_at": metadata.get("created_at", datetime.now().isoformat()),
                "confidence": metadata.get("confidence", 1.0)
            }

            return index_record
        except Exception as e:
            logging.error(f"创建索引记录失败: {str(e)}")
            # 返回基本索引记录
            return {
                "keywords": [],
                "categories": [metadata.get("category", "未分类")],
                "created_at": metadata.get("created_at", datetime.now().isoformat()),
                "confidence": metadata.get("confidence", 1.0)
            }

    def _store_knowledge(self, knowledge_item: Dict) -> str:
        """存储知识项到文件系统

        Args:
            knowledge_item: 知识项

        Returns:
            str: 知识项ID
        """
        knowledge_id = knowledge_item["knowledge_id"]
        knowledge_file = os.path.join(self.knowledge_directory, f"{knowledge_id}.json")

        try:
            with open(knowledge_file, 'w', encoding='utf-8') as f:
                json.dump(knowledge_item, f, ensure_ascii=False, indent=2)
            return knowledge_id
        except Exception as e:
            error_msg = f"存储知识项失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="storage_error",
                    error_message=error_msg
                )
            raise

    def _retrieve_knowledge(self, knowledge_id: str) -> Dict:
        """从文件系统检索知识项

        Args:
            knowledge_id: 知识项ID

        Returns:
            Dict: 知识项内容
        """
        knowledge_file = os.path.join(self.knowledge_directory, f"{knowledge_id}.json")

        if not os.path.exists(knowledge_file):
            return None

        try:
            with open(knowledge_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            error_msg = f"检索知识项{knowledge_id}失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="retrieval_error",
                    error_message=error_msg
                )
            return None

    def _search_index(self, query: str, filters: Dict = None) -> List[str]:
        """根据查询和过滤条件搜索知识索引

        Args:
            query: 查询字符串
            filters: 过滤条件

        Returns:
            List[str]: 匹配的知识项ID列表
        """
        try:
            with self._index_lock:
                results = []

                # 将查询分词
                query_words = query.lower().split()

                # 计算每个知识项的匹配得分
                scores = {}
                for knowledge_id, index_record in self.knowledge_index.items():
                    score = 0
                    keywords = index_record.get("keywords", [])

                    # 简单的词匹配评分
                    for word in query_words:
                        if word in keywords:
                            score += 1

                    # 应用信心系数
                    confidence = index_record.get("confidence", 1.0)
                    score *= confidence

                    # 应用过滤条件
                    if filters:
                        if "category" in filters and filters["category"] not in index_record.get("categories", []):
                            continue

                        if "min_date" in filters:
                            if index_record.get("created_at", "") < filters["min_date"]:
                                continue

                        if "max_date" in filters:
                            if index_record.get("created_at", "") > filters["max_date"]:
                                continue

                    if score > 0:
                        scores[knowledge_id] = score

                # 按得分排序
                sorted_results = sorted(scores.items(), key=lambda x: x[1], reverse=True)
                results = [knowledge_id for knowledge_id, score in sorted_results]

                return results
        except Exception as e:
            error_msg = f"搜索索引失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="search_index_error",
                    error_message=error_msg
                )
            return []

    def _process_learning(self, interaction: Dict) -> Dict:
        """处理交互学习记录

        Args:
            interaction: 交互信息

        Returns:
            Dict: 处理结果
        """
        # 为学习记录生成ID
        learning_id = str(uuid.uuid4())
        timestamp = datetime.now().isoformat()

        # 提取交互信息
        question = interaction.get("question", "")
        answer = interaction.get("answer", "")
        feedback = interaction.get("feedback", {})

        # 分析是否有价值 (简化实现)
        valuable = feedback.get("valuable", False)
        confidence = feedback.get("confidence", 0.5)

        # 分类交互 (简化实现)
        category = feedback.get("category", "一般交互")

        # 确定是否添加到知识库
        add_to_knowledge = valuable and confidence > 0.7

        # 准备需要存储的内容
        if add_to_knowledge:
            content = f"问题: {question}\n\n回答: {answer}"
        else:
            content = ""

        # 保存学习记录
        learning_record = {
            "learning_id": learning_id,
            "interaction_id": interaction.get("interaction_id", str(uuid.uuid4())),
            "timestamp": timestamp,
            "question": question,
            "answer": answer,
            "feedback": feedback,
            "valuable": valuable,
            "confidence": confidence,
            "category": category,
            "add_to_knowledge": add_to_knowledge
        }

        # 存储学习记录
        learning_file = os.path.join(self.learning_directory, f"{learning_id}.json")
        with open(learning_file, 'w', encoding='utf-8') as f:
            json.dump(learning_record, f, ensure_ascii=False, indent=2)

        # 返回处理结果
        result = {
            "learning_id": learning_id,
            "interaction_id": learning_record["interaction_id"],
            "valuable": valuable,
            "confidence": confidence,
            "category": category,
            "add_to_knowledge": add_to_knowledge,
            "content": content
        }

        return result

def _get_resource_usage(self) -> Dict:
        """获取资源使用情况

        Returns:
            Dict: 资源使用信息
        """
        try:
            # 获取知识库大小
            knowledge_size = 0
            for item in os.listdir(self.knowledge_directory):
                if item.endswith('.json'):
                    knowledge_size += os.path.getsize(os.path.join(self.knowledge_directory, item))

            # 获取学习记录大小
            learning_size = 0
            for item in os.listdir(self.learning_directory):
                if item.endswith('.json'):
                    learning_size += os.path.getsize(os.path.join(self.learning_directory, item))

            # 获取索引大小
            index_size = 0
            for item in os.listdir(self.index_directory):
                if item.endswith('.json'):
                    index_size += os.path.getsize(os.path.join(self.index_directory, item))

            # 返回资源使用情况
            return {
                "knowledge_count": len(self.knowledge_index),
                "knowledge_size_kb": round(knowledge_size / 1024, 2),
                "learning_records": len(os.listdir(self.learning_directory)),
                "learning_size_kb": round(learning_size / 1024, 2),
                "index_size_kb": round(index_size / 1024, 2),
                "total_size_kb": round((knowledge_size + learning_size + index_size) / 1024, 2),
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logging.warning(f"获取资源使用信息失败: {str(e)}")
            return {
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }

    def _log_query(self, query: str, results_count: int) -> None:
        """记录查询日志

        Args:
            query: 查询字符串
            results_count: 结果数量
        """
        try:
            timestamp = datetime.now().isoformat()
            log_id = str(uuid.uuid4())

            # 创建查询日志
            query_log = {
                "log_id": log_id,
                "query": query,
                "results_count": results_count,
                "timestamp": timestamp
            }

            # 存储查询日志
            log_file = os.path.join(self.learning_directory, f"query_{log_id}.json")
            with open(log_file, 'w', encoding='utf-8') as f:
                json.dump(query_log, f, ensure_ascii=False, indent=2)

            # 清理旧日志（保留最近1000条）
            self._cleanup_old_logs()
        except Exception as e:
            logging.warning(f"记录查询日志失败: {str(e)}")

    def _cleanup_old_logs(self) -> None:
        """清理旧的查询日志，只保留最近的1000条"""
        try:
            log_files = []
            for item in os.listdir(self.learning_directory):
                if item.startswith('query_') and item.endswith('.json'):
                    file_path = os.path.join(self.learning_directory, item)
                    log_files.append((file_path, os.path.getmtime(file_path)))

            # 按修改时间排序
            log_files.sort(key=lambda x: x[1], reverse=True)

            # 删除超过1000条的旧日志
            if len(log_files) > 1000:
                for file_path, _ in log_files[1000:]:
                    os.remove(file_path)
        except Exception as e:
            logging.warning(f"清理旧日志失败: {str(e)}")

    def _load_knowledge_index(self) -> None:
        """加载知识索引"""
        index_file = os.path.join(self.index_directory, "knowledge_index.json")

        if os.path.exists(index_file):
            try:
                with open(index_file, 'r', encoding='utf-8') as f:
                    self.knowledge_index = json.load(f)
                logging.info(f"已加载知识索引，包含{len(self.knowledge_index)}条记录")
            except Exception as e:
                logging.error(f"加载知识索引失败: {str(e)}")
                # 如果加载失败，重建索引
                self._rebuild_index()
        else:
            logging.info("未找到知识索引，将重建")
            self._rebuild_index()

    def _save_knowledge_index(self) -> None:
        """保存知识索引到文件"""
        index_file = os.path.join(self.index_directory, "knowledge_index.json")

        try:
            # 创建临时文件
            temp_file = f"{index_file}.tmp"
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(self.knowledge_index, f, ensure_ascii=False, indent=2)

            # 原子替换
            if os.path.exists(index_file):
                os.replace(temp_file, index_file)
            else:
                os.rename(temp_file, index_file)

            logging.debug(f"已保存知识索引，包含{len(self.knowledge_index)}条记录")
        except Exception as e:
            logging.error(f"保存知识索引失败: {str(e)}")
            if os.path.exists(f"{index_file}.tmp"):
                os.remove(f"{index_file}.tmp")

    def _rebuild_index(self) -> None:
        """重建知识索引"""
        logging.info("开始重建知识索引...")

        try:
            # 清空当前索引
            self.knowledge_index = {}

            # 遍历所有知识项
            for item in os.listdir(self.knowledge_directory):
                if item.endswith('.json'):
                    try:
                        knowledge_file = os.path.join(self.knowledge_directory, item)
                        with open(knowledge_file, 'r', encoding='utf-8') as f:
                            knowledge_item = json.load(f)

                        # 提取ID和内容
                        knowledge_id = knowledge_item.get("knowledge_id")
                        content = knowledge_item.get("content", "")
                        metadata = knowledge_item.get("metadata", {})

                        if knowledge_id and content:
                            # 创建索引记录
                            self.knowledge_index[knowledge_id] = self._index_knowledge(content, metadata)
                    except Exception as e:
                        logging.error(f"索引知识项{item}失败: {str(e)}")

            # 保存重建的索引
            self._save_knowledge_index()
            logging.info(f"知识索引重建完成，包含{len(self.knowledge_index)}条记录")
        except Exception as e:
            logging.error(f"重建知识索引失败: {str(e)}")
            if self.error_handler:
                self.error_handler.handle_error(
                    module="knowledge_core",
                    error_type="rebuild_index_error",
                    error_message=str(e)
                )

    def _load_learning_stats(self) -> None:
        """加载学习统计信息"""
        stats_file = os.path.join(self.index_directory, "learning_stats.json")

        if os.path.exists(stats_file):
            try:
                with open(stats_file, 'r', encoding='utf-8') as f:
                    self.learning_stats = json.load(f)
                logging.info("已加载学习统计信息")
            except Exception as e:
                logging.error(f"加载学习统计信息失败: {str(e)}")
                # 保持默认统计信息
        else:
            logging.info("未找到学习统计信息，使用默认值")
            # 计算当前统计
            self.learning_stats["total_entries"] = len(self.knowledge_index)

    def _save_learning_stats(self) -> None:
        """保存学习统计信息到文件"""
        stats_file = os.path.join(self.index_directory, "learning_stats.json")

        try:
            # 创建临时文件
            temp_file = f"{stats_file}.tmp"
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(self.learning_stats, f, ensure_ascii=False, indent=2)

            # 原子替换
            if os.path.exists(stats_file):
                os.replace(temp_file, stats_file)
            else:
                os.rename(temp_file, stats_file)

            logging.debug("已保存学习统计信息")
        except Exception as e:
            logging.error(f"保存学习统计信息失败: {str(e)}")
            if os.path.exists(f"{stats_file}.tmp"):
                os.remove(f"{stats_file}.tmp")

def _handle_message(self, message: Message) -> None:
        """处理接收到的消息

        Args:
            message: 消息对象
        """
        message_type = message.get("type", "")

        # 根据消息类型调用不同的处理方法
        handlers = {
            "knowledge_query": self._handle_query,
            "knowledge_add": self._handle_add,
            "knowledge_update": self._handle_update,
            "knowledge_delete": self._handle_delete,
            "learning_record": self._handle_learning
        }

        if message_type in handlers:
            handlers[message_type](message)
        else:
            logging.warning(f"收到未知类型消息: {message_type}")

    def _handle_query(self, message: Message) -> None:
        """处理知识查询消息

        Args:
            message: 查询消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        query = payload.get("query", "")
        max_results = payload.get("max_results", 5)
        filters = payload.get("filters", None)

        # 执行查询
        if filters:
            results = self.search_knowledge(query, filters)
        else:
            results = self.query_knowledge(query, max_results)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "knowledge_response",
                "payload": {
                    "query": query,
                    "results": results,
                    "count": len(results)
                },
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_add(self, message: Message) -> None:
        """处理添加知识消息

        Args:
            message: 添加知识消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        content = payload.get("content", "")
        metadata = payload.get("metadata", {})

        if not content:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "knowledge_add_response",
                    "payload": {
                        "success": False,
                        "error": "内容为空"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行添加
        result = self.add_knowledge(content, metadata)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "knowledge_add_response",
                "payload": result,
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_update(self, message: Message) -> None:
        """处理更新知识消息

        Args:
            message: 更新知识消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        knowledge_id = payload.get("knowledge_id", "")
        content = payload.get("content", "")
        metadata = payload.get("metadata", None)

        if not knowledge_id or not content:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "knowledge_update_response",
                    "payload": {
                        "success": False,
                        "error": "知识ID或内容为空"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行更新
        result = self.update_knowledge(knowledge_id, content, metadata)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "knowledge_update_response",
                "payload": result,
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_delete(self, message: Message) -> None:
        """处理删除知识消息

        Args:
            message: 删除知识消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        knowledge_id = payload.get("knowledge_id", "")

        if not knowledge_id:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "knowledge_delete_response",
                    "payload": {
                        "success": False,
                        "error": "知识ID为空"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行删除
        result = self.delete_knowledge(knowledge_id)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "knowledge_delete_response",
                "payload": {
                    "success": result,
                    "knowledge_id": knowledge_id
                },
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_learning(self, message: Message) -> None:
        """处理学习记录消息

        Args:
            message: 学习记录消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        interaction = payload.get("interaction", {})

        if not interaction:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "learning_response",
                    "payload": {
                        "success": False,
                        "error": "交互数据为空"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行学习
        result = self.learn_from_interaction(interaction)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "learning_response",
                "payload": result,
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

"""
本地训练模块：负责模型训练和微调功能

此模块提供模型训练和微调功能，包括训练数据的管理、训练任务的调度、
模型性能评估以及模型版本管理。
"""

import os
import json
import uuid
import time
import shutil
import logging
import threading
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple

# 假设这些导入已经在系统中定义
from utils.config import Config
from core.message_bus import MessageBus, Message
from core.error_handler import ErrorHandler

# =================================================================================
# 3. 本地训练模块(TrainLocal) - 负责模型训练和微调
# =================================================================================

class TrainLocal:
    """本地模型训练窗口：负责模型训练和微调

    此类提供了模型训练和微调的功能，包括训练数据的管理、训练任务的调度、
    模型性能评估以及模型版本管理。

    Attributes:
        config (Config): 系统配置对象
        message_bus (MessageBus): 消息总线，用于模块间通信
        error_handler (ErrorHandler): 错误处理器
        models_directory (str): 模型存储目录
        datasets_directory (str): 数据集存储目录
        training_jobs_directory (str): 训练任务存储目录
        running (bool): 模块运行状态标志
        module_id (str): 模块唯一标识符
        active_jobs (Dict): 当前活跃的训练任务
        job_threads (Dict): 训练任务线程
        resource_limits (Dict): 资源限制配置
    """

    def __init__(self, config: Optional[Config] = None,
                 message_bus: Optional[MessageBus] = None,
                 error_handler: Optional[ErrorHandler] = None):
        """初始化本地训练模块

        Args:
            config: 系统配置对象，若为None则使用默认配置
            message_bus: 消息总线对象，用于模块间通信
            error_handler: 错误处理器对象
        """
        self.config = config if config else Config()
        self.message_bus = message_bus
        self.error_handler = error_handler
        self.module_id = "train_local"
        self.running = False

        # 存储目录设置
        self.models_directory = os.path.join("data", "models")
        self.datasets_directory = os.path.join("data", "datasets")
        self.training_jobs_directory = os.path.join("data", "training_jobs")

        # 创建必要的目录
        for directory in [self.models_directory, self.datasets_directory, self.training_jobs_directory]:
            os.makedirs(directory, exist_ok=True)

        # 活跃训练任务
        self.active_jobs = {}

        # 训练任务线程
        self.job_threads = {}

        # 资源限制
        self.resource_limits = {
            "max_jobs": 2,       # 最大同时运行任务数
            "max_memory_gb": 8,  # 最大内存使用
            "max_gpu_memory_gb": 4,  # 最大GPU内存使用
            "max_cpu_cores": 4   # 最大CPU核心使用
        }

        # 任务运行锁
        self._job_lock = threading.RLock()

        self._register_module()

        logging.info(f"TrainLocal模块初始化完成")

    def _register_module(self) -> None:
        """向系统注册模块，并订阅相关消息"""
        if self.message_bus:
            # 注册消息处理器
            self.message_bus.register_handler(
                source="*",
                message_type="train_request",
                handler=self._handle_train_request
            )
            self.message_bus.register_handler(
                source="*",
                message_type="finetune_request",
                handler=self._handle_finetune_request
            )
            self.message_bus.register_handler(
                source="*",
                message_type="evaluate_request",
                handler=self._handle_evaluate_request
            )
            self.message_bus.register_handler(
                source="*",
                message_type="model_info_request",
                handler=self._handle_model_info_request
            )

            # 向ModuleRegistry注册
            registry_message = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": "module_registry",
                "priority": "high",
                "type": "register_module",
                "payload": {
                    "module_id": self.module_id,
                    "module_type": "support_service",
                    "capabilities": ["model_training", "model_finetuning", "model_evaluation"],
                    "status": "initialized"
                },
                "metadata": {}
            }
            self.message_bus.send_message(registry_message)
            logging.info(f"TrainLocal模块已注册到系统")

    def start(self) -> bool:
        """启动本地训练模块

        初始化训练环境，恢复未完成的训练任务

        Returns:
            bool: 启动是否成功
        """
        try:
            self.running = True

            # 初始化训练环境
            env_initialized = self._initialize_training_env()
            if not env_initialized:
                logging.warning("训练环境初始化部分失败，但模块仍将继续运行")

            # 恢复未完成的训练任务
            self._restore_training_jobs()

            # 向总控发送启动成功消息
            if self.message_bus:
                status_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "module_status",
                    "payload": {
                        "module_id": self.module_id,
                        "status": "running",
                        "active_jobs": len(self.active_jobs),
                        "resources": self._get_resource_usage()
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(status_message)

            logging.info(f"TrainLocal模块已启动")
            return True
        except Exception as e:
            self.running = False
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="startup_error",
                    error_message=str(e)
                )
            logging.error(f"TrainLocal模块启动失败: {str(e)}")
            return False

def stop(self) -> bool:
        """停止本地训练模块

        停止所有运行中的训练任务，保存训练状态

        Returns:
            bool: 停止是否成功
        """
        try:
            # 标记模块为停止状态
            self.running = False

            # 保存所有活跃任务状态
            for job_id, job_info in self.active_jobs.items():
                job_info["status"] = "paused"
                job_info["paused_at"] = datetime.now().isoformat()
                self._save_job_state(job_id, job_info)

            # 等待所有训练线程结束
            for job_id, thread in self.job_threads.items():
                if thread.is_alive():
                    logging.info(f"等待训练任务 {job_id} 线程结束")
                    thread.join(timeout=30)  # 等待最多30秒

                    if thread.is_alive():
                        logging.warning(f"训练任务 {job_id} 线程未能正常结束")

            # 清空活跃任务和线程
            self.active_jobs.clear()
            self.job_threads.clear()

            # 向总控发送停止消息
            if self.message_bus:
                status_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "module_status",
                    "payload": {
                        "module_id": self.module_id,
                        "status": "stopped"
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(status_message)

            logging.info(f"TrainLocal模块已停止")
            return True
        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="shutdown_error",
                    error_message=str(e)
                )
            logging.error(f"TrainLocal模块停止失败: {str(e)}")
            return False

    def train_model(self, model_id: str, dataset_path: str, parameters: Dict = None) -> Dict:
        """训练新模型

        Args:
            model_id: 模型ID
            dataset_path: 训练数据集路径
            parameters: 训练参数

        Returns:
            Dict: 训练任务信息
        """
        try:
            if not self.running:
                error_msg = "模块未启动，无法执行训练任务"
                logging.warning(error_msg)
                return {"success": False, "error": error_msg}

            # 检查数据集是否存在
            if not os.path.exists(dataset_path):
                error_msg = f"训练数据集不存在: {dataset_path}"
                logging.error(error_msg)
                return {"success": False, "error": error_msg}

            # 检查资源是否足够
            if not self._manage_training_resources(parameters):
                error_msg = "资源不足，无法启动新的训练任务"
                logging.error(error_msg)
                return {"success": False, "error": error_msg}

            # 生成训练任务ID
            job_id = str(uuid.uuid4())

            # 默认参数
            if not parameters:
                parameters = {}

            default_params = {
                "learning_rate": 0.001,
                "batch_size": 32,
                "epochs": 10,
                "optimizer": "adam",
                "model_type": "sequential",
                "early_stopping": True,
                "validation_split": 0.2
            }

            # 合并参数
            for key, value in default_params.items():
                if key not in parameters:
                    parameters[key] = value

            # 创建训练任务信息
            timestamp = datetime.now().isoformat()
            job_info = {
                "job_id": job_id,
                "model_id": model_id,
                "dataset_path": dataset_path,
                "parameters": parameters,
                "status": "preparing",
                "created_at": timestamp,
                "updated_at": timestamp,
                "progress": 0.0,
                "metrics": {},
                "log_file": os.path.join(self.training_jobs_directory, f"{job_id}.log"),
                "result_file": os.path.join(self.training_jobs_directory, f"{job_id}_result.json"),
                "job_type": "training"
            }

            # 保存任务状态
            self._save_job_state(job_id, job_info)

            # 添加到活跃任务
            with self._job_lock:
                self.active_jobs[job_id] = job_info

            # 启动训练线程
            thread = threading.Thread(
                target=self._run_training_job,
                args=(model_id, dataset_path, parameters, job_id),
                daemon=True
            )
            thread.start()
            self.job_threads[job_id] = thread

            # 通知训练任务已创建
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "training_started",
                    "payload": {
                        "job_id": job_id,
                        "model_id": model_id,
                        "status": "preparing"
                    },
                    "metadata": {"timestamp": timestamp}
                }
                self.message_bus.send_message(notify_message)

            logging.info(f"已创建训练任务 {job_id} 用于模型 {model_id}")
            return {
                "success": True,
                "job_id": job_id,
                "model_id": model_id,
                "status": "preparing"
            }
        except Exception as e:
            error_msg = f"创建训练任务失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="training_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

    def finetune_model(self, model_id: str, dataset_path: str, parameters: Dict = None) -> Dict:
        """微调现有模型

        Args:
            model_id: 现有模型ID
            dataset_path: 微调数据集路径
            parameters: 微调参数

        Returns:
            Dict: 微调任务信息
        """
        try:
            if not self.running:
                error_msg = "模块未启动，无法执行微调任务"
                logging.warning(error_msg)
                return {"success": False, "error": error_msg}

            # 检查模型是否存在
            model_info = self.get_model_info(model_id)
            if not model_info or model_info.get("error"):
                error_msg = f"模型不存在: {model_id}"
                logging.error(error_msg)
                return {"success": False, "error": error_msg}

            # 检查数据集是否存在
            if not os.path.exists(dataset_path):
                error_msg = f"微调数据集不存在: {dataset_path}"
                logging.error(error_msg)
                return {"success": False, "error": error_msg}

            # 检查资源是否足够
            if not self._manage_training_resources(parameters):
                error_msg = "资源不足，无法启动新的微调任务"
                logging.error(error_msg)
                return {"success": False, "error": error_msg}

            # 生成微调任务ID
            job_id = str(uuid.uuid4())

            # 默认参数
            if not parameters:
                parameters = {}

            default_params = {
                "learning_rate": 0.0001,  # 通常微调使用较小的学习率
                "batch_size": 16,
                "epochs": 5,
                "optimizer": "adam",
                "early_stopping": True,
                "freeze_layers": "auto",  # 自动确定冻结层
                "validation_split": 0.2
            }

            # 合并参数
            for key, value in default_params.items():
                if key not in parameters:
                    parameters[key] = value

# 创建微调任务信息
            timestamp = datetime.now().isoformat()
            job_info = {
                "job_id": job_id,
                "model_id": model_id,
                "dataset_path": dataset_path,
                "parameters": parameters,
                "status": "preparing",
                "created_at": timestamp,
                "updated_at": timestamp,
                "progress": 0.0,
                "metrics": {},
                "log_file": os.path.join(self.training_jobs_directory, f"{job_id}.log"),
                "result_file": os.path.join(self.training_jobs_directory, f"{job_id}_result.json"),
                "job_type": "finetuning",
                "base_model": model_id
            }

            # 保存任务状态
            self._save_job_state(job_id, job_info)

            # 添加到活跃任务
            with self._job_lock:
                self.active_jobs[job_id] = job_info

            # 启动微调线程
            thread = threading.Thread(
                target=self._run_finetuning_job,
                args=(model_id, dataset_path, parameters, job_id),
                daemon=True
            )
            thread.start()
            self.job_threads[job_id] = thread

            # 通知微调任务已创建
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "finetuning_started",
                    "payload": {
                        "job_id": job_id,
                        "model_id": model_id,
                        "status": "preparing"
                    },
                    "metadata": {"timestamp": timestamp}
                }
                self.message_bus.send_message(notify_message)

            logging.info(f"已创建微调任务 {job_id} 用于模型 {model_id}")
            return {
                "success": True,
                "job_id": job_id,
                "model_id": model_id,
                "status": "preparing"
            }
        except Exception as e:
            error_msg = f"创建微调任务失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="finetuning_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

    def evaluate_model(self, model_id: str, test_data_path: str) -> Dict:
        """评估模型性能

        Args:
            model_id: 模型ID
            test_data_path: 测试数据集路径

        Returns:
            Dict: 评估结果
        """
        try:
            if not self.running:
                error_msg = "模块未启动，无法执行模型评估"
                logging.warning(error_msg)
                return {"success": False, "error": error_msg}

            # 检查模型是否存在
            model_info = self.get_model_info(model_id)
            if not model_info or model_info.get("error"):
                error_msg = f"模型不存在: {model_id}"
                logging.error(error_msg)
                return {"success": False, "error": error_msg}

            # 检查测试数据集是否存在
            if not os.path.exists(test_data_path):
                error_msg = f"测试数据集不存在: {test_data_path}"
                logging.error(error_msg)
                return {"success": False, "error": error_msg}

            # 生成评估任务ID
            eval_id = str(uuid.uuid4())

            # 执行评估
            result = self._run_evaluation(model_id, test_data_path)

            # 保存评估结果
            result["eval_id"] = eval_id
            result["model_id"] = model_id
            result["test_data_path"] = test_data_path
            result["created_at"] = datetime.now().isoformat()

            eval_file = os.path.join(self.training_jobs_directory, f"eval_{eval_id}.json")
            with open(eval_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, ensure_ascii=False, indent=2)

            # 更新模型信息
            model_path = os.path.join(self.models_directory, f"{model_id}.json")
            if os.path.exists(model_path):
                with open(model_path, 'r', encoding='utf-8') as f:
                    model_data = json.load(f)

                # 添加评估结果
                if "evaluations" not in model_data:
                    model_data["evaluations"] = []

                model_data["evaluations"].append({
                    "eval_id": eval_id,
                    "created_at": result["created_at"],
                    "metrics": result["metrics"],
                    "test_data_path": test_data_path
                })

                # 保存更新后的模型信息
                with open(model_path, 'w', encoding='utf-8') as f:
                    json.dump(model_data, f, ensure_ascii=False, indent=2)

            # 通知评估完成
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "evaluation_completed",
                    "payload": {
                        "eval_id": eval_id,
                        "model_id": model_id,
                        "metrics": result["metrics"]
                    },
                    "metadata": {"timestamp": result["created_at"]}
                }
                self.message_bus.send_message(notify_message)

            logging.info(f"已完成模型 {model_id} 的评估")
            return {
                "success": True,
                "eval_id": eval_id,
                "model_id": model_id,
                "metrics": result["metrics"]
            }
        except Exception as e:
            error_msg = f"模型评估失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="evaluation_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

    def list_models(self) -> List[Dict]:
        """列出所有可用模型

        Returns:
            List[Dict]: 模型信息列表
        """
        try:
            models = []

            # 遍历模型目录
            for item in os.listdir(self.models_directory):
                if item.endswith('.json'):
                    model_file = os.path.join(self.models_directory, item)
                    try:
                        with open(model_file, 'r', encoding='utf-8') as f:
                            model_data = json.load(f)

                        # 提取基本信息
                        model_info = {
                            "model_id": model_data.get("model_id", ""),
                            "name": model_data.get("name", ""),
                            "type": model_data.get("type", ""),
                            "created_at": model_data.get("created_at", ""),
                            "updated_at": model_data.get("updated_at", ""),
                            "version": model_data.get("version", "1.0.0"),
                            "has_weights": os.path.exists(os.path.join(self.models_directory, f"{model_data.get('model_id', '')}.weights"))
                        }

                        models.append(model_info)
                    except Exception as e:
                        logging.warning(f"读取模型信息失败 {item}: {str(e)}")

            # 按创建时间排序
            models.sort(key=lambda x: x.get("created_at", ""), reverse=True)

            return models
        except Exception as e:
            error_msg = f"列出模型失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="list_models_error",
                    error_message=error_msg
                )
            return []

def get_model_info(self, model_id: str) -> Dict:
        """获取特定模型的详细信息

        Args:
            model_id: 模型ID

        Returns:
            Dict: 模型详细信息
        """
        try:
            model_file = os.path.join(self.models_directory, f"{model_id}.json")

            if not os.path.exists(model_file):
                error_msg = f"模型不存在: {model_id}"
                logging.warning(error_msg)
                return {"error": error_msg}

            # 读取模型信息
            with open(model_file, 'r', encoding='utf-8') as f:
                model_data = json.load(f)

            # 添加模型权重文件信息
            weights_file = os.path.join(self.models_directory, f"{model_id}.weights")
            model_data["has_weights"] = os.path.exists(weights_file)
            if model_data["has_weights"]:
                model_data["weights_size"] = os.path.getsize(weights_file)

            return model_data
        except Exception as e:
            error_msg = f"获取模型信息失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="get_model_info_error",
                    error_message=error_msg
                )
            return {"error": error_msg}

    def save_model(self, model_id: str, path: str = None) -> Dict:
        """保存模型到指定路径

        Args:
            model_id: 模型ID
            path: 保存路径，如果为None则使用默认路径

        Returns:
            Dict: 保存结果
        """
        try:
            # 获取模型信息
            model_info = self.get_model_info(model_id)
            if "error" in model_info:
                return {"success": False, "error": model_info["error"]}

            # 确定保存路径
            if not path:
                path = os.path.join(self.models_directory, f"export_{model_id}")

            # 创建保存目录
            os.makedirs(path, exist_ok=True)

            # 保存模型信息
            info_file = os.path.join(path, f"{model_id}_info.json")
            with open(info_file, 'w', encoding='utf-8') as f:
                json.dump(model_info, f, ensure_ascii=False, indent=2)

            # 复制模型权重文件
            weights_file = os.path.join(self.models_directory, f"{model_id}.weights")
            if os.path.exists(weights_file):
                shutil.copy2(weights_file, os.path.join(path, f"{model_id}.weights"))

            logging.info(f"已保存模型 {model_id} 到 {path}")
            return {
                "success": True,
                "model_id": model_id,
                "path": path,
                "files": os.listdir(path)
            }
        except Exception as e:
            error_msg = f"保存模型失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="save_model_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

    def load_model(self, path: str) -> Dict:
        """从指定路径加载模型

        Args:
            path: 模型文件路径

        Returns:
            Dict: 加载结果
        """
        try:
            # 检查路径是否存在
            if not os.path.exists(path):
                error_msg = f"模型路径不存在: {path}"
                logging.error(error_msg)
                return {"success": False, "error": error_msg}

            # 如果是目录，查找模型信息文件
            if os.path.isdir(path):
                info_files = [f for f in os.listdir(path) if f.endswith('_info.json')]
                if not info_files:
                    error_msg = f"未找到模型信息文件: {path}"
                    logging.error(error_msg)
                    return {"success": False, "error": error_msg}

                # 使用第一个信息文件
                info_file = os.path.join(path, info_files[0])
                model_id = info_files[0].replace('_info.json', '')

                # 查找权重文件
                weights_file = os.path.join(path, f"{model_id}.weights")
                if not os.path.exists(weights_file):
                    logging.warning(f"未找到模型权重文件: {weights_file}")
            else:
                # 假设是直接的模型文件
                info_file = path
                model_id = os.path.basename(path).replace('.json', '')
                weights_file = os.path.join(os.path.dirname(path), f"{model_id}.weights")

            # 读取模型信息
            with open(info_file, 'r', encoding='utf-8') as f:
                model_data = json.load(f)

            # 生成新的模型ID
            new_model_id = str(uuid.uuid4())
            model_data["model_id"] = new_model_id
            model_data["imported_from"] = model_id
            model_data["imported_at"] = datetime.now().isoformat()

            # 保存到模型目录
            new_info_file = os.path.join(self.models_directory, f"{new_model_id}.json")
            with open(new_info_file, 'w', encoding='utf-8') as f:
                json.dump(model_data, f, ensure_ascii=False, indent=2)

            # 复制权重文件
            if os.path.exists(weights_file):
                new_weights_file = os.path.join(self.models_directory, f"{new_model_id}.weights")
                shutil.copy2(weights_file, new_weights_file)

            logging.info(f"已加载模型 {model_id} 为 {new_model_id}")
            return {
                "success": True,
                "model_id": new_model_id,
                "original_id": model_id,
                "name": model_data.get("name", "")
            }
        except Exception as e:
            error_msg = f"加载模型失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="load_model_error",
                    error_message=error_msg
                )
            return {"success": False, "error": error_msg}

    def prepare_dataset(self, data: List[Dict], format_type: str) -> str:
        """准备训练数据集

        Args:
            data: 要处理的数据
            format_type: 数据格式类型，如'text', 'image', 'json'

        Returns:
            str: 数据集文件路径
        """
        try:
            # 生成数据集ID
            dataset_id = str(uuid.uuid4())
            dataset_path = os.path.join(self.datasets_directory, f"{dataset_id}.{format_type}")

            # 根据不同的格式类型处理数据
            if format_type == "json":
                with open(dataset_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)

            elif format_type == "csv":
                import csv
                with open(dataset_path, 'w', newline='', encoding='utf-8') as f:
                    if data and isinstance(data[0], dict):
                        fieldnames = data[0].keys()
                        writer = csv.DictWriter(f, fieldnames=fieldnames)
                        writer.writeheader()
                        writer.writerows(data)
                    else:
                        writer = csv.writer(f)
                        writer.writerows(data)

            elif format_type == "text":
                with open(dataset_path, 'w', encoding='utf-8') as f:
                    for item in data:
                        if isinstance(item, dict):
                            f.write(json.dumps(item, ensure_ascii=False) + '\n')
                        elif isinstance(item, str):
                            f.write(item + '\n')
                        else:
                            f.write(str(item) + '\n')

            else:
                error_msg = f"不支持的数据格式类型: {format_type}"
                logging.error(error_msg)
                return error_msg

            logging.info(f"已创建{format_type}格式数据集: {dataset_path}")
            return dataset_path
        except Exception as e:
            error_msg = f"准备数据集失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="prepare_dataset_error",
                    error_message=error_msg
                )
            return str(e)

def _initialize_training_env(self) -> bool:
        """初始化训练环境

        确保所需的库和依赖已经加载

        Returns:
            bool: 初始化是否成功
        """
        try:
            logging.info("初始化训练环境...")

            # 检查必要的目录
            for directory in [self.models_directory, self.datasets_directory, self.training_jobs_directory]:
                os.makedirs(directory, exist_ok=True)

            # 尝试导入必要的库(在实际环境中实现)
            # 这里仅做模拟
            required_libs = ["tensorflow", "numpy", "pandas", "scikit-learn"]
            missing_libs = []

            # 模拟检查库可用性
            for lib in required_libs:
                try:
                    # 实际项目中应该尝试导入
                    # __import__(lib)
                    # 这里简化处理
                    pass
                except ImportError:
                    missing_libs.append(lib)

            if missing_libs:
                logging.warning(f"缺少以下库: {', '.join(missing_libs)}")
                return False

            # 检查GPU可用性(在实际环境中实现)
            # 这里仅做模拟
            gpu_available = True  # 模拟GPU可用

            if not gpu_available:
                logging.warning("未检测到可用的GPU，训练性能可能受限")

            # 加载模型配置
            self._load_model_configs()

            logging.info("训练环境初始化完成")
            return True
        except Exception as e:
            error_msg = f"初始化训练环境失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="init_env_error",
                    error_message=error_msg
                )
            return False

    def _run_training_job(self, model_id: str, dataset_path: str, parameters: Dict, job_id: str) -> Dict:
        """执行模型训练任务

        Args:
            model_id: 模型ID
            dataset_path: 数据集路径
            parameters: 训练参数
            job_id: 训练任务ID

        Returns:
            Dict: 训练结果
        """
        try:
            # 更新任务状态
            self._update_job_status(job_id, "loading_data", 0.05)

            # 模拟数据加载时间
            time.sleep(2)

            # 创建模型（在实际环境中实现）
            # 这里仅做模拟
            self._update_job_status(job_id, "building_model", 0.1)
            time.sleep(2)

            # 开始训练
            self._update_job_status(job_id, "training", 0.15)

            epochs = parameters.get("epochs", 10)

            # 模拟训练过程
            for epoch in range(epochs):
                # 模拟每个epoch的训练
                time.sleep(1)

                # 计算进度
                progress = 0.15 + (0.7 * (epoch + 1) / epochs)

                # 模拟训练指标
                loss = 1.0 / (epoch + 1)
                accuracy = 0.5 + 0.4 * (epoch / epochs)

                # 更新任务状态和指标
                metrics = {
                    "epoch": epoch + 1,
                    "loss": loss,
                    "accuracy": accuracy,
                    "val_loss": loss * 1.1,
                    "val_accuracy": accuracy * 0.9
                }

                self._update_job_status(job_id, "training", progress, metrics)

                # 模拟日志记录
                log_file = os.path.join(self.training_jobs_directory, f"{job_id}.log")
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"Epoch {epoch+1}/{epochs}: loss={loss:.4f}, accuracy={accuracy:.4f}\n")

                # 检查模块是否仍在运行
                if not self.running:
                    self._update_job_status(job_id, "interrupted", progress)
                    return {"success": False, "error": "模块已停止"}

            # 完成训练，保存模型
            self._update_job_status(job_id, "saving_model", 0.9)

            # 模拟保存模型
            time.sleep(2)

            # 创建和保存模型信息
            model_info = {
                "model_id": model_id,
                "name": parameters.get("name", f"Model-{model_id[:8]}"),
                "type": parameters.get("model_type", "sequential"),
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat(),
                "version": "1.0.0",
                "parameters": parameters,
                "training_job": job_id,
                "dataset": dataset_path,
                "metrics": {
                    "loss": 0.1,
                    "accuracy": 0.9,
                    "val_loss": 0.11,
                    "val_accuracy": 0.85
                },
                "layer_info": [
                    {"type": "input", "shape": [None, 28, 28, 1]},
                    {"type": "conv2d", "filters": 32, "kernel_size": 3},
                    {"type": "maxpooling2d", "pool_size": 2},
                    {"type": "flatten"},
                    {"type": "dense", "units": 128},
                    {"type": "dense", "units": 10}
                ]
            }

            # 保存模型信息文件
            model_file = os.path.join(self.models_directory, f"{model_id}.json")
            with open(model_file, 'w', encoding='utf-8') as f:
                json.dump(model_info, f, ensure_ascii=False, indent=2)

            # 模拟创建模型权重文件
            weights_file = os.path.join(self.models_directory, f"{model_id}.weights")
            with open(weights_file, 'w', encoding='utf-8') as f:
                f.write("模拟模型权重数据")

            # 完成训练
            self._update_job_status(job_id, "completed", 1.0, model_info["metrics"])

            # 保存训练结果
            result_file = os.path.join(self.training_jobs_directory, f"{job_id}_result.json")
            with open(result_file, 'w', encoding='utf-8') as f:
                json.dump({
                    "job_id": job_id,
                    "model_id": model_id,
                    "status": "completed",
                    "created_at": model_info["created_at"],
                    "completed_at": datetime.now().isoformat(),
                    "parameters": parameters,
                    "metrics": model_info["metrics"]
                }, f, ensure_ascii=False, indent=2)

            # 通知训练完成
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "training_completed",
                    "payload": {
                        "job_id": job_id,
                        "model_id": model_id,
                        "metrics": model_info["metrics"]
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)

            # 从活跃任务中移除
            with self._job_lock:
                if job_id in self.active_jobs:
                    del self.active_jobs[job_id]
                if job_id in self.job_threads:
                    del self.job_threads[job_id]

            logging.info(f"训练任务 {job_id} 完成")
            return {"success": True, "model_id": model_id}
        except Exception as e:
            error_msg = f"执行训练任务失败: {str(e)}"
            logging.error(error_msg)

            # 更新任务状态为失败
            self._update_job_status(job_id, "failed", 0.0, {"error": str(e)})

            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="training_job_error",
                    error_message=error_msg
                )

            # 通知训练失败
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "high",
                    "type": "training_failed",
                    "payload": {
                        "job_id": job_id,
                        "model_id": model_id,
                        "error": str(e)
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)

            # 从活跃任务中移除
            with self._job_lock:
                if job_id in self.active_jobs:
                    del self.active_jobs[job_id]
                if job_id in self.job_threads:
                    del self.job_threads[job_id]

            return {"success": False, "error": str(e)}

def _run_finetuning_job(self, model_id: str, dataset_path: str, parameters: Dict, job_id: str) -> Dict:
        """执行模型微调任务

        Args:
            model_id: 基础模型ID
            dataset_path: 微调数据集路径
            parameters: 微调参数
            job_id: 微调任务ID

        Returns:
            Dict: 微调结果
        """
        try:
            # 加载基础模型信息
            model_file = os.path.join(self.models_directory, f"{model_id}.json")
            with open(model_file, 'r', encoding='utf-8') as f:
                base_model = json.load(f)

            # 更新任务状态
            self._update_job_status(job_id, "loading_model", 0.05)

            # 模拟模型加载时间
            time.sleep(2)

            # 加载数据集
            self._update_job_status(job_id, "loading_data", 0.1)
            time.sleep(1)

            # 开始微调
            self._update_job_status(job_id, "finetuning", 0.15)

            epochs = parameters.get("epochs", 5)

            # 创建新的模型ID（微调后的模型）
            new_model_id = str(uuid.uuid4())

            # 模拟微调过程
            for epoch in range(epochs):
                # 模拟每个epoch的微调
                time.sleep(1)

                # 计算进度
                progress = 0.15 + (0.7 * (epoch + 1) / epochs)

                # 模拟微调指标（通常比训练从头开始有更好的起点）
                loss = 0.3 / (epoch + 1)
                accuracy = 0.8 + 0.15 * (epoch / epochs)

                # 更新任务状态和指标
                metrics = {
                    "epoch": epoch + 1,
                    "loss": loss,
                    "accuracy": accuracy,
                    "val_loss": loss * 1.05,
                    "val_accuracy": accuracy * 0.95
                }

                self._update_job_status(job_id, "finetuning", progress, metrics)

                # 模拟日志记录
                log_file = os.path.join(self.training_jobs_directory, f"{job_id}.log")
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"Epoch {epoch+1}/{epochs}: loss={loss:.4f}, accuracy={accuracy:.4f}\n")

                # 检查模块是否仍在运行
                if not self.running:
                    self._update_job_status(job_id, "interrupted", progress)
                    return {"success": False, "error": "模块已停止"}

            # 完成微调，保存模型
            self._update_job_status(job_id, "saving_model", 0.9)

            # 模拟保存模型
            time.sleep(1)

            # 创建和保存微调后的模型信息
            model_info = {
                "model_id": new_model_id,
                "name": parameters.get("name", f"Finetuned-{model_id[:8]}"),
                "type": base_model.get("type", "sequential"),
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat(),
                "version": f"{base_model.get('version', '1.0.0')}-ft",
                "base_model": model_id,
                "base_model_name": base_model.get("name", ""),
                "parameters": parameters,
                "finetuning_job": job_id,
                "dataset": dataset_path,
                "metrics": {
                    "loss": 0.05,
                    "accuracy": 0.95,
                    "val_loss": 0.06,
                    "val_accuracy": 0.93
                },
                "layer_info": base_model.get("layer_info", [])
            }

            # 保存模型信息文件
            model_file = os.path.join(self.models_directory, f"{new_model_id}.json")
            with open(model_file, 'w', encoding='utf-8') as f:
                json.dump(model_info, f, ensure_ascii=False, indent=2)

            # 模拟创建模型权重文件
            weights_file = os.path.join(self.models_directory, f"{new_model_id}.weights")
            with open(weights_file, 'w', encoding='utf-8') as f:
                f.write("模拟模型权重数据 - 微调版本")

            # 完成微调
            self._update_job_status(job_id, "completed", 1.0, model_info["metrics"])

            # 保存微调结果
            result_file = os.path.join(self.training_jobs_directory, f"{job_id}_result.json")
            with open(result_file, 'w', encoding='utf-8') as f:
                json.dump({
                    "job_id": job_id,
                    "model_id": new_model_id,
                    "base_model": model_id,
                    "status": "completed",
                    "created_at": model_info["created_at"],
                    "completed_at": datetime.now().isoformat(),
                    "parameters": parameters,
                    "metrics": model_info["metrics"]
                }, f, ensure_ascii=False, indent=2)

            # 通知微调完成
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "normal",
                    "type": "finetuning_completed",
                    "payload": {
                        "job_id": job_id,
                        "model_id": new_model_id,
                        "base_model": model_id,
                        "metrics": model_info["metrics"]
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)

            # 从活跃任务中移除
            with self._job_lock:
                if job_id in self.active_jobs:
                    del self.active_jobs[job_id]
                if job_id in self.job_threads:
                    del self.job_threads[job_id]

            logging.info(f"微调任务 {job_id} 完成，生成新模型 {new_model_id}")
            return {"success": True, "model_id": new_model_id, "base_model": model_id}
        except Exception as e:
            error_msg = f"执行微调任务失败: {str(e)}"
            logging.error(error_msg)

            # 更新任务状态为失败
            self._update_job_status(job_id, "failed", 0.0, {"error": str(e)})

            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="finetuning_job_error",
                    error_message=error_msg
                )

            # 通知微调失败
            if self.message_bus:
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "high",
                    "type": "finetuning_failed",
                    "payload": {
                        "job_id": job_id,
                        "model_id": model_id,
                        "error": str(e)
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)

            # 从活跃任务中移除
            with self._job_lock:
                if job_id in self.active_jobs:
                    del self.active_jobs[job_id]
                if job_id in self.job_threads:
                    del self.job_threads[job_id]

            return {"success": False, "error": str(e)}

    def _run_evaluation(self, model_id: str, test_data_path: str) -> Dict:
        """执行模型评估

        Args:
            model_id: 模型ID
            test_data_path: 测试数据集路径

        Returns:
            Dict: 评估结果
        """
        try:
            logging.info(f"开始评估模型 {model_id}")

            # 加载模型信息
            model_file = os.path.join(self.models_directory, f"{model_id}.json")
            with open(model_file, 'r', encoding='utf-8') as f:
                model_data = json.load(f)

            # 模拟加载测试数据
            time.sleep(1)

            # 模拟评估过程
            time.sleep(2)

            # 模拟评估指标（根据模型类型生成不同的指标）
            model_type = model_data.get("type", "")
            metrics = {}

            if "classification" in model_type.lower():
                metrics = {
                    "accuracy": 0.91,
                    "precision": 0.89,
                    "recall": 0.92,
                    "f1_score": 0.90,
                    "confusion_matrix": [[95, 5], [8, 92]]
                }
            elif "regression" in model_type.lower():
                metrics = {
                    "mean_squared_error": 0.025,
                    "mean_absolute_error": 0.12,
                    "r2_score": 0.87,
                    "explained_variance": 0.88
                }
            else:
                # 默认指标
                metrics = {
                    "accuracy": 0.92,
                    "loss": 0.08,
                    "auc": 0.94
                }

            # 添加评估元数据
            result = {
                "metrics": metrics,
                "model_id": model_id,
                "test_data": test_data_path,
                "timestamp": datetime.now().isoformat(),
                "success": True
            }

            logging.info(f"模型 {model_id} 评估完成")
            return result
        except Exception as e:
            error_msg = f"执行模型评估失败: {str(e)}"
            logging.error(error_msg)
            if self.error_handler:
                self.error_handler.handle_error(
                    module="train_local",
                    error_type="evaluation_error",
                    error_message=error_msg
                )
            return {"success": False, "error": str(e)}

def _manage_training_resources(self, required_resources: Dict) -> bool:
        """管理训练资源，确保有足够的资源执行训练任务

        Args:
            required_resources: 需要的资源

        Returns:
            bool: 是否有足够资源
        """
        try:
            # 检查当前活跃任务数是否已达上限
            if len(self.active_jobs) >= self.resource_limits["max_jobs"]:
                logging.warning(f"已达到最大任务数限制: {self.resource_limits['max_jobs']}")
                return False

            # 检查内存需求
            required_memory = required_resources.get("memory_gb", 2)
            if required_memory > self.resource_limits["max_memory_gb"]:
                logging.warning(f"内存需求超过限制: {required_memory}GB > {self.resource_limits['max_memory_gb']}GB")
                return False

            # 检查GPU内存需求
            required_gpu_memory = required_resources.get("gpu_memory_gb", 1)
            if required_gpu_memory > self.resource_limits["max_gpu_memory_gb"]:
                logging.warning(f"GPU内存需求超过限制: {required_gpu_memory}GB > {self.resource_limits['max_gpu_memory_gb']}GB")
                return False

            # 检查CPU核心需求
            required_cpu_cores = required_resources.get("cpu_cores", 1)
            if required_cpu_cores > self.resource_limits["max_cpu_cores"]:
                logging.warning(f"CPU核心需求超过限制: {required_cpu_cores} > {self.resource_limits['max_cpu_cores']}")
                return False

            # 所有资源检查通过
            return True
        except Exception as e:
            logging.error(f"管理训练资源失败: {str(e)}")
            return False

    def _monitor_training_job(self, job_id: str) -> Dict:
        """监控训练任务状态

        Args:
            job_id: 训练任务ID

        Returns:
            Dict: 训练任务状态信息
        """
        try:
            if job_id not in self.active_jobs:
                return {"error": f"任务不存在: {job_id}"}

            job_info = self.active_jobs[job_id]

            # 添加实时资源使用信息
            job_info["resources"] = {
                "memory_usage_gb": 2.5,  # 模拟值
                "gpu_memory_usage_gb": 1.2,  # 模拟值
                "cpu_usage_percent": 75  # 模拟值
            }

            return job_info
        except Exception as e:
            logging.error(f"监控训练任务失败: {str(e)}")
            return {"error": str(e)}

    def _get_resource_usage(self) -> Dict:
        """获取资源使用情况

        Returns:
            Dict: 资源使用信息
        """
        try:
            # 获取存储使用情况
            models_size = sum(os.path.getsize(os.path.join(self.models_directory, f))
                            for f in os.listdir(self.models_directory) if os.path.isfile(os.path.join(self.models_directory, f)))

            datasets_size = sum(os.path.getsize(os.path.join(self.datasets_directory, f))
                              for f in os.listdir(self.datasets_directory) if os.path.isfile(os.path.join(self.datasets_directory, f)))

            jobs_size = sum(os.path.getsize(os.path.join(self.training_jobs_directory, f))
                          for f in os.listdir(self.training_jobs_directory) if os.path.isfile(os.path.join(self.training_jobs_directory, f)))

            # 模拟系统资源使用情况
            mem_usage = 2.0 + (len(self.active_jobs) * 0.5)  # 每个任务增加0.5GB内存使用
            gpu_mem_usage = 1.0 + (len(self.active_jobs) * 0.3)  # 每个任务增加0.3GB GPU内存使用
            cpu_usage = 20 + (len(self.active_jobs) * 15)  # 每个任务增加15%CPU使用

            return {
                "models_count": len([f for f in os.listdir(self.models_directory) if f.endswith('.json')]),
                "models_size_mb": round(models_size / (1024 * 1024), 2),
                "datasets_count": len(os.listdir(self.datasets_directory)),
                "datasets_size_mb": round(datasets_size / (1024 * 1024), 2),
                "jobs_count": len(os.listdir(self.training_jobs_directory)) // 2,  # 每个任务有两个文件
                "jobs_size_mb": round(jobs_size / (1024 * 1024), 2),
                "active_jobs": len(self.active_jobs),
                "memory_usage_gb": min(mem_usage, self.resource_limits["max_memory_gb"]),
                "gpu_memory_usage_gb": min(gpu_mem_usage, self.resource_limits["max_gpu_memory_gb"]),
                "cpu_usage_percent": min(cpu_usage, 100),
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logging.warning(f"获取资源使用情况失败: {str(e)}")
            return {
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }

    def _update_job_status(self, job_id: str, status: str, progress: float, metrics: Dict = None) -> None:
        """更新训练任务状态

        Args:
            job_id: 训练任务ID
            status: 新状态
            progress: 进度(0-1)
            metrics: 训练指标
        """
        try:
            if job_id not in self.active_jobs:
                logging.warning(f"无法更新不存在的任务状态: {job_id}")
                return

            with self._job_lock:
                self.active_jobs[job_id]["status"] = status
                self.active_jobs[job_id]["progress"] = progress
                self.active_jobs[job_id]["updated_at"] = datetime.now().isoformat()

                if metrics:
                    if "metrics" not in self.active_jobs[job_id]:
                        self.active_jobs[job_id]["metrics"] = {}

                    self.active_jobs[job_id]["metrics"].update(metrics)

            # 保存任务状态
            self._save_job_state(job_id, self.active_jobs[job_id])

            # 通知状态更新
            if self.message_bus:
                job_type = self.active_jobs[job_id].get("job_type", "training")
                notify_message = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": "assembly_ctrl",
                    "priority": "low",
                    "type": f"{job_type}_status_update",
                    "payload": {
                        "job_id": job_id,
                        "status": status,
                        "progress": progress,
                        "model_id": self.active_jobs[job_id].get("model_id", ""),
                        "metrics": metrics
                    },
                    "metadata": {"timestamp": datetime.now().isoformat()}
                }
                self.message_bus.send_message(notify_message)
        except Exception as e:
            logging.error(f"更新任务状态失败: {str(e)}")

    def _save_job_state(self, job_id: str, job_info: Dict) -> None:
        """保存训练任务状态到文件

        Args:
            job_id: 训练任务ID
            job_info: 任务信息
        """
        try:
            job_file = os.path.join(self.training_jobs_directory, f"{job_id}.json")

            # 创建临时文件
            temp_file = f"{job_file}.tmp"
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(job_info, f, ensure_ascii=False, indent=2)

            # 原子替换
            if os.path.exists(job_file):
                os.replace(temp_file, job_file)
            else:
                os.rename(temp_file, job_file)
        except Exception as e:
            logging.error(f"保存任务状态失败: {str(e)}")
            if os.path.exists(f"{job_file}.tmp"):
                os.remove(f"{job_file}.tmp")

def _restore_training_jobs(self) -> None:
        """恢复未完成的训练任务"""
        try:
            logging.info("尝试恢复未完成的训练任务...")

            # 扫描任务目录
            job_files = [f for f in os.listdir(self.training_jobs_directory)
                         if f.endswith('.json') and not f.endswith('_result.json')]

            restored_count = 0

            for job_file in job_files:
                job_id = job_file.replace('.json', '')
                job_path = os.path.join(self.training_jobs_directory, job_file)

                try:
                    with open(job_path, 'r', encoding='utf-8') as f:
                        job_info = json.load(f)

                    # 检查任务状态
                    status = job_info.get("status", "")

                    if status in ["preparing", "loading_data", "training", "finetuning", "saving_model"]:
                        # 任务未完成，需要恢复
                        logging.info(f"恢复任务: {job_id}, 原状态: {status}")

                        # 更新状态为暂停
                        job_info["status"] = "paused"
                        job_info["paused_at"] = datetime.now().isoformat()
                        job_info["resume_available"] = True

                        # 保存更新后的状态
                        self._save_job_state(job_id, job_info)

                        # 通知任务已暂停
                        if self.message_bus:
                            job_type = job_info.get("job_type", "training")
                            notify_message = {
                                "message_id": str(uuid.uuid4()),
                                "source": self.module_id,
                                "destination": "assembly_ctrl",
                                "priority": "normal",
                                "type": f"{job_type}_paused",
                                "payload": {
                                    "job_id": job_id,
                                    "model_id": job_info.get("model_id", ""),
                                    "resume_available": True
                                },
                                "metadata": {"timestamp": datetime.now().isoformat()}
                            }
                            self.message_bus.send_message(notify_message)

                        restored_count += 1
                except Exception as e:
                    logging.error(f"恢复任务{job_id}失败: {str(e)}")

            if restored_count > 0:
                logging.info(f"已恢复{restored_count}个未完成的训练任务")
            else:
                logging.info("没有找到需要恢复的训练任务")
        except Exception as e:
            logging.error(f"恢复训练任务失败: {str(e)}")

    def _load_model_configs(self) -> None:
        """加载模型配置信息"""
        try:
            # 模型配置文件路径
            config_file = os.path.join(self.models_directory, "model_configs.json")

            # 如果配置文件不存在，创建默认配置
            if not os.path.exists(config_file):
                default_configs = {
                    "supported_model_types": [
                        {
                            "type": "sequential",
                            "description": "顺序模型，适用于简单的分类和回归任务"
                        },
                        {
                            "type": "cnn",
                            "description": "卷积神经网络，适用于图像处理任务"
                        },
                        {
                            "type": "rnn",
                            "description": "循环神经网络，适用于序列和时序数据"
                        },
                        {
                            "type": "transformer",
                            "description": "Transformer模型，适用于NLP任务"
                        }
                    ],
                    "default_parameters": {
                        "sequential": {
                            "learning_rate": 0.001,
                            "batch_size": 32,
                            "epochs": 10
                        },
                        "cnn": {
                            "learning_rate": 0.0005,
                            "batch_size": 16,
                            "epochs": 20
                        },
                        "rnn": {
                            "learning_rate": 0.001,
                            "batch_size": 32,
                            "epochs": 15
                        },
                        "transformer": {
                            "learning_rate": 0.0001,
                            "batch_size": 8,
                            "epochs": 5
                        }
                    }
                }

                with open(config_file, 'w', encoding='utf-8') as f:
                    json.dump(default_configs, f, ensure_ascii=False, indent=2)

                logging.info("已创建默认模型配置")
            else:
                logging.info("已加载现有模型配置")
        except Exception as e:
            logging.error(f"加载模型配置失败: {str(e)}")

    def _handle_train_request(self, message: Message) -> None:
        """处理训练请求消息

        Args:
            message: 训练请求消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        model_id = payload.get("model_id", str(uuid.uuid4()))
        dataset_path = payload.get("dataset_path", "")
        parameters = payload.get("parameters", {})

        if not dataset_path:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "train_response",
                    "payload": {
                        "success": False,
                        "error": "未提供数据集路径"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行训练
        result = self.train_model(model_id, dataset_path, parameters)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "train_response",
                "payload": result,
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

def _handle_finetune_request(self, message: Message) -> None:
        """处理微调请求消息

        Args:
            message: 微调请求消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        model_id = payload.get("model_id", "")
        dataset_path = payload.get("dataset_path", "")
        parameters = payload.get("parameters", {})

        if not model_id or not dataset_path:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "finetune_response",
                    "payload": {
                        "success": False,
                        "error": "未提供模型ID或数据集路径"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行微调
        result = self.finetune_model(model_id, dataset_path, parameters)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "finetune_response",
                "payload": result,
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_evaluate_request(self, message: Message) -> None:
        """处理评估请求消息

        Args:
            message: 评估请求消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        model_id = payload.get("model_id", "")
        test_data_path = payload.get("test_data_path", "")

        if not model_id or not test_data_path:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "evaluate_response",
                    "payload": {
                        "success": False,
                        "error": "未提供模型ID或测试数据路径"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
            return

        # 执行评估
        result = self.evaluate_model(model_id, test_data_path)

        # 返回响应
        if self.message_bus:
            response = {
                "message_id": str(uuid.uuid4()),
                "source": self.module_id,
                "destination": source,
                "priority": "normal",
                "type": "evaluate_response",
                "payload": result,
                "metadata": {
                    "in_response_to": message_id,
                    "timestamp": datetime.now().isoformat()
                }
            }
            self.message_bus.send_message(response)

    def _handle_model_info_request(self, message: Message) -> None:
        """处理模型信息请求消息

        Args:
            message: 模型信息请求消息
        """
        source = message.get("source", "unknown")
        message_id = message.get("message_id", "")
        payload = message.get("payload", {})

        model_id = payload.get("model_id", "")
        list_all = payload.get("list_all", False)

        if list_all:
            # 列出所有模型
            models = self.list_models()

            # 返回响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "model_list_response",
                    "payload": {
                        "models": models,
                        "count": len(models)
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
        elif model_id:
            # 获取特定模型信息
            model_info = self.get_model_info(model_id)

            # 返回响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "model_info_response",
                    "payload": model_info,
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)
        else:
            # 返回错误响应
            if self.message_bus:
                response = {
                    "message_id": str(uuid.uuid4()),
                    "source": self.module_id,
                    "destination": source,
                    "priority": "normal",
                    "type": "model_info_response",
                    "payload": {
                        "error": "未提供模型ID且未请求列出所有模型"
                    },
                    "metadata": {
                        "in_response_to": message_id,
                        "timestamp": datetime.now().isoformat()
                    }
                }
                self.message_bus.send_message(response)

==================== [第六阶段 - 测试与集成] ====================

"""
ASSEMBLY-CTRL System - TestVerify Module (Part 1)
Implementation of the System Testing and Verification Component
"""

import uuid
import time
import datetime
import logging
import inspect
import statistics
from typing import Dict, List, Any

from core.error_handler import ErrorHandler
from core.message_bus import MessageBus, Message
from core.module_registry import ModuleRegistry
from core.resource_manager import ResourceMonitor
from utils.config import Config

# =================================================================================
# TestVerify - System Testing and Verification Module
# =================================================================================

class TestVerify:
    """System testing window: responsible for functional, integration, and performance testing"""

    def __init__(self, config: Config = None, message_bus: MessageBus = None,
                 error_handler: ErrorHandler = None):
        """Initialize test verification module"""
        self.logger = logging.getLogger("TestVerify")
        self.config = config or Config()
        self.message_bus = message_bus
        self.error_handler = error_handler
        self.module_registry = ModuleRegistry()
        self.resource_monitor = ResourceMonitor()

        # Test state and history
        self.test_history = []
        self.current_test = None
        self.test_in_progress = False
        self.test_suites = {}
        self.reports = {}

        # Performance baseline
        self.performance_baseline = {
            "message_throughput": 1000,  # Messages per second
            "task_latency": 50,          # Milliseconds
            "concurrent_operations": 100, # Number of concurrent operations
            "resource_efficiency": 0.8,   # Resource utilization ratio
            "stability_score": 0.95       # Stability score
        }

        # Initialize test suites
        self._initialize_test_suites()

    def _register_module(self) -> None:
        """Register this module with the module registry"""
        if self.module_registry:
            self.module_registry.register_module(
                module_id="test_verify",
                module_instance=self,
                module_type="system",
                module_description="System testing and verification module"
            )

    def start(self) -> bool:
        """Start the test verification module"""
        try:
            self.logger.info("Starting TestVerify module")
            self._register_module()

            if self.message_bus:
                self.message_bus.register_handler("test_verify", self._handle_message)

            return True
        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    error=e,
                    source="TestVerify.start",
                    severity="critical",
                    additional_info="Failed to start test verification module"
                )
            self.logger.error(f"Failed to start TestVerify: {str(e)}")
            return False

    def stop(self) -> bool:
        """Stop the test verification module"""
        try:
            self.logger.info("Stopping TestVerify module")

            if self.test_in_progress:
                self._abort_current_test()

            if self.message_bus:
                self.message_bus.unregister_handler("test_verify")

            return True
        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    error=e,
                    source="TestVerify.stop",
                    severity="warning",
                    additional_info="Failed to stop test verification module cleanly"
                )
            self.logger.error(f"Failed to stop TestVerify: {str(e)}")
            return False

    def run_test_suite(self, suite_id: str = None) -> Dict:
        """Run specified test suite or all test suites"""
        if self.test_in_progress:
            return {"success": False, "error": "Test already in progress"}

        self.test_in_progress = True
        self.current_test = {"id": str(uuid.uuid4()), "type": "suite", "suite_id": suite_id}

        try:
            start_time = time.time()

            if suite_id and suite_id in self.test_suites:
                # Run specific test suite
                suite = self.test_suites[suite_id]
                results = self._execute_test_suite(suite_id, suite)
            else:
                # Run all test suites
                results = {}
                for s_id, suite in self.test_suites.items():
                    results[s_id] = self._execute_test_suite(s_id, suite)

            # Calculate overall results
            total_tests = 0
            passed_tests = 0
            for suite_results in results.values():
                if isinstance(suite_results, dict) and "tests" in suite_results:
                    total_tests += suite_results["total"]
                    passed_tests += suite_results["passed"]

            # Generate summary
            summary = {
                "test_id": self.current_test["id"],
                "timestamp": datetime.datetime.now().isoformat(),
                "duration": time.time() - start_time,
                "total_tests": total_tests,
                "passed_tests": passed_tests,
                "success_rate": (passed_tests / total_tests) if total_tests > 0 else 0,
                "results": results
            }

            # Save test history
            self.test_history.append({
                "id": self.current_test["id"],
                "type": "suite",
                "suite_id": suite_id,
                "timestamp": summary["timestamp"],
                "success_rate": summary["success_rate"],
                "duration": summary["duration"]
            })

            # Generate test report
            report_id = self._generate_test_report(self.current_test["id"], summary)
            summary["report_id"] = report_id

            # Send test completion message
            if self.message_bus:
                self.message_bus.send_message(
                    Message(
                        message_id=str(uuid.uuid4()),
                        source="test_verify",
                        destination="*",
                        priority="normal",
                        type="test_completed",
                        payload={
                            "test_id": self.current_test["id"],
                            "success_rate": summary["success_rate"],
                            "report_id": report_id
                        }
                    )
                )

            return {"success": True, "summary": summary, "report_id": report_id}

        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    error=e,
                    source="TestVerify.run_test_suite",
                    severity="error",
                    additional_info=f"Failed to run test suite: {suite_id}"
                )
            self.logger.error(f"Error running test suite {suite_id}: {str(e)}")
            return {"success": False, "error": str(e)}

        finally:
            self.test_in_progress = False
            self.current_test = None

    def run_single_test(self, test_id: str) -> Dict:
        """Run a single test"""
        if self.test_in_progress:
            return {"success": False, "error": "Test already in progress"}

        if not test_id or "." not in test_id:
            return {"success": False, "error": "Invalid test ID format. Expected 'suite_id.test_name'"}

        suite_id, test_name = test_id.split(".", 1)

        if suite_id not in self.test_suites:
            return {"success": False, "error": f"Test suite '{suite_id}' not found"}

        suite = self.test_suites[suite_id]
        test_func = None

        # Find the test function
        for name, func in suite.items():
            if name == test_name:
                test_func = func
                break

        if not test_func:
            return {"success": False, "error": f"Test '{test_name}' not found in suite '{suite_id}'"}

        self.test_in_progress = True
        self.current_test = {"id": str(uuid.uuid4()), "type": "single", "test_id": test_id}

        try:
            start_time = time.time()

            # Execute the test
            if suite_id == "performance":
                result = test_func()
                success = True
            else:
                result = test_func()
                success = bool(result)

            duration = time.time() - start_time

            # Generate result
            summary = {
                "test_id": self.current_test["id"],
                "timestamp": datetime.datetime.now().isoformat(),
                "duration": duration,
                "success": success,
                "result": result
            }

            # Save test history
            self.test_history.append({
                "id": self.current_test["id"],
                "type": "single",
                "test_id": test_id,
                "timestamp": summary["timestamp"],
                "success": success,
                "duration": duration
            })

            # Generate test report
            report_id = self._generate_test_report(self.current_test["id"], summary)
            summary["report_id"] = report_id

            # Send test completion message
            if self.message_bus:
                self.message_bus.send_message(
                    Message(
                        message_id=str(uuid.uuid4()),
                        source="test_verify",
                        destination="*",
                        priority="normal",
                        type="test_completed",
                        payload={
                            "test_id": self.current_test["id"],
                            "success": success,
                            "report_id": report_id
                        }
                    )
                )

            return {"success": True, "summary": summary, "report_id": report_id}

        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    error=e,
                    source="TestVerify.run_single_test",
                    severity="error",
                    additional_info=f"Failed to run test: {test_id}"
                )
            self.logger.error(f"Error running test {test_id}: {str(e)}")
            return {"success": False, "error": str(e)}

        finally:
            self.test_in_progress = False
            self.current_test = None

    def verify_module(self, module_id: str) -> Dict:
        """Verify specific module functionality and interface"""
        try:
            # Get module instance
            module = self.module_registry.get_module(module_id)
            if not module:
                return {
                    "success": False,
                    "error": f"Module '{module_id}' not found in registry"
                }

            results = {}

            # Verify module interface
            interface_result = self._verify_module_interface(module_id)
            results["interface"] = interface_result

            # Verify module functionality
            functionality_result = self._test_module_functionality(module_id)
            results["functionality"] = functionality_result

            # Generate summary
            overall_success = (
                interface_result.get("success", False) and
                functionality_result.get("success", False)
            )

            summary = {
                "module_id": module_id,
                "timestamp": datetime.datetime.now().isoformat(),
                "overall_success": overall_success,
                "results": results
            }

            return {"success": True, "summary": summary}

        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    error=e,
                    source="TestVerify.verify_module",
                    severity="error",
                    additional_info=f"Failed to verify module: {module_id}"
                )
            self.logger.error(f"Error verifying module {module_id}: {str(e)}")
            return {"success": False, "error": str(e)}

    # [Continued in Part 2...]

# [Continued from Part 1...]

    def benchmark_system(self, benchmark_config: Dict = None) -> Dict:
        """Perform system benchmark test"""
        if self.test_in_progress:
            return {"success": False, "error": "Test already in progress"}

        self.test_in_progress = True
        self.current_test = {"id": str(uuid.uuid4()), "type": "benchmark"}

        try:
            # Merge default config with user config
            config = {
                "duration": 60,    # Test duration in seconds
                "threads": 4,      # Number of concurrent threads
                "message_rate": 100,  # Messages per second
                "task_complexity": "medium"  # Task complexity
            }

            if benchmark_config:
                config.update(benchmark_config)

            # Execute performance tests
            start_time = time.time()
            results = self._run_performance_tests(config)
            duration = time.time() - start_time

            # Compare with baseline
            comparison = {}
            for metric, value in results.items():
                if metric in self.performance_baseline:
                    baseline = self.performance_baseline[metric]
                    ratio = value / baseline
                    comparison[metric] = {
                        "current": value,
                        "baseline": baseline,
                        "ratio": ratio,
                        "status": "good" if ratio >= 0.9 else "warning" if ratio >= 0.7 else "critical"
                    }

            # Generate summary
            summary = {
                "benchmark_id": self.current_test["id"],
                "timestamp": datetime.datetime.now().isoformat(),
                "duration": duration,
                "config": config,
                "results": results,
                "comparison": comparison
            }

            # Save test history
            self.test_history.append({
                "id": self.current_test["id"],
                "type": "benchmark",
                "timestamp": summary["timestamp"],
                "duration": duration
            })

            # Generate test report
            report_id = self._generate_test_report(self.current_test["id"], summary)
            summary["report_id"] = report_id

            # Send benchmark completion message
            if self.message_bus:
                self.message_bus.send_message(
                    Message(
                        message_id=str(uuid.uuid4()),
                        source="test_verify",
                        destination="*",
                        priority="normal",
                        type="benchmark_completed",
                        payload={
                            "benchmark_id": self.current_test["id"],
                            "report_id": report_id
                        }
                    )
                )

            return {"success": True, "summary": summary, "report_id": report_id}

        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    error=e,
                    source="TestVerify.benchmark_system",
                    severity="error",
                    additional_info="Failed to run system benchmark"
                )
            self.logger.error(f"Error running system benchmark: {str(e)}")
            return {"success": False, "error": str(e)}

        finally:
            self.test_in_progress = False
            self.current_test = None

    def get_test_report(self, report_id: str = None) -> Dict:
        """Get test report by ID or latest report if ID is None"""
        if not self.reports:
            return {"success": False, "error": "No test reports available"}

        if report_id is None:
            # Return latest report
            latest_id = max(self.reports.keys(),
                           key=lambda k: self.reports[k].get("timestamp", ""))
            report = self.reports[latest_id]
            return {"success": True, "report_id": latest_id, "report": report}

        if report_id not in self.reports:
            return {"success": False, "error": f"Report with ID '{report_id}' not found"}

        return {"success": True, "report_id": report_id, "report": self.reports[report_id]}

    def get_available_tests(self) -> List[Dict]:
        """Get all available tests"""
        available_tests = []

        for suite_id, suite in self.test_suites.items():
            for test_name, test_func in suite.items():
                # Get test function docstring
                doc = inspect.getdoc(test_func) or "No description available"

                available_tests.append({
                    "id": f"{suite_id}.{test_name}",
                    "suite": suite_id,
                    "name": test_name,
                    "description": doc
                })

        return available_tests

    def get_test_history(self) -> List[Dict]:
        """Get test execution history"""
        return self.test_history

    def get_system_health_score(self) -> Dict:
        """Calculate system health score"""
        try:
            # Get recent test results
            recent_tests = self.test_history[-10:] if len(self.test_history) > 10 else self.test_history

            if not recent_tests:
                return {
                    "success": True,
                    "health_score": 0.0,
                    "status": "unknown",
                    "metrics": {
                        "test_success_rate": 0.0,
                        "resource_efficiency": 0.0,
                        "performance_ratio": 0.0,
                        "stability": 0.0
                    }
                }

            # Calculate test success rate
            success_rates = []
            for test in recent_tests:
                if test["type"] == "suite":
                    success_rates.append(test.get("success_rate", 0))
                elif test["type"] == "single":
                    success_rates.append(1.0 if test.get("success", False) else 0.0)

            test_success_rate = statistics.mean(success_rates) if success_rates else 0.0

            # Get resource usage
            resource_usage = self._get_resource_usage()
            resource_efficiency = (
                (1.0 - resource_usage["cpu_usage"] / 100) * 0.4 +
                (1.0 - resource_usage["memory_usage"] / 100) * 0.4 +
                (1.0 - resource_usage["disk_usage"] / 100) * 0.2
            )

            # Performance metrics
            performance_ratio = 0.0
            recent_benchmarks = [t for t in recent_tests if t["type"] == "benchmark"]
            if recent_benchmarks and recent_benchmarks[-1]["id"] in self.reports:
                report = self.reports[recent_benchmarks[-1]["id"]]
                if "comparison" in report:
                    ratios = [comp.get("ratio", 0) for comp in report["comparison"].values()]
                    performance_ratio = statistics.mean(ratios) if ratios else 0.0

            # Stability
            stability = 1.0 - (
                len([t for t in recent_tests if t.get("error")]) / len(recent_tests)
            ) if recent_tests else 0.0

            # Calculate overall health score
            health_score = (
                test_success_rate * 0.4 +
                resource_efficiency * 0.3 +
                performance_ratio * 0.2 +
                stability * 0.1
            )

            # Determine status
            if health_score >= 0.8:
                status = "excellent"
            elif health_score >= 0.6:
                status = "good"
            elif health_score >= 0.4:
                status = "fair"
            else:
                status = "poor"

            return {
                "success": True,
                "health_score": health_score,
                "status": status,
                "metrics": {
                    "test_success_rate": test_success_rate,
                    "resource_efficiency": resource_efficiency,
                    "performance_ratio": performance_ratio,
                    "stability": stability
                },
                "resource_usage": resource_usage
            }

        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    error=e,
                    source="TestVerify.get_system_health_score",
                    severity="warning",
                    additional_info="Failed to calculate system health score"
                )
            self.logger.error(f"Error calculating health score: {str(e)}")
            return {"success": False, "error": str(e)}

    # =================================================================================
    # Helper and Implementation Methods
    # =================================================================================

    def _handle_message(self, message: Message) -> None:
        """Handle received messages"""
        if not message or not isinstance(message, Message):
            self.logger.error("Invalid message received")
            return

        # Process based on message type
        handler_map = {
            "test_request": self._handle_test_request,
            "verification_request": self._handle_verification_request,
            "benchmark_request": self._handle_benchmark_request,
            "report_request": self._handle_report_request
        }

        handler = handler_map.get(message.type)
        if handler:
            try:
                handler(message)
            except Exception as e:
                if self.error_handler:
                    self.error_handler.handle_error(
                        error=e,
                        source="TestVerify._handle_message",
                        severity="error",
                        additional_info=f"Error handling message type: {message.type}"
                    )
                self.logger.error(f"Error handling message {message.type}: {str(e)}")
        else:
            self.logger.warning(f"Unhandled message type: {message.type}")

    def _generate_test_report(self, test_id: str, results: Dict) -> str:
        """Generate a test report and store it"""
        report_id = f"report_{test_id}"

        # Basic report information
        report = {
            "report_id": report_id,
            "test_id": test_id,
            "timestamp": results.get("timestamp", datetime.datetime.now().isoformat()),
            "duration": results.get("duration", 0),
            "results": results
        }

        # Analyze results
        if "summary" not in report:
            report["summary"] = self._analyze_test_results(results)

        # Store report
        self.reports[report_id] = report

        return report_id

    def _verify_module_interface(self, module_id: str) -> Dict:
        """Verify module interface against expected interface"""
        module = self.module_registry.get_module(module_id)
        if not module:
            return {"success": False, "error": f"Module '{module_id}' not found"}

        # Get expected module interface
        expected_methods = {
            "start": {"mandatory": True, "params": []},
            "stop": {"mandatory": True, "params": []},
            "_handle_message": {"mandatory": True, "params": ["message"]}
        }

        # Add specific interface requirements for different module types
        module_type = self.module_registry.get_module_type(module_id)
        if module_type == "ai":
            expected_methods.update({
                "process_query": {"mandatory": True, "params": ["query"]},
                "get_model_info": {"mandatory": False, "params": []}
            })
        elif module_type == "ui":
            expected_methods.update({
                "display": {"mandatory": True, "params": ["content"]},
                "get_user_input": {"mandatory": True, "params": []}
            })

        # Check interface implementation
        results = {}
        for method_name, specs in expected_methods.items():
            if hasattr(module, method_name):
                method = getattr(module, method_name)
                if callable(method):
                    # Check parameters
                    sig = inspect.signature(method)
                    params = list(sig.parameters.keys())
                    if "self" in params:
                        params.remove("self")

                    # Check if required parameters exist
                    required_params = specs["params"]
                    missing_params = [p for p in required_params if p not in params]

                    if missing_params:
                        results[method_name] = {
                            "implemented": True,
                            "correct_signature": False,
                            "missing_params": missing_params
                        }
                    else:
                        results[method_name] = {
                            "implemented": True,
                            "correct_signature": True
                        }
                else:
                    results[method_name] = {
                        "implemented": False,
                        "error": "Attribute exists but is not callable"
                    }
            else:
                if specs["mandatory"]:
                    results[method_name] = {
                        "implemented": False,
                        "error": "Required method not implemented"
                    }
                else:
                    results[method_name] = {
                        "implemented": False,
                        "optional": True
                    }

        # Calculate overall result
        mandatory_methods = [name for name, specs in expected_methods.items()
                              if specs["mandatory"]]
        missing_mandatory = [name for name in mandatory_methods
                              if not results.get(name, {}).get("implemented", False)]

        incorrect_signatures = [name for name, result in results.items()
                                if result.get("implemented", False) and
                                   not result.get("correct_signature", True)]

        success = not missing_mandatory and not incorrect_signatures

        return {
            "success": success,
            "module_id": module_id,
            "module_type": module_type,
            "missing_mandatory_methods": missing_mandatory,
            "incorrect_signatures": incorrect_signatures,
            "results": results
        }

    def _initialize_test_suites(self) -> None:
        """Initialize all test suites"""
        # Unit test suite
        self.test_suites["unit"] = {
            "test_message_bus": self._test_message_bus,
            "test_error_handler": self._test_error_handler,
            "test_module_registry": self._test_module_registry,
            "test_resource_monitor": self._test_resource_monitor
        }

        # Integration test suite
        self.test_suites["integration"] = {
            "test_system_startup": self._test_system_startup,
            "test_system_shutdown": self._test_system_shutdown,
            "test_module_communication": self._test_module_communication,
            "test_task_processing": self._test_task_processing,
            "test_error_recovery": self._test_error_recovery
        }

        # Performance test suite
        self.test_suites["performance"] = {
            "test_message_throughput": self._test_message_throughput,
            "test_task_latency": self._test_task_latency,
            "test_concurrent_operations": self._test_concurrent_operations,
            "test_resource_efficiency": self._test_resource_efficiency,
            "test_system_stability": self._test_system_stability
        }

# =================================================================================
# SystemIntegration - System Integration Tool
# =================================================================================

class SystemIntegration:
    """System integration tool: responsible for system deployment and integration verification"""

    @staticmethod
    def analyze_system_dependencies() -> Dict:
        """Analyze dependencies between system modules"""
        # Implementation would go here
        return {"success": True, "dependencies": {}}

    @staticmethod
    def verify_interfaces() -> Dict:
        """Verify interfaces between modules"""
        # Implementation would go here
        return {"success": True, "interfaces": {}}

    @staticmethod
    def optimize_startup_sequence() -> Dict:
        """Optimize system startup sequence"""
        # Implementation would go here
        return {"success": True, "sequence": []}

    @staticmethod
    def verify_configuration() -> Dict:
        """Verify system configuration"""
        # Implementation would go here
        return {"success": True, "configuration": {}}

    @staticmethod
    def check_system_compatibility() -> Dict:
        """Check system compatibility"""
        # Implementation would go here
        return {"success": True, "compatibility": {}}

    @staticmethod
    def generate_deployment_package(output_path: str) -> Dict:
        """Generate system deployment package"""
        # Implementation would go here
        return {"success": True, "package_path": output_path}

==================== [第七阶段 - 部署与运维] ====================
# assembly_ctrl_system/modules/deploy_service/deployment_manager.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
部署管理器模块负责系统的部署策略、环境配置和容器化支持
"""

import os
import uuid
import json
import logging
from typing import Dict, List, Optional, Union, Any

from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from utils.config import Config

class DeploymentManager:
    """
    负责ASSEMBLY-CTRL系统的部署、环境配置和容器化支持
    支持多种部署模式：开发环境、测试环境、生产环境
    支持Docker容器化和Kubernetes编排
    """

    def __init__(self, config: Config, message_bus: MessageBus):
        """初始化部署管理器"""
        self.module_id = f"deploy_manager_{uuid.uuid4().hex[:8]}"
        self.config = config
        self.message_bus = message_bus
        self.error_handler = ErrorHandler()

        # 部署环境配置
        self.environments = {
            "dev": {"debug": True, "log_level": "DEBUG", "monitoring": False},
            "test": {"debug": True, "log_level": "INFO", "monitoring": True},
            "prod": {"debug": False, "log_level": "WARNING", "monitoring": True}
        }

        # 当前环境
        self.current_env = "dev"

        # 已注册容器服务
        self.registered_containers = {}

        # 注册模块
        ModuleRegistry().register_module(self.module_id, self)

        # 注册消息处理
        self.message_bus.register_handler(
            "deployment_request",
            self.handle_deployment_request
        )

        logging.info(f"DeploymentManager initialized with ID: {self.module_id}")

    def handle_deployment_request(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """处理部署请求消息"""
        try:
            action = message.get("payload", {}).get("action")
            if not action:
                return self._create_error_response(message, "No action specified in deployment request")

            if action == "change_environment":
                new_env = message.get("payload", {}).get("environment")
                return self.change_environment(new_env, message)

            elif action == "deploy_container":
                container_config = message.get("payload", {}).get("container_config")
                return self.deploy_container(container_config, message)

            elif action == "get_deployment_status":
                return self.get_deployment_status(message)

            elif action == "generate_deployment_config":
                template_type = message.get("payload", {}).get("template_type", "docker")
                return self.generate_deployment_config(template_type, message)

            else:
                return self._create_error_response(message, f"Unknown action: {action}")

        except Exception as e:
            return self._create_error_response(message, f"Error processing deployment request: {str(e)}")

    def change_environment(self, new_env: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """切换部署环境"""
        if new_env not in self.environments:
            return self._create_error_response(original_message, f"Unknown environment: {new_env}")

        old_env = self.current_env
        self.current_env = new_env

        # 配置日志级别
        log_level = self.environments[new_env]["log_level"]
        logging.getLogger().setLevel(getattr(logging, log_level))

        # 通知其他模块环境变更
        env_change_notice = {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": "broadcast",
            "priority": "high",
            "type": "environment_changed",
            "payload": {
                "old_environment": old_env,
                "new_environment": new_env,
                "environment_config": self.environments[new_env]
            },
            "metadata": {}
        }
        self.message_bus.send_message(env_change_notice)

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "deployment_response",
            "payload": {
                "action": "change_environment",
                "success": True,
                "old_environment": old_env,
                "new_environment": new_env,
                "environment_config": self.environments[new_env]
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def deploy_container(self, container_config: Dict[str, Any], original_message: Dict[str, Any]) -> Dict[str, Any]:
        """部署容器配置"""
        if not container_config:
            return self._create_error_response(original_message, "Missing container configuration")

        container_id = container_config.get("container_id") or f"container_{uuid.uuid4().hex[:8]}"

        # 验证配置
        validation_result = self._validate_container_config(container_config)
        if not validation_result["valid"]:
            return self._create_error_response(
                original_message,
                f"Invalid container configuration: {validation_result['error']}"
            )

        # 注册容器
        self.registered_containers[container_id] = {
            "config": container_config,
            "status": "registered",
            "created_at": import("datetime").datetime.now().isoformat(),
            "environment": self.current_env
        }

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "deployment_response",
            "payload": {
                "action": "deploy_container",
                "success": True,
                "container_id": container_id,
                "status": "registered"
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def get_deployment_status(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """获取当前部署状态"""
        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "deployment_response",
            "payload": {
                "action": "get_deployment_status",
                "success": True,
                "current_environment": self.current_env,
                "environment_config": self.environments[self.current_env],
                "container_count": len(self.registered_containers),
                "containers": self.registered_containers
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def generate_deployment_config(self, template_type: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """生成部署配置模板"""
        if template_type == "docker":
            template = self._generate_docker_template()
        elif template_type == "kubernetes":
            template = self._generate_kubernetes_template()
        else:
            return self._create_error_response(original_message, f"Unknown template type: {template_type}")

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "deployment_response",
            "payload": {
                "action": "generate_deployment_config",
                "success": True,
                "template_type": template_type,
                "template": template
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def _validate_container_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """验证容器配置"""
        required_fields = ["image", "resources"]

        for field in required_fields:
            if field not in config:
                return {"valid": False, "error": f"Missing required field: {field}"}

        # 验证资源配置
        resources = config.get("resources", {})
        if not isinstance(resources, dict):
            return {"valid": False, "error": "Resources must be a dictionary"}

        if "cpu" not in resources or "memory" not in resources:
            return {"valid": False, "error": "Resources must specify cpu and memory"}

        return {"valid": True}

    def _generate_docker_template(self) -> Dict[str, Any]:
        """生成Docker配置模板"""
        return {
            "version": "3",
            "services": {
                "assembly_ctrl": {
                    "image": "assembly_ctrl:latest",
                    "build": {
                        "context": ".",
                        "dockerfile": "Dockerfile"
                    },
                    "ports": ["8080:8080"],
                    "environment": [
                        f"ENV={self.current_env}",
                        "DEBUG=false",
                        "LOG_LEVEL=INFO"
                    ],
                    "volumes": ["./data:/app/data"],
                    "restart": "unless-stopped"
                }
            }
        }

    def _generate_kubernetes_template(self) -> Dict[str, Any]:
        """生成Kubernetes配置模板"""
        return {
            "apiVersion": "apps/v1",
            "kind": "Deployment",
            "metadata": {"name": "assembly-ctrl-deployment"},
            "spec": {
                "replicas": 3,
                "selector": {"matchLabels": {"app": "assembly-ctrl"}},
                "template": {
                    "metadata": {"labels": {"app": "assembly-ctrl"}},
                    "spec": {
                        "containers": [{
                            "name": "assembly-ctrl",
                            "image": "assembly_ctrl:latest",
                            "ports": [{"containerPort": 8080}],
                            "env": [
                                {"name": "ENV", "value": self.current_env},
                                {"name": "DEBUG", "value": "false"},
                                {"name": "LOG_LEVEL", "value": "INFO"}
                            ],
                            "resources": {
                                "limits": {"cpu": "500m", "memory": "512Mi"},
                                "requests": {"cpu": "200m", "memory": "256Mi"}
                            }
                        }]
                    }
                }
            }
        }

    def _create_error_response(self, original_message: Dict[str, Any], error_message: str) -> Dict[str, Any]:
        """创建错误响应消息"""
        error_id = self.error_handler.log_error("DeploymentManager", error_message)

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "high",
            "type": "deployment_response",
            "payload": {
                "success": False,
                "error": error_message,
                "error_id": error_id
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

# assembly_ctrl_system/modules/deploy_service/cloud_provider.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
云服务提供商接口，支持多种云平台的部署和管理
"""

import os
import uuid
import logging
from typing import Dict, List, Optional, Union, Any
from abc import ABC, abstractmethod

from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from utils.config import Config

class CloudProvider(ABC):
    """云服务提供商基类接口"""

    @abstractmethod
    def authenticate(self, credentials: Dict[str, Any]) -> bool:
        """验证云平台身份认证"""
        pass

    @abstractmethod
    def deploy_instance(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """部署云实例"""
        pass

    @abstractmethod
    def terminate_instance(self, instance_id: str) -> bool:
        """终止云实例"""
        pass

    @abstractmethod
    def list_instances(self) -> List[Dict[str, Any]]:
        """列出所有云实例"""
        pass

    @abstractmethod
    def get_instance_status(self, instance_id: str) -> Dict[str, Any]:
        """获取实例状态"""
        pass

class AWSProvider(CloudProvider):
    """AWS云平台提供商实现"""

    def __init__(self, config: Config):
        """初始化AWS云平台提供商"""
        self.config = config
        self.region = config.get("aws_region", "us-east-1")
        self.instances = {}  # 模拟实例存储
        self.authenticated = False
        logging.info(f"AWS Cloud Provider initialized with region: {self.region}")

    def authenticate(self, credentials: Dict[str, Any]) -> bool:
        """验证AWS身份认证"""
        # 模拟AWS认证流程
        required_keys = ["access_key", "secret_key"]
        if not all(key in credentials for key in required_keys):
            logging.error("Missing required AWS credentials")
            return False

        # 实际应用中会使用boto3验证
        self.authenticated = True
        logging.info("AWS authentication successful")
        return True

    def deploy_instance(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """部署AWS EC2实例"""
        if not self.authenticated:
            raise ValueError("Not authenticated with AWS")

        # 验证配置
        required_fields = ["instance_type", "ami_id"]
        for field in required_fields:
            if field not in config:
                raise ValueError(f"Missing required field in EC2 config: {field}")

        # 模拟部署过程
        instance_id = f"i-{uuid.uuid4().hex[:8]}"
        self.instances[instance_id] = {
            "id": instance_id,
            "type": config["instance_type"],
            "ami": config["ami_id"],
            "status": "pending",
            "created_at": import("datetime").datetime.now().isoformat(),
            "public_ip": f"54.{uuid.uuid4().hex[:2]}.{uuid.uuid4().hex[:2]}.{uuid.uuid4().hex[:2]}"
        }

        # 模拟实例启动过程
        self.instances[instance_id]["status"] = "running"

        logging.info(f"EC2 instance {instance_id} deployed and running")
        return self.instances[instance_id]

    def terminate_instance(self, instance_id: str) -> bool:
        """终止EC2实例"""
        if not self.authenticated:
            raise ValueError("Not authenticated with AWS")

        if instance_id not in self.instances:
            logging.error(f"Instance {instance_id} not found")
            return False

        # 模拟终止过程
        self.instances[instance_id]["status"] = "terminating"
        logging.info(f"EC2 instance {instance_id} terminating")

        # 实际移除实例
        self.instances.pop(instance_id)
        return True

    def list_instances(self) -> List[Dict[str, Any]]:
        """列出所有EC2实例"""
        if not self.authenticated:
            raise ValueError("Not authenticated with AWS")

        return list(self.instances.values())

    def get_instance_status(self, instance_id: str) -> Dict[str, Any]:
        """获取EC2实例状态"""
        if not self.authenticated:
            raise ValueError("Not authenticated with AWS")

        if instance_id not in self.instances:
            raise ValueError(f"Instance {instance_id} not found")

        return {
            "id": instance_id,
            "status": self.instances[instance_id]["status"],
            "details": self.instances[instance_id]
        }

class AzureProvider(CloudProvider):
    """Azure云平台提供商实现"""

    def __init__(self, config: Config):
        """初始化Azure云平台提供商"""
        self.config = config
        self.location = config.get("azure_location", "eastus")
        self.instances = {}  # 模拟实例存储
        self.authenticated = False
        logging.info(f"Azure Cloud Provider initialized with location: {self.location}")

    def authenticate(self, credentials: Dict[str, Any]) -> bool:
        """验证Azure身份认证"""
        # 模拟Azure认证流程
        required_keys = ["tenant_id", "client_id", "client_secret"]
        if not all(key in credentials for key in required_keys):
            logging.error("Missing required Azure credentials")
            return False

        # 实际应用中会使用Azure SDK验证
        self.authenticated = True
        logging.info("Azure authentication successful")
        return True

    def deploy_instance(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """部署Azure虚拟机"""
        if not self.authenticated:
            raise ValueError("Not authenticated with Azure")

        # 验证配置
        required_fields = ["vm_size", "image"]
        for field in required_fields:
            if field not in config:
                raise ValueError(f"Missing required field in VM config: {field}")

        # 模拟部署过程
        instance_id = f"vm-{uuid.uuid4().hex[:8]}"
        self.instances[instance_id] = {
            "id": instance_id,
            "size": config["vm_size"],
            "image": config["image"],
            "status": "Creating",
            "created_at": import("datetime").datetime.now().isoformat(),
            "ip_address": f"40.{uuid.uuid4().hex[:2]}.{uuid.uuid4().hex[:2]}.{uuid.uuid4().hex[:2]}"
        }

        # 模拟实例启动过程
        self.instances[instance_id]["status"] = "Running"

        logging.info(f"Azure VM {instance_id} deployed and running")
        return self.instances[instance_id]

    def terminate_instance(self, instance_id: str) -> bool:
        """终止Azure虚拟机"""
        if not self.authenticated:
            raise ValueError("Not authenticated with Azure")

        if instance_id not in self.instances:
            logging.error(f"VM {instance_id} not found")
            return False

        # 模拟终止过程
        self.instances[instance_id]["status"] = "Deleting"
        logging.info(f"Azure VM {instance_id} deleting")

        # 实际移除实例
        self.instances.pop(instance_id)
        return True

    def list_instances(self) -> List[Dict[str, Any]]:
        """列出所有Azure虚拟机"""
        if not self.authenticated:
            raise ValueError("Not authenticated with Azure")

        return list(self.instances.values())

    def get_instance_status(self, instance_id: str) -> Dict[str, Any]:
        """获取Azure虚拟机状态"""
        if not self.authenticated:
            raise ValueError("Not authenticated with Azure")

        if instance_id not in self.instances:
            raise ValueError(f"VM {instance_id} not found")

        return {
            "id": instance_id,
            "status": self.instances[instance_id]["status"],
            "details": self.instances[instance_id]
        }

# assembly_ctrl_system/modules/deploy_service/cloud_factory.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
云服务工厂，负责创建不同云提供商的实例
"""

import logging
from typing import Dict, Optional, Any

from utils.config import Config
from modules.deploy_service.cloud_provider import CloudProvider, AWSProvider, AzureProvider

class CloudFactory:
    """
    云服务工厂类
    负责创建和管理不同云提供商的实例
    实现了工厂设计模式
    """

    def __init__(self, config: Config):
        """初始化云服务工厂"""
        self.config = config
        self.providers = {}
        logging.info("CloudFactory initialized")

    def get_provider(self, provider_type: str) -> CloudProvider:
        """
        获取指定类型的云提供商实例
        如果实例不存在，则创建新实例

        Args:
            provider_type: 云提供商类型，如 'aws', 'azure', 'gcp'

        Returns:
            CloudProvider: 云提供商实例

        Raises:
            ValueError: 如果提供商类型不支持
        """
        # 如果提供商已存在，直接返回
        if provider_type in self.providers:
            return self.providers[provider_type]

        # 创建新的提供商实例
        provider = None

        if provider_type.lower() == "aws":
            provider = AWSProvider(self.config)
        elif provider_type.lower() == "azure":
            provider = AzureProvider(self.config)
        elif provider_type.lower() == "gcp":
            # GCP提供商实现可在未来添加
            raise NotImplementedError("GCP provider not yet implemented")
        else:
            raise ValueError(f"Unsupported cloud provider: {provider_type}")

        # 缓存提供商实例
        self.providers[provider_type] = provider
        logging.info(f"Created new cloud provider instance: {provider_type}")

        return provider

# assembly_ctrl_system/modules/deploy_service/cloud_service.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
云服务管理模块，提供统一的云服务接口
"""

import uuid
import logging
from typing import Dict, List, Optional, Union, Any

from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from utils.config import Config
from modules.deploy_service.cloud_factory import CloudFactory

class CloudService:
    """
    云服务管理模块
    为系统提供统一的云服务接口
    支持多种云平台的部署和管理
    """

    def __init__(self, config: Config, message_bus: MessageBus):
        """初始化云服务管理模块"""
        self.module_id = f"cloud_service_{uuid.uuid4().hex[:8]}"
        self.config = config
        self.message_bus = message_bus
        self.error_handler = ErrorHandler()

        # 创建云服务工厂
        self.cloud_factory = CloudFactory(config)

        # 已认证的提供商
        self.authenticated_providers = set()

        # 已部署的实例
        self.deployed_instances = {}

        # 注册模块
        ModuleRegistry().register_module(self.module_id, self)

        # 注册消息处理
        self.message_bus.register_handler(
            "cloud_request",
            self.handle_cloud_request
        )

        logging.info(f"CloudService initialized with ID: {self.module_id}")

    def handle_cloud_request(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """处理云服务请求消息"""
        try:
            action = message.get("payload", {}).get("action")
            if not action:
                return self._create_error_response(message, "No action specified in cloud request")

            if action == "authenticate":
                provider_type = message.get("payload", {}).get("provider")
                credentials = message.get("payload", {}).get("credentials")
                return self.authenticate_provider(provider_type, credentials, message)

            elif action == "deploy_instance":
                provider_type = message.get("payload", {}).get("provider")
                instance_config = message.get("payload", {}).get("instance_config")
                return self.deploy_instance(provider_type, instance_config, message)

            elif action == "terminate_instance":
                provider_type = message.get("payload", {}).get("provider")
                instance_id = message.get("payload", {}).get("instance_id")
                return self.terminate_instance(provider_type, instance_id, message)

            elif action == "list_instances":
                provider_type = message.get("payload", {}).get("provider")
                return self.list_instances(provider_type, message)

            elif action == "get_instance_status":
                provider_type = message.get("payload", {}).get("provider")
                instance_id = message.get("payload", {}).get("instance_id")
                return self.get_instance_status(provider_type, instance_id, message)

            else:
                return self._create_error_response(message, f"Unknown action: {action}")

        except Exception as e:
            return self._create_error_response(message, f"Error processing cloud request: {str(e)}")

    def authenticate_provider(self, provider_type: str, credentials: Dict[str, Any], original_message: Dict[str, Any]) -> Dict[str, Any]:
        """认证云服务提供商"""
        if not provider_type:
            return self._create_error_response(original_message, "No provider type specified")

        if not credentials:
            return self._create_error_response(original_message, "No credentials provided")

        try:
            # 获取提供商实例
            provider = self.cloud_factory.get_provider(provider_type)

            # 执行认证
            success = provider.authenticate(credentials)

            if success:
                self.authenticated_providers.add(provider_type)
                logging.info(f"Successfully authenticated with {provider_type}")

                return {
                    "message_id": uuid.uuid4().hex,
                    "source": self.module_id,
                    "destination": original_message.get("source"),
                    "priority": "normal",
                    "type": "cloud_response",
                    "payload": {
                        "action": "authenticate",
                        "provider": provider_type,
                        "success": True
                    },
                    "metadata": {
                        "in_response_to": original_message.get("message_id")
                    }
                }
            else:
                logging.error(f"Authentication failed with {provider_type}")
                return self._create_error_response(
                    original_message,
                    f"Authentication failed with {provider_type}"
                )

        except ValueError as e:
            return self._create_error_response(original_message, str(e))
        except NotImplementedError as e:
            return self._create_error_response(original_message, str(e))

    def deploy_instance(self, provider_type: str, instance_config: Dict[str, Any], original_message: Dict[str, Any]) -> Dict[str, Any]:
        """部署云实例"""
        if not provider_type:
            return self._create_error_response(original_message, "No provider type specified")

        if not instance_config:
            return self._create_error_response(original_message, "No instance configuration provided")

        if provider_type not in self.authenticated_providers:
            return self._create_error_response(
                original_message,
                f"Not authenticated with {provider_type}. Please authenticate first."
            )

        try:
            # 获取提供商实例
            provider = self.cloud_factory.get_provider(provider_type)

            # 部署实例
            instance = provider.deploy_instance(instance_config)

            # 记录已部署实例
            instance_id = instance["id"]
            self.deployed_instances[instance_id] = {
                "provider": provider_type,
                "details": instance
            }

            logging.info(f"Successfully deployed instance {instance_id} on {provider_type}")

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "cloud_response",
                "payload": {
                    "action": "deploy_instance",
                    "provider": provider_type,
                    "success": True,
                    "instance": instance
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }

        except Exception as e:
            return self._create_error_response(original_message, f"Error deploying instance: {str(e)}")

    def terminate_instance(self, provider_type: str, instance_id: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """终止云实例"""
        if not provider_type:
            return self._create_error_response(original_message, "No provider type specified")

        if not instance_id:
            return self._create_error_response(original_message, "No instance ID provided")

        if provider_type not in self.authenticated_providers:
            return self._create_error_response(
                original_message,
                f"Not authenticated with {provider_type}. Please authenticate first."
            )

        try:
            # 获取提供商实例
            provider = self.cloud_factory.get_provider(provider_type)

            # 终止实例
            success = provider.terminate_instance(instance_id)

            if success:
                # 移除已部署实例记录
                if instance_id in self.deployed_instances:
                    self.deployed_instances.pop(instance_id)

                logging.info(f"Successfully terminated instance {instance_id} on {provider_type}")

                return {
                    "message_id": uuid.uuid4().hex,
                    "source": self.module_id,
                    "destination": original_message.get("source"),
                    "priority": "normal",
                    "type": "cloud_response",
                    "payload": {
                        "action": "terminate_instance",
                        "provider": provider_type,
                        "instance_id": instance_id,
                        "success": True
                    },
                    "metadata": {
                        "in_response_to": original_message.get("message_id")
                    }
                }
            else:
                return self._create_error_response(
                    original_message,
                    f"Failed to terminate instance {instance_id} on {provider_type}"
                )

        except Exception as e:
            return self._create_error_response(original_message, f"Error terminating instance: {str(e)}")

    def list_instances(self, provider_type: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """列出云实例"""
        if not provider_type:
            return self._create_error_response(original_message, "No provider type specified")

        if provider_type not in self.authenticated_providers:
            return self._create_error_response(
                original_message,
                f"Not authenticated with {provider_type}. Please authenticate first."
            )

        try:
            # 获取提供商实例
            provider = self.cloud_factory.get_provider(provider_type)

            # 获取实例列表
            instances = provider.list_instances()

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "cloud_response",
                "payload": {
                    "action": "list_instances",
                    "provider": provider_type,
                    "success": True,
                    "instances": instances
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }

        except Exception as e:
            return self._create_error_response(original_message, f"Error listing instances: {str(e)}")

    def get_instance_status(self, provider_type: str, instance_id: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """获取云实例状态"""
        if not provider_type:
            return self._create_error_response(original_message, "No provider type specified")

        if not instance_id:
            return self._create_error_response(original_message, "No instance ID provided")

        if provider_type not in self.authenticated_providers:
            return self._create_error_response(
                original_message,
                f"Not authenticated with {provider_type}. Please authenticate first."
            )

        try:
            # 获取提供商实例
            provider = self.cloud_factory.get_provider(provider_type)

            # 获取实例状态
            status = provider.get_instance_status(instance_id)

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "cloud_response",
                "payload": {
                    "action": "get_instance_status",
                    "provider": provider_type,
                    "instance_id": instance_id,
                    "success": True,
                    "status": status
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }

        except Exception as e:
            return self._create_error_response(original_message, f"Error getting instance status: {str(e)}")

    def _create_error_response(self, original_message: Dict[str, Any], error_message: str) -> Dict[str, Any]:
        """创建错误响应消息"""
        error_id = self.error_handler.log_error("CloudService", error_message)

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "high",
            "type": "cloud_response",
            "payload": {
                "success": False,
                "error": error_message,
                "error_id": error_id
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

# assembly_ctrl_system/modules/deploy_service/auto_scaling.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
自动扩展模块，负责系统的水平和垂直扩展
"""

import uuid
import logging
import time
from typing import Dict, List, Optional, Union, Any
from threading import Thread

from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from utils.config import Config
from core.resource_manager import ResourceMonitor

class AutoScalingPolicy:
    """自动扩展策略基类"""

    def __init__(self, name: str, config: Dict[str, Any]):
        """初始化自动扩展策略"""
        self.name = name
        self.config = config

    def evaluate(self, metrics: Dict[str, Any]) -> Dict[str, Any]:
        """
        评估指标并返回扩展决策

        Args:
            metrics: 系统指标数据

        Returns:
            Dict: 包含扩展决策的字典
        """
        raise NotImplementedError("Subclasses must implement evaluate method")

class CPUBasedScalingPolicy(AutoScalingPolicy):
    """基于CPU利用率的扩展策略"""

    def __init__(self, config: Dict[str, Any]):
        """初始化CPU扩展策略"""
        super().__init__("cpu_based_scaling", config)
        self.scale_up_threshold = config.get("scale_up_threshold", 75)  # CPU利用率超过75%时扩展
        self.scale_down_threshold = config.get("scale_down_threshold", 25)  # CPU利用率低于25%时收缩
        self.scale_up_factor = config.get("scale_up_factor", 2)  # 扩展因子
        self.scale_down_factor = config.get("scale_down_factor", 0.5)  # 收缩因子

    def evaluate(self, metrics: Dict[str, Any]) -> Dict[str, Any]:
        """评估CPU指标并返回扩展决策"""
        cpu_utilization = metrics.get("cpu_utilization", 0)

        if cpu_utilization > self.scale_up_threshold:
            # CPU利用率超过阈值，需要扩展
            return {
                "action": "scale_up",
                "factor": self.scale_up_factor,
                "reason": f"CPU utilization ({cpu_utilization}%) exceeded threshold ({self.scale_up_threshold}%)"
            }
        elif cpu_utilization < self.scale_down_threshold:
            # CPU利用率低于阈值，可以收缩
            return {
                "action": "scale_down",
                "factor": self.scale_down_factor,
                "reason": f"CPU utilization ({cpu_utilization}%) below threshold ({self.scale_down_threshold}%)"
            }
        else:
            # 无需调整
            return {
                "action": "none",
                "reason": f"CPU utilization ({cpu_utilization}%) within thresholds"
            }

class MemoryBasedScalingPolicy(AutoScalingPolicy):
    """基于内存利用率的扩展策略"""

    def __init__(self, config: Dict[str, Any]):
        """初始化内存扩展策略"""
        super().__init__("memory_based_scaling", config)
        self.scale_up_threshold = config.get("scale_up_threshold", 80)  # 内存利用率超过80%时扩展
        self.scale_down_threshold = config.get("scale_down_threshold", 30)  # 内存利用率低于30%时收缩
        self.scale_up_factor = config.get("scale_up_factor", 1.5)  # 扩展因子
        self.scale_down_factor = config.get("scale_down_factor", 0.7)  # 收缩因子

    def evaluate(self, metrics: Dict[str, Any]) -> Dict[str, Any]:
        """评估内存指标并返回扩展决策"""
        memory_utilization = metrics.get("memory_utilization", 0)

        if memory_utilization > self.scale_up_threshold:
            # 内存利用率超过阈值，需要扩展
            return {
                "action": "scale_up",
                "factor": self.scale_up_factor,
                "reason": f"Memory utilization ({memory_utilization}%) exceeded threshold ({self.scale_up_threshold}%)"
            }
        elif memory_utilization < self.scale_down_threshold:
            # 内存利用率低于阈值，可以收缩
            return {
                "action": "scale_down",
                "factor": self.scale_down_factor,
                "reason": f"Memory utilization ({memory_utilization}%) below threshold ({self.scale_down_threshold}%)"
            }
        else:
            # 无需调整
            return {
                "action": "none",
                "reason": f"Memory utilization ({memory_utilization}%) within thresholds"
            }

class RequestRateScalingPolicy(AutoScalingPolicy):
    """基于请求速率的扩展策略"""

    def __init__(self, config: Dict[str, Any]):
        """初始化请求速率扩展策略"""
        super().__init__("request_rate_scaling", config)
        self.scale_up_threshold = config.get("scale_up_threshold", 100)  # 请求速率超过100/秒时扩展
        self.scale_down_threshold = config.get("scale_down_threshold", 20)  # 请求速率低于20/秒时收缩
        self.scale_up_factor = config.get("scale_up_factor", 2)  # 扩展因子
        self.scale_down_factor = config.get("scale_down_factor", 0.5)  # 收缩因子

    def evaluate(self, metrics: Dict[str, Any]) -> Dict[str, Any]:
        """评估请求速率指标并返回扩展决策"""
        request_rate = metrics.get("request_rate", 0)

        if request_rate > self.scale_up_threshold:
            # 请求速率超过阈值，需要扩展
            return {
                "action": "scale_up",
                "factor": self.scale_up_factor,
                "reason": f"Request rate ({request_rate}/sec) exceeded threshold ({self.scale_up_threshold}/sec)"
            }
        elif request_rate < self.scale_down_threshold:
            # 请求速率低于阈值，可以收缩
            return {
                "action": "scale_down",
                "factor": self.scale_down_factor,
                "reason": f"Request rate ({request_rate}/sec) below threshold ({self.scale_down_threshold}/sec)"
            }
        else:
            # 无需调整
            return {
                "action": "none",
                "reason": f"Request rate ({request_rate}/sec) within thresholds"
            }

class AutoScaling:
    """
    自动扩展模块
    负责系统的自动扩展和收缩
    支持多种扩展策略
    """

    def __init__(self, config: Config, message_bus: MessageBus, resource_monitor: ResourceMonitor):
        """初始化自动扩展模块"""
        self.module_id = f"auto_scaling_{uuid.uuid4().hex[:8]}"
        self.config = config
        self.message_bus = message_bus
        self.error_handler = ErrorHandler()
        self.resource_monitor = resource_monitor

        # 扩展策略
        self.policies = {}

        # 初始化默认策略
        self._init_default_policies()

        # 当前实例数量
        self.current_instances = 1

        # 最小和最大实例数量限制
        self.min_instances = config.get("min_instances", 1)
        self.max_instances = config.get("max_instances", 10)

        # 冷却期（秒）
        self.cooldown_period = config.get("scaling_cooldown_period", 300)
        self.last_scaling_time = 0

        # 监控间隔（秒）
        self.monitoring_interval = config.get("monitoring_interval", 60)

        # 是否开启自动扩展
        self.enabled = config.get("auto_scaling_enabled", False)

        # 注册模块
        ModuleRegistry().register_module(self.module_id, self)

        # 注册消息处理
        self.message_bus.register_handler(
            "scaling_request",
            self.handle_scaling_request
        )

        # 启动监控线程
        if self.enabled:
            self._start_monitoring()

        logging.info(f"AutoScaling initialized with ID: {self.module_id}")

    def _init_default_policies(self):
        """初始化默认扩展策略"""
        # CPU扩展策略
        cpu_policy_config = self.config.get("cpu_scaling_policy", {
            "scale_up_threshold": 75,
            "scale_down_threshold": 25,
            "scale_up_factor": 2,
            "scale_down_factor": 0.5
        })
        self.policies["cpu"] = CPUBasedScalingPolicy(cpu_policy_config)

        # 内存扩展策略
        memory_policy_config = self.config.get("memory_scaling_policy", {
            "scale_up_threshold": 80,
            "scale_down_threshold": 30,
            "scale_up_factor": 1.5,
            "scale_down_factor": 0.7
        })
        self.policies["memory"] = MemoryBasedScalingPolicy(memory_policy_config)

        # 请求速率扩展策略
        request_policy_config = self.config.get("request_scaling_policy", {
            "scale_up_threshold": 100,
            "scale_down_threshold": 20,
            "scale_up_factor": 2,
            "scale_down_factor": 0.5
        })
        self.policies["request_rate"] = RequestRateScalingPolicy(request_policy_config)

    def _start_monitoring(self):
        """启动监控线程"""
        def monitoring_task():
            while self.enabled:
                try:
                    self._check_scaling_conditions()
                    time.sleep(self.monitoring_interval)
                except Exception as e:
                    self.error_handler.log_error("AutoScaling", f"Error in monitoring task: {str(e)}")

        monitor_thread = Thread(target=monitoring_task)
        monitor_thread.daemon = True
        monitor_thread.start()
        logging.info("AutoScaling monitoring thread started")

    def _check_scaling_conditions(self):
        """检查是否需要扩展"""
        # 获取当前指标
        metrics = self.resource_monitor.get_system_metrics()

        # 评估所有策略
        scaling_decisions = {}
        for policy_name, policy in self.policies.items():
            scaling_decisions[policy_name] = policy.evaluate(metrics)

        # 寻找需要扩展的决策
        scale_up_decisions = [d for d in scaling_decisions.values() if d["action"] == "scale_up"]
        scale_down_decisions = [d for d in scaling_decisions.values() if d["action"] == "scale_down"]

        # 确定最终扩展决策（优先扩展）
        if scale_up_decisions and self._can_scale():
            # 选择扩展因子最大的决策
            decision = max(scale_up_decisions, key=lambda d: d["factor"])
            self._execute_scaling(decision)
        elif scale_down_decisions and not scale_up_decisions and self._can_scale():
            # 选择收缩因子最大的决策
            decision = max(scale_down_decisions, key=lambda d: d["factor"])
            self._execute_scaling(decision)

    def _can_scale(self) -> bool:
        """检查是否可以执行扩展操作（是否在冷却期）"""
        current_time = time.time()
        return current_time - self.last_scaling_time >= self.cooldown_period

    def _execute_scaling(self, decision: Dict[str, Any]):
        """执行扩展决策"""
        action = decision["action"]
        factor = decision["factor"]
        reason = decision["reason"]

        if action == "scale_up":
            new_instances = min(int(self.current_instances * factor), self.max_instances)
            if new_instances > self.current_instances:
                self._scale_to(new_instances, reason)
        elif action == "scale_down":
            new_instances = max(int(self.current_instances * factor), self.min_instances)
            if new_instances < self.current_instances:
                self._scale_to(new_instances, reason)

    def _scale_to(self, new_instance_count: int, reason: str):
        """扩展到指定实例数量"""
        old_instances = self.current_instances
        self.current_instances = new_instance_count
        self.last_scaling_time = time.time()

        # 记录扩展操作
        logging.info(f"Scaling from {old_instances} to {new_instance_count} instances. Reason: {reason}")

        # 发送扩展事件消息
        scaling_event = {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": "broadcast",
            "priority": "high",
            "type": "scaling_event",
            "payload": {
                "old_instance_count": old_instances,
                "new_instance_count": new_instance_count,
                "reason": reason,
                "timestamp": time.time()
            },
            "metadata": {}
        }
        self.message_bus.send_message(scaling_event)

    def handle_scaling_request(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """处理扩展请求消息"""
        try:
            action = message.get("payload", {}).get("action")
            if not action:
                return self._create_error_response(message, "No action specified in scaling request")

            if action == "get_status":
                return self.get_status(message)

            elif action == "set_enabled":
                enabled = message.get("payload", {}).get("enabled")
                return self.set_enabled(enabled, message)

            elif action == "manual_scale":
                instance_count = message.get("payload", {}).get("instance_count")
                return self.manual_scale(instance_count, message)

            elif action == "update_policy":
                policy_name = message.get("payload", {}).get("policy_name")
                policy_config = message.get("payload", {}).get("policy_config")
                return self.update_policy(policy_name, policy_config, message)

            else:
                return self._create_error_response(message, f"Unknown action: {action}")

        except Exception as e:
            return self._create_error_response(message, f"Error processing scaling request: {str(e)}")

    def get_status(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """获取自动扩展状态"""
        policy_status = {}
        metrics = self.resource_monitor.get_system_metrics()

        for policy_name, policy in self.policies.items():
            policy_status[policy_name] = {
                "config": policy.config,
                "decision": policy.evaluate(metrics)
            }

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "scaling_response",
            "payload": {
                "action": "get_status",
                "success": True,
                "enabled": self.enabled,
                "current_instances": self.current_instances,
                "min_instances": self.min_instances,
                "max_instances": self.max_instances,
                "cooldown_period": self.cooldown_period,
                "time_since_last_scaling": time.time() - self.last_scaling_time,
                "can_scale_now": self._can_scale(),
                "policies": policy_status,
                "current_metrics": metrics
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def set_enabled(self, enabled: bool, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """设置自动扩展是否启用"""
        if enabled is None:
            return self._create_error_response(original_message, "No enabled value provided")

        old_enabled = self.enabled
        self.enabled = enabled

        # 如果从禁用变为启用，需要启动监控线程
        if not old_enabled and enabled:
            self._start_monitoring()

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "scaling_response",
            "payload": {
                "action": "set_enabled",
                "success": True,
                "old_enabled": old_enabled,
                "new_enabled": enabled
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def manual_scale(self, instance_count: int, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """手动扩展到指定实例数量"""
        if instance_count is None:
            return self._create_error_response(original_message, "No instance count provided")

        if not isinstance(instance_count, int) or instance_count < 1:
            return self._create_error_response(original_message, "Instance count must be a positive integer")

        # 限制实例数量在最小和最大值之间
        instance_count = max(min(instance_count, self.max_instances), self.min_instances)

        old_instances = self.current_instances
        self._scale_to(instance_count, "Manual scaling requested")

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "scaling_response",
            "payload": {
                "action": "manual_scale",
                "success": True,
                "old_instance_count": old_instances,
                "new_instance_count": instance_count
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def update_policy(self, policy_name: str, policy_config: Dict[str, Any], original_message: Dict[str, Any]) -> Dict[str, Any]:
        """更新扩展策略配置"""
        if not policy_name:
            return self._create_error_response(original_message, "No policy name provided")

        if not policy_config:
            return self._create_error_response(original_message, "No policy configuration provided")

        if policy_name not in self.policies:
            return self._create_error_response(original_message, f"Unknown policy: {policy_name}")

        # 保存旧配置
        old_config = self.policies[policy_name].config

        # 更新策略配置
        if policy_name == "cpu":
            self.policies[policy_name] = CPUBasedScalingPolicy(policy_config)
        elif policy_name == "memory":
            self.policies[policy_name] = MemoryBasedScalingPolicy(policy_config)
        elif policy_name == "request_rate":
            self.policies[policy_name] = RequestRateScalingPolicy(policy_config)

        logging.info(f"Updated {policy_name} scaling policy configuration")

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "scaling_response",
            "payload": {
                "action": "update_policy",
                "success": True,
                "policy_name": policy_name,
                "old_config": old_config,
                "new_config": policy_config
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def _create_error_response(self, original_message: Dict[str, Any], error_message: str) -> Dict[str, Any]:
        """创建错误响应消息"""
        error_id = self.error_handler.log_error("AutoScaling", error_message)

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "high",
            "type": "scaling_response",
            "payload": {
                "success": False,
                "error": error_message,
                "error_id": error_id
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

# assembly_ctrl_system/modules/maintenance/system_monitor.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
系统监控模块，负责监控系统性能和健康状态
"""

import uuid
import logging
import time
import json
from datetime import datetime
from typing import Dict, List, Optional, Union, Any
from threading import Thread, Lock

from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from utils.config import Config
from core.resource_manager import ResourceMonitor

class MetricCollector:
    """指标收集器，负责采集系统各种性能指标"""

    def __init__(self, config: Config, resource_monitor: ResourceMonitor):
        """初始化指标收集器"""
        self.config = config
        self.resource_monitor = resource_monitor
        self.collection_interval = config.get("metric_collection_interval", 30)  # 采集间隔（秒）
        self.metrics_history = {}  # 存储历史指标数据
        self.history_length = config.get("metrics_history_length", 100)  # 历史数据保留条数
        self.metrics_lock = Lock()  # 用于线程安全操作

        # 采集指标的类型
        self.metric_types = [
            "cpu_utilization",
            "memory_utilization",
            "disk_usage",
            "network_io",
            "request_rate",
            "response_time",
            "error_rate"
        ]

        # 为每种指标初始化历史数据存储
        for metric_type in self.metric_types:
            self.metrics_history[metric_type] = []

    def start_collection(self):
        """启动指标采集线程"""
        def collection_task():
            while True:
                try:
                    self._collect_metrics()
                    time.sleep(self.collection_interval)
                except Exception as e:
                    logging.error(f"Error in metric collection: {str(e)}")

        collection_thread = Thread(target=collection_task)
        collection_thread.daemon = True
        collection_thread.start()
        logging.info("Metric collection thread started")

    def _collect_metrics(self):
        """采集当前系统指标"""
        # 从ResourceMonitor获取基本系统指标
        system_metrics = self.resource_monitor.get_system_metrics()

        # 获取当前时间戳
        timestamp = datetime.now().isoformat()

        # 模拟采集其他指标（在实际系统中会从各个模块获取）
        metrics = {
            "cpu_utilization": system_metrics.get("cpu_utilization", 0),
            "memory_utilization": system_metrics.get("memory_utilization", 0),
            "disk_usage": system_metrics.get("disk_usage", 0),
            "network_io": {
                "bytes_sent": system_metrics.get("network_bytes_sent", 0),
                "bytes_received": system_metrics.get("network_bytes_received", 0)
            },
            "request_rate": system_metrics.get("request_rate", 0),
            "response_time": system_metrics.get("response_time", 0),
            "error_rate": system_metrics.get("error_rate", 0)
        }

        # 为每个指标添加时间戳
        for metric_type in self.metric_types:
            metric_data = {
                "timestamp": timestamp,
                "value": metrics.get(metric_type, 0)
            }

            # 线程安全地更新指标历史
            with self.metrics_lock:
                self.metrics_history[metric_type].append(metric_data)

                # 保持历史数据在指定长度内
                if len(self.metrics_history[metric_type]) > self.history_length:
                    self.metrics_history[metric_type] = self.metrics_history[metric_type][-self.history_length:]

    def get_current_metrics(self) -> Dict[str, Any]:
        """获取当前系统所有指标"""
        current_metrics = {}

        with self.metrics_lock:
            for metric_type in self.metric_types:
                if self.metrics_history[metric_type]:
                    current_metrics[metric_type] = self.metrics_history[metric_type][-1]["value"]
                else:
                    current_metrics[metric_type] = 0

        return current_metrics

    def get_metrics_history(self, metric_type: str, limit: int = None) -> List[Dict[str, Any]]:
        """获取指定指标的历史数据"""
        if metric_type not in self.metric_types:
            raise ValueError(f"Unknown metric type: {metric_type}")

        with self.metrics_lock:
            if limit:
                return self.metrics_history[metric_type][-limit:]
            else:
                return self.metrics_history[metric_type]

class AlertRule:
    """告警规则，用于定义指标告警条件"""

    def __init__(self, name: str, metric_type: str, threshold: float, condition: str, severity: str):
        """
        初始化告警规则

        Args:
            name: 规则名称
            metric_type: 指标类型
            threshold: 阈值
            condition: 条件（"greater_than", "less_than", "equal_to"）
            severity: 严重程度（"info", "warning", "error", "critical"）
        """
        self.name = name
        self.metric_type = metric_type
        self.threshold = threshold
        self.condition = condition
        self.severity = severity

    def evaluate(self, metric_value: float) -> bool:
        """评估指标值是否触发告警"""
        if self.condition == "greater_than":
            return metric_value > self.threshold
        elif self.condition == "less_than":
            return metric_value < self.threshold
        elif self.condition == "equal_to":
            return metric_value == self.threshold
        else:
            raise ValueError(f"Unknown condition: {self.condition}")

class AlertManager:
    """告警管理器，负责管理告警规则和处理告警"""

    def __init__(self, config: Config, message_bus: MessageBus):
        """初始化告警管理器"""
        self.config = config
        self.message_bus = message_bus
        self.rules = []  # 告警规则列表
        self.active_alerts = {}  # 当前激活的告警

        # 初始化默认告警规则
        self._init_default_rules()

    def _init_default_rules(self):
        """初始化默认告警规则"""
        default_rules = [
            AlertRule("high_cpu", "cpu_utilization", 90, "greater_than", "warning"),
            AlertRule("critical_cpu", "cpu_utilization", 95, "greater_than", "critical"),
            AlertRule("high_memory", "memory_utilization", 85, "greater_than", "warning"),
            AlertRule("critical_memory", "memory_utilization", 95, "greater_than", "critical"),
            AlertRule("disk_space_low", "disk_usage", 90, "greater_than", "warning"),
            AlertRule("high_error_rate", "error_rate", 5, "greater_than", "warning"),
            AlertRule("critical_error_rate", "error_rate", 10, "greater_than", "critical")
        ]

        for rule in default_rules:
            self.add_rule(rule)

    def add_rule(self, rule: AlertRule):
        """添加告警规则"""
        self.rules.append(rule)
        logging.info(f"Added alert rule: {rule.name}")

    def remove_rule(self, rule_name: str) -> bool:
        """移除告警规则"""
        for i, rule in enumerate(self.rules):
            if rule.name == rule_name:
                self.rules.pop(i)
                logging.info(f"Removed alert rule: {rule_name}")
                return True

        logging.warning(f"Alert rule not found: {rule_name}")
        return False

    def check_alerts(self, metrics: Dict[str, Any]):
        """检查指标是否触发告警"""
        for rule in self.rules:
            metric_value = metrics.get(rule.metric_type)

            if metric_value is None:
                continue

            # 检查是否触发告警
            is_triggered = rule.evaluate(metric_value)

            # 告警已激活且仍然触发
            if rule.name in self.active_alerts and is_triggered:
                # 更新告警持续时间
                self.active_alerts[rule.name]["duration"] += 1

                # 每隔一定时间发送重复告警
                repeat_interval = self.config.get("alert_repeat_interval", 10)
                if self.active_alerts[rule.name]["duration"] % repeat_interval == 0:
                    self._send_alert(rule, metric_value, is_repeat=True)

            # 新触发的告警
            elif is_triggered:
                # 创建新的激活告警
                self.active_alerts[rule.name] = {
                    "rule": rule,
                    "value": metric_value,
                    "start_time": datetime.now().isoformat(),
                    "duration": 1  # 持续周期数
                }

                # 发送告警消息
                self._send_alert(rule, metric_value)

            # 告警已解除
            elif rule.name in self.active_alerts:
                # 发送告警恢复消息
                self._send_recovery(rule, metric_value)

                # 移除激活告警
                del self.active_alerts[rule.name]

    def _send_alert(self, rule: AlertRule, value: float, is_repeat: bool = False):
        """发送告警消息"""
        alert_msg = {
            "message_id": uuid.uuid4().hex,
            "source": "alert_manager",
            "destination": "broadcast",
            "priority": "high",
            "type": "system_alert",
            "payload": {
                "rule_name": rule.name,
                "metric_type": rule.metric_type,
                "threshold": rule.threshold,
                "current_value": value,
                "severity": rule.severity,
                "timestamp": datetime.now().isoformat(),
                "is_repeat": is_repeat
            },
            "metadata": {}
        }

        self.message_bus.send_message(alert_msg)
        logging.warning(f"Alert triggered: {rule.name}, value: {value}, severity: {rule.severity}")

    def _send_recovery(self, rule: AlertRule, value: float):
        """发送告警恢复消息"""
        recovery_msg = {
            "message_id": uuid.uuid4().hex,
            "source": "alert_manager",
            "destination": "broadcast",
            "priority": "normal",
            "type": "alert_recovery",
            "payload": {
                "rule_name": rule.name,
                "metric_type": rule.metric_type,
                "threshold": rule.threshold,
                "current_value": value,
                "severity": rule.severity,
                "timestamp": datetime.now().isoformat(),
                "duration": self.active_alerts[rule.name]["duration"],
                "start_time": self.active_alerts[rule.name]["start_time"]
            },
            "metadata": {}
        }

        self.message_bus.send_message(recovery_msg)
        logging.info(f"Alert resolved: {rule.name}, value: {value}")

class SystemMonitor:
    """
    系统监控模块
    负责监控系统性能和健康状态
    支持指标收集、告警和监控数据可视化
    """

    def __init__(self, config: Config, message_bus: MessageBus, resource_monitor: ResourceMonitor):
        """初始化系统监控模块"""
        self.module_id = f"system_monitor_{uuid.uuid4().hex[:8]}"
        self.config = config
        self.message_bus = message_bus
        self.error_handler = ErrorHandler()

        # 创建指标收集器
        self.metric_collector = MetricCollector(config, resource_monitor)

        # 创建告警管理器
        self.alert_manager = AlertManager(config, message_bus)

        # 监控检查间隔（秒）
        self.check_interval = config.get("monitor_check_interval", 60)

        # 是否启用监控
        self.enabled = config.get("monitoring_enabled", True)

        # 注册模块
        ModuleRegistry().register_module(self.module_id, self)

        # 注册消息处理
        self.message_bus.register_handler(
            "monitor_request",
            self.handle_monitor_request
        )

        # 启动监控
        if self.enabled:
            self._start_monitoring()

        logging.info(f"SystemMonitor initialized with ID: {self.module_id}")

    def _start_monitoring(self):
        """启动系统监控"""
        # 启动指标收集
        self.metric_collector.start_collection()

        # 启动监控检查线程
        def monitoring_task():
            while self.enabled:
                try:
                    self._check_system_health()
                    time.sleep(self.check_interval)
                except Exception as e:
                    self.error_handler.log_error("SystemMonitor", f"Error in monitoring task: {str(e)}")

        monitor_thread = Thread(target=monitoring_task)
        monitor_thread.daemon = True
        monitor_thread.start()
        logging.info("System monitoring thread started")

    def _check_system_health(self):
        """检查系统健康状态"""
        # 获取当前指标
        current_metrics = self.metric_collector.get_current_metrics()

        # 检查告警
        self.alert_manager.check_alerts(current_metrics)

        # 广播系统健康状态
        health_msg = {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": "broadcast",
            "priority": "low",
            "type": "system_health_update",
            "payload": {
                "timestamp": datetime.now().isoformat(),
                "metrics": current_metrics,
                "active_alerts": len(self.alert_manager.active_alerts),
                "status": "healthy" if len(self.alert_manager.active_alerts) == 0 else "warning"
            },
            "metadata": {}
        }

        self.message_bus.send_message(health_msg)

    def handle_monitor_request(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """处理监控请求消息"""
        try:
            action = message.get("payload", {}).get("action")
            if not action:
                return self._create_error_response(message, "No action specified in monitor request")

            if action == "get_metrics":
                metric_type = message.get("payload", {}).get("metric_type")
                limit = message.get("payload", {}).get("limit")
                return self.get_metrics(metric_type, limit, message)

            elif action == "get_system_health":
                return self.get_system_health(message)

            elif action == "add_alert_rule":
                rule_config = message.get("payload", {}).get("rule_config")
                return self.add_alert_rule(rule_config, message)

            elif action == "remove_alert_rule":
                rule_name = message.get("payload", {}).get("rule_name")
                return self.remove_alert_rule(rule_name, message)

            elif action == "set_enabled":
                enabled = message.get("payload", {}).get("enabled")
                return self.set_enabled(enabled, message)

            else:
                return self._create_error_response(message, f"Unknown action: {action}")

        except Exception as e:
            return self._create_error_response(message, f"Error processing monitor request: {str(e)}")

    def get_metrics(self, metric_type: str, limit: int, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """获取指标数据"""
        try:
            if metric_type == "all":
                # 获取所有当前指标
                metrics = self.metric_collector.get_current_metrics()
                return {
                    "message_id": uuid.uuid4().hex,
                    "source": self.module_id,
                    "destination": original_message.get("source"),
                    "priority": "normal",
                    "type": "monitor_response",
                    "payload": {
                        "action": "get_metrics",
                        "success": True,
                        "metric_type": "all",
                        "metrics": metrics
                    },
                    "metadata": {
                        "in_response_to": original_message.get("message_id")
                    }
                }
            else:
                # 获取指定指标的历史数据
                metrics = self.metric_collector.get_metrics_history(metric_type, limit)
                return {
                    "message_id": uuid.uuid4().hex,
                    "source": self.module_id,
                    "destination": original_message.get("source"),
                    "priority": "normal",
                    "type": "monitor_response",
                    "payload": {
                        "action": "get_metrics",
                        "success": True,
                        "metric_type": metric_type,
                        "metrics": metrics
                    },
                    "metadata": {
                        "in_response_to": original_message.get("message_id")
                    }
                }
        except ValueError as e:
            return self._create_error_response(original_message, str(e))

    def get_system_health(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """获取系统健康状态"""
        # 获取当前指标
        current_metrics = self.metric_collector.get_current_metrics()

        # 获取激活的告警
        active_alerts = []
        for alert_name, alert_info in self.alert_manager.active_alerts.items():
            active_alerts.append({
                "name": alert_name,
                "metric_type": alert_info["rule"].metric_type,
                "severity": alert_info["rule"].severity,
                "value": alert_info["value"],
                "start_time": alert_info["start_time"],
                "duration": alert_info["duration"]
            })

        # 确定系统状态
        if len(active_alerts) == 0:
            status = "healthy"
        else:
            # 检查是否有严重告警
            has_critical = any(alert["severity"] == "critical" for alert in active_alerts)
            status = "critical" if has_critical else "warning"

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "monitor_response",
            "payload": {
                "action": "get_system_health",
                "success": True,
                "timestamp": datetime.now().isoformat(),
                "status": status,
                "metrics": current_metrics,
                "active_alerts": active_alerts
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def add_alert_rule(self, rule_config: Dict[str, Any], original_message: Dict[str, Any]) -> Dict[str, Any]:
        """添加告警规则"""
        if not rule_config:
            return self._create_error_response(original_message, "No rule configuration provided")

        required_fields = ["name", "metric_type", "threshold", "condition", "severity"]
        for field in required_fields:
            if field not in rule_config:
                return self._create_error_response(original_message, f"Missing required field in rule config: {field}")

        # 创建新规则
        try:
            new_rule = AlertRule(
                rule_config["name"],
                rule_config["metric_type"],
                rule_config["threshold"],
                rule_config["condition"],
                rule_config["severity"]
            )

            # 添加规则
            self.alert_manager.add_rule(new_rule)

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "monitor_response",
                "payload": {
                    "action": "add_alert_rule",
                    "success": True,
                    "rule_name": new_rule.name
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except ValueError as e:
            return self._create_error_response(original_message, str(e))

    def remove_alert_rule(self, rule_name: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """移除告警规则"""
        if not rule_name:
            return self._create_error_response(original_message, "No rule name provided")

        # 移除规则
        success = self.alert_manager.remove_rule(rule_name)

        if success:
            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "monitor_response",
                "payload": {
                    "action": "remove_alert_rule",
                    "success": True,
                    "rule_name": rule_name
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        else:
            return self._create_error_response(original_message, f"Alert rule not found: {rule_name}")

    def set_enabled(self, enabled: bool, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """设置监控是否启用"""
        if enabled is None:
            return self._create_error_response(original_message, "No enabled value provided")

        old_enabled = self.enabled
        self.enabled = enabled

        # 如果从禁用变为启用，需要启动监控
        if not old_enabled and enabled:
            self._start_monitoring()

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "monitor_response",
            "payload": {
                "action": "set_enabled",
                "success": True,
                "old_enabled": old_enabled,
                "new_enabled": enabled
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def _create_error_response(self, original_message: Dict[str, Any], error_message: str) -> Dict[str, Any]:
        """创建错误响应消息"""
        error_id = self.error_handler.log_error("SystemMonitor", error_message)

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "high",
            "type": "monitor_response",
            "payload": {
                "success": False,
                "error": error_message,
                "error_id": error_id
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

# assembly_ctrl_system/modules/maintenance/backup_service.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
备份服务模块，负责系统数据的备份和恢复
"""

import uuid
import logging
import os
import json
import shutil
from datetime import datetime
from typing import Dict, List, Optional, Union, Any
from threading import Thread, Lock

from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from utils.config import Config

class BackupService:
    """
    备份服务模块
    负责系统数据的自动备份和恢复
    支持定时备份和手动备份
    """

    def __init__(self, config: Config, message_bus: MessageBus):
        """初始化备份服务模块"""
        self.module_id = f"backup_service_{uuid.uuid4().hex[:8]}"
        self.config = config
        self.message_bus = message_bus
        self.error_handler = ErrorHandler()

        # 备份目录
        self.backup_dir = config.get("backup_dir", "./data/backups")

        # 确保备份目录存在
        os.makedirs(self.backup_dir, exist_ok=True)

        # 备份保留数量
        self.backup_retention = config.get("backup_retention", 5)

        # 自动备份间隔（秒）
        self.backup_interval = config.get("backup_interval", 86400)  # 默认每天备份一次

        # 备份源目录
        self.backup_sources = config.get("backup_sources", ["./data/knowledge", "./data/configs"])

        # 备份锁，确保一次只有一个备份操作
        self.backup_lock = Lock()

        # 是否启用自动备份
        self.auto_backup_enabled = config.get("auto_backup_enabled", True)

        # 备份历史记录
        self.backup_history = []

        # 从备份目录加载备份历史
        self._load_backup_history()

        # 注册模块
        ModuleRegistry().register_module(self.module_id, self)

        # 注册消息处理
        self.message_bus.register_handler(
            "backup_request",
            self.handle_backup_request
        )

        # 启动自动备份线程
        if self.auto_backup_enabled:
            self._start_auto_backup()

        logging.info(f"BackupService initialized with ID: {self.module_id}")

    def _load_backup_history(self):
        """从备份目录加载备份历史"""
        try:
            history_file = os.path.join(self.backup_dir, "backup_history.json")
            if os.path.exists(history_file):
                with open(history_file, "r") as f:
                    self.backup_history = json.load(f)
                logging.info(f"Loaded {len(self.backup_history)} backup records from history")
            else:
                logging.info("No backup history found, starting fresh")
        except Exception as e:
            logging.error(f"Error loading backup history: {str(e)}")
            self.backup_history = []

    def _save_backup_history(self):
        """保存备份历史到文件"""
        try:
            history_file = os.path.join(self.backup_dir, "backup_history.json")
            with open(history_file, "w") as f:
                json.dump(self.backup_history, f, indent=2)
            logging.info(f"Saved {len(self.backup_history)} backup records to history")
        except Exception as e:
            logging.error(f"Error saving backup history: {str(e)}")

    def _start_auto_backup(self):
        """启动自动备份线程"""
        def auto_backup_task():
            import time
            while self.auto_backup_enabled:
                try:
                    # 执行备份
                    self.create_backup("auto_scheduled")

                    # 等待下一次备份
                    time.sleep(self.backup_interval)
                except Exception as e:
                    self.error_handler.log_error("BackupService", f"Error in auto backup task: {str(e)}")
                    time.sleep(60)  # 出错后等待一分钟再重试

        backup_thread = Thread(target=auto_backup_task)
        backup_thread.daemon = True
        backup_thread.start()
        logging.info("Automatic backup thread started")

    def create_backup(self, backup_type: str) -> Dict[str, Any]:
        """
        创建系统备份

        Args:
            backup_type: 备份类型（"manual", "auto_scheduled", "pre_update"）

        Returns:
            Dict: 备份信息
        """
        with self.backup_lock:
            try:
                # 生成备份ID和时间戳
                backup_id = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:6]}"
                timestamp = datetime.now().isoformat()

                # 创建备份目录
                backup_path = os.path.join(self.backup_dir, backup_id)
                os.makedirs(backup_path, exist_ok=True)

                # 复制源文件到备份目录
                for source in self.backup_sources:
                    if os.path.exists(source):
                        dest_path = os.path.join(backup_path, os.path.basename(source))
                        if os.path.isdir(source):
                            shutil.copytree(source, dest_path)
                        else:
                            shutil.copy2(source, dest_path)

                # 创建备份元数据
                metadata = {
                    "backup_id": backup_id,
                    "timestamp": timestamp,
                    "type": backup_type,
                    "sources": self.backup_sources,
                    "size_bytes": self._get_dir_size(backup_path)
                }

                # 保存元数据到备份目录
                with open(os.path.join(backup_path, "metadata.json"), "w") as f:
                    json.dump(metadata, f, indent=2)

                # 更新备份历史
                self.backup_history.append(metadata)
                self._save_backup_history()

                # 删除多余的旧备份
                self._cleanup_old_backups()

                logging.info(f"Created backup {backup_id} of type {backup_type}")

                # 发送备份完成事件
                self._send_backup_event(backup_id, "created", metadata)

                return metadata

            except Exception as e:
                error_msg = f"Error creating backup: {str(e)}"
                self.error_handler.log_error("BackupService", error_msg)
                raise RuntimeError(error_msg)

    def restore_backup(self, backup_id: str) -> Dict[str, Any]:
        """
        从备份恢复系统

        Args:
            backup_id: 要恢复的备份ID

        Returns:
            Dict: 恢复操作结果
        """
        with self.backup_lock:
            try:
                # 检查备份是否存在
                backup_path = os.path.join(self.backup_dir, backup_id)
                if not os.path.exists(backup_path):
                    raise ValueError(f"Backup {backup_id} not found")

                # 读取备份元数据
                with open(os.path.join(backup_path, "metadata.json"), "r") as f:
                    metadata = json.load(f)

                # 恢复文件
                for source in metadata["sources"]:
                    source_name = os.path.basename(source)
                    backup_source = os.path.join(backup_path, source_name)

                    if os.path.exists(backup_source):
                        # 如果目标存在，先创建一个临时备份
                        if os.path.exists(source):
                            temp_backup = f"{source}_restore_backup_{uuid.uuid4().hex[:6]}"
                            if os.path.isdir(source):
                                shutil.copytree(source, temp_backup)
                            else:
                                shutil.copy2(source, temp_backup)

                            # 删除原目标
                            if os.path.isdir(source):
                                shutil.rmtree(source)
                            else:
                                os.remove(source)

                        # 复制备份到目标
                        if os.path.isdir(backup_source):
                            shutil.copytree(backup_source, source)
                        else:
                            shutil.copy2(backup_source, source)

                # 记录恢复操作
                restore_info = {
                    "backup_id": backup_id,
                    "restore_timestamp": datetime.now().isoformat(),
                    "original_metadata": metadata
                }

                logging.info(f"Restored system from backup {backup_id}")

                # 发送恢复完成事件
                self._send_backup_event(backup_id, "restored", restore_info)

                return restore_info

            except Exception as e:
                error_msg = f"Error restoring backup: {str(e)}"
                self.error_handler.log_error("BackupService", error_msg)
                raise RuntimeError(error_msg)

    def delete_backup(self, backup_id: str) -> bool:
        """
        删除备份

        Args:
            backup_id: 要删除的备份ID

        Returns:
            bool: 删除是否成功
        """
        with self.backup_lock:
            try:
                # 检查备份是否存在
                backup_path = os.path.join(self.backup_dir, backup_id)
                if not os.path.exists(backup_path):
                    raise ValueError(f"Backup {backup_id} not found")

                # 删除备份目录
                shutil.rmtree(backup_path)

                # 更新备份历史
                self.backup_history = [b for b in self.backup_history if b["backup_id"] != backup_id]
                self._save_backup_history()

                logging.info(f"Deleted backup {backup_id}")

                # 发送删除事件
                self._send_backup_event(backup_id, "deleted", {})

                return True

            except Exception as e:
                error_msg = f"Error deleting backup: {str(e)}"
                self.error_handler.log_error("BackupService", error_msg)
                return False

    def get_backup_list(self) -> List[Dict[str, Any]]:
        """获取所有备份列表"""
        return sorted(self.backup_history, key=lambda x: x["timestamp"], reverse=True)

    def _cleanup_old_backups(self):
        """清理过期的旧备份"""
        # 按时间排序备份历史
        sorted_backups = sorted(self.backup_history, key=lambda x: x["timestamp"], reverse=True)

        # 保留指定数量的备份
        if len(sorted_backups) > self.backup_retention:
            # 获取要删除的备份
            backups_to_delete = sorted_backups[self.backup_retention:]

            for backup in backups_to_delete:
                backup_id = backup["backup_id"]
                self.delete_backup(backup_id)

    def _get_dir_size(self, path: str) -> int:
        """获取目录总大小（字节）"""
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                if not os.path.islink(fp):
                    total_size += os.path.getsize(fp)

        return total_size

    def _send_backup_event(self, backup_id: str, event_type: str, details: Dict[str, Any]):
        """发送备份相关事件"""
        event_msg = {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": "broadcast",
            "priority": "normal",
            "type": "backup_event",
            "payload": {
                "backup_id": backup_id,
                "event_type": event_type,
                "timestamp": datetime.now().isoformat(),
                "details": details
            },
            "metadata": {}
        }

        self.message_bus.send_message(event_msg)

    def handle_backup_request(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """处理备份服务请求消息"""
        try:
            action = message.get("payload", {}).get("action")
            if not action:
                return self._create_error_response(message, "No action specified in backup request")

            if action == "create_backup":
                backup_type = message.get("payload", {}).get("backup_type", "manual")
                return self.handle_create_backup(backup_type, message)

            elif action == "restore_backup":
                backup_id = message.get("payload", {}).get("backup_id")
                return self.handle_restore_backup(backup_id, message)

            elif action == "delete_backup":
                backup_id = message.get("payload", {}).get("backup_id")
                return self.handle_delete_backup(backup_id, message)

            elif action == "get_backup_list":
                return self.handle_get_backup_list(message)

            elif action == "set_auto_backup":
                enabled = message.get("payload", {}).get("enabled")
                interval = message.get("payload", {}).get("interval")
                return self.handle_set_auto_backup(enabled, interval, message)

            else:
                return self._create_error_response(message, f"Unknown action: {action}")

        except Exception as e:
            return self._create_error_response(message, f"Error processing backup request: {str(e)}")

    def handle_create_backup(self, backup_type: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理创建备份请求"""
        try:
            backup_metadata = self.create_backup(backup_type)

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "backup_response",
                "payload": {
                    "action": "create_backup",
                    "success": True,
                    "backup_id": backup_metadata["backup_id"],
                    "metadata": backup_metadata
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_restore_backup(self, backup_id: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理恢复备份请求"""
        if not backup_id:
            return self._create_error_response(original_message, "No backup ID provided")

        try:
            restore_info = self.restore_backup(backup_id)

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "backup_response",
                "payload": {
                    "action": "restore_backup",
                    "success": True,
                    "backup_id": backup_id,
                    "restore_info": restore_info
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_delete_backup(self, backup_id: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理删除备份请求"""
        if not backup_id:
            return self._create_error_response(original_message, "No backup ID provided")

        success = self.delete_backup(backup_id)

        if success:
            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "backup_response",
                "payload": {
                    "action": "delete_backup",
                    "success": True,
                    "backup_id": backup_id
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        else:
            return self._create_error_response(original_message, f"Failed to delete backup: {backup_id}")

    def handle_get_backup_list(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理获取备份列表请求"""
        backups = self.get_backup_list()

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "backup_response",
            "payload": {
                "action": "get_backup_list",
                "success": True,
                "backups": backups,
                "count": len(backups)
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def handle_set_auto_backup(self, enabled: bool, interval: int, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理设置自动备份请求"""
        if enabled is None:
            return self._create_error_response(original_message, "No enabled value provided")

        old_enabled = self.auto_backup_enabled
        old_interval = self.backup_interval

        self.auto_backup_enabled = enabled

        if interval:
            self.backup_interval = interval

        # 如果从禁用变为启用，需要启动自动备份线程
        if not old_enabled and enabled:
            self._start_auto_backup()

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "backup_response",
            "payload": {
                "action": "set_auto_backup",
                "success": True,
                "old_settings": {
                    "enabled": old_enabled,
                    "interval": old_interval
                },
                "new_settings": {
                    "enabled": self.auto_backup_enabled,
                    "interval": self.backup_interval
                }
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def _create_error_response(self, original_message: Dict[str, Any], error_message: str) -> Dict[str, Any]:
        """创建错误响应消息"""
        error_id = self.error_handler.log_error("BackupService", error_message)

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "high",
            "type": "backup_response",
            "payload": {
                "success": False,
                "error": error_message,
                "error_id": error_id
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

# assembly_ctrl_system/modules/maintenance/update_manager.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
更新管理器，负责系统的版本更新和升级
"""

import uuid
import logging
import os
import json
import shutil
import time
import threading
from datetime import datetime
from typing import Dict, List, Optional, Union, Any
from threading import Thread, Lock

from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from utils.config import Config
from modules.maintenance.backup_service import BackupService

class UpdateManager:
    """
    更新管理器
    负责系统的版本更新、升级和回滚
    支持热更新和冷更新
    """

    def __init__(self, config: Config, message_bus: MessageBus, backup_service: BackupService):
        """初始化更新管理器"""
        self.module_id = f"update_manager_{uuid.uuid4().hex[:8]}"
        self.config = config
        self.message_bus = message_bus
        self.error_handler = ErrorHandler()
        self.backup_service = backup_service

        # 更新锁，确保一次只有一个更新操作
        self.update_lock = Lock()

        # 更新包目录
        self.update_dir = config.get("update_dir", "./data/updates")

        # 确保更新包目录存在
        os.makedirs(self.update_dir, exist_ok=True)

        # 当前系统版本
        self.current_version = config.get("system_version", "1.0.0")

        # 可用更新包列表
        self.available_updates = []

        # 更新历史记录
        self.update_history = []

        # 加载更新历史和可用更新
        self._load_update_data()

        # 是否正在更新中
        self.is_updating = False

        # 最后一次更新检查时间
        self.last_check_time = 0

        # 更新检查间隔（秒）
        self.check_interval = config.get("update_check_interval", 86400)  # 默认每天检查一次

        # 是否自动检查更新
        self.auto_check_enabled = config.get("auto_check_updates", True)

        # 注册模块
        ModuleRegistry().register_module(self.module_id, self)

        # 注册消息处理
        self.message_bus.register_handler(
            "update_request",
            self.handle_update_request
        )

        # 启动自动检查更新线程
        if self.auto_check_enabled:
            self._start_auto_check()

        logging.info(f"UpdateManager initialized with ID: {self.module_id}, current version: {self.current_version}")

    def _load_update_data(self):
        """加载更新历史和可用更新"""
        try:
            # 加载更新历史
            history_file = os.path.join(self.update_dir, "update_history.json")
            if os.path.exists(history_file):
                with open(history_file, "r") as f:
                    self.update_history = json.load(f)
                logging.info(f"Loaded {len(self.update_history)} update records from history")
            else:
                logging.info("No update history found, starting fresh")

            # 扫描可用更新包
            self._scan_available_updates()

        except Exception as e:
            logging.error(f"Error loading update data: {str(e)}")
            self.update_history = []
            self.available_updates = []

    def _save_update_history(self):
        """保存更新历史到文件"""
        try:
            history_file = os.path.join(self.update_dir, "update_history.json")
            with open(history_file, "w") as f:
                json.dump(self.update_history, f, indent=2)
            logging.info(f"Saved {len(self.update_history)} update records to history")
        except Exception as e:
            logging.error(f"Error saving update history: {str(e)}")

    def _scan_available_updates(self):
        """扫描可用更新包"""
        self.available_updates = []

        try:
            # 遍历更新目录中的所有子目录
            for item in os.listdir(self.update_dir):
                item_path = os.path.join(self.update_dir, item)

                if os.path.isdir(item_path):
                    # 检查是否包含更新元数据
                    metadata_file = os.path.join(item_path, "update_metadata.json")
                    if os.path.exists(metadata_file):
                        try:
                            with open(metadata_file, "r") as f:
                                metadata = json.load(f)

                            # 验证元数据格式
                            required_fields = ["update_id", "version", "requires_version"]
                            if all(field in metadata for field in required_fields):
                                # 添加到可用更新列表
                                self.available_updates.append(metadata)
                        except Exception as e:
                            logging.error(f"Error reading update metadata from {metadata_file}: {str(e)}")

            # 按版本号排序
            self.available_updates.sort(key=lambda x: self._version_to_tuple(x["version"]))
            logging.info(f"Found {len(self.available_updates)} available updates")

        except Exception as e:
            logging.error(f"Error scanning available updates: {str(e)}")

    def _version_to_tuple(self, version: str) -> tuple:
        """将版本号转换为元组，便于比较"""
        try:
            return tuple(map(int, version.split(".")))
        except Exception:
            return (0, 0, 0)  # 解析失败时返回默认值

    def _start_auto_check(self):
        """启动自动检查更新线程"""
        def auto_check_task():
            while self.auto_check_enabled:
                try:
                    current_time = time.time()

                    # 检查是否需要执行更新检查
                    if current_time - self.last_check_time >= self.check_interval:
                        self.check_for_updates()
                        self.last_check_time = current_time

                    # 等待一段时间再检查
                    time.sleep(3600)  # 每小时检查一次是否到达检查时间
                except Exception as e:
                    self.error_handler.log_error("UpdateManager", f"Error in auto check task: {str(e)}")
                    time.sleep(60)  # 出错后等待一分钟再重试

        check_thread = Thread(target=auto_check_task)
        check_thread.daemon = True
        check_thread.start()
        logging.info("Automatic update check thread started")

    def check_for_updates(self) -> List[Dict[str, Any]]:
        """
        检查是否有可用更新

        Returns:
            List[Dict]: 可用更新列表
        """
        # 重新扫描可用更新
        self._scan_available_updates()

        # 筛选可安装的更新
        available_updates = self._get_applicable_updates()

        # 如果有可用更新，发送通知
        if available_updates:
            self._send_update_event("updates_available", {
                "count": len(available_updates),
                "updates": available_updates
            })

        return available_updates

    def _get_applicable_updates(self) -> List[Dict[str, Any]]:
        """获取适用于当前版本的更新列表"""
        applicable_updates = []
        current_version_tuple = self._version_to_tuple(self.current_version)

        for update in self.available_updates:
            # 检查更新是否适用于当前版本
            requires_version_tuple = self._version_to_tuple(update["requires_version"])
            update_version_tuple = self._version_to_tuple(update["version"])

            # 只有当当前版本等于或高于所需版本，且更新版本高于当前版本时才适用
            if current_version_tuple >= requires_version_tuple and update_version_tuple > current_version_tuple:
                applicable_updates.append(update)

        return applicable_updates

    def install_update(self, update_id: str, auto_backup: bool = True) -> Dict[str, Any]:
        """
        安装指定的更新

        Args:
            update_id: 要安装的更新ID
            auto_backup: 是否在更新前自动备份

        Returns:
            Dict: 更新结果
        """
        with self.update_lock:
            # 检查是否已在更新中
            if self.is_updating:
                raise RuntimeError("Another update is already in progress")

            self.is_updating = True
            backup_id = None

            try:
                # 查找更新元数据
                update_metadata = None
                for update in self.available_updates:
                    if update["update_id"] == update_id:
                        update_metadata = update
                        break

                if not update_metadata:
                    raise ValueError(f"Update {update_id} not found")

                # 检查更新是否适用
                requires_version = update_metadata["requires_version"]
                new_version = update_metadata["version"]

                if self._version_to_tuple(self.current_version) < self._version_to_tuple(requires_version):
                    raise ValueError(f"Current version {self.current_version} does not meet required version {requires_version}")

                # 在更新前创建备份
                if auto_backup:
                    backup_metadata = self.backup_service.create_backup("pre_update")
                    backup_id = backup_metadata["backup_id"]
                    logging.info(f"Created pre-update backup: {backup_id}")

                # 发送更新开始事件
                self._send_update_event("update_started", {
                    "update_id": update_id,
                    "from_version": self.current_version,
                    "to_version": new_version,
                    "backup_id": backup_id
                })

                # 执行更新
                update_path = os.path.join(self.update_dir, update_id)
                update_script = os.path.join(update_path, "install.py")

                # 如果存在安装脚本，执行它
                if os.path.exists(update_script):
                    self._execute_update_script(update_script, update_metadata)
                else:
                    # 否则执行默认更新流程
                    self._perform_default_update(update_path, update_metadata)

                # 更新成功，记录新版本
                old_version = self.current_version
                self.current_version = new_version

                # 更新配置文件中的版本号
                self.config.set("system_version", new_version)

                # 记录更新历史
                update_record = {
                    "update_id": update_id,
                    "from_version": old_version,
                    "to_version": new_version,
                    "timestamp": datetime.now().isoformat(),
                    "backup_id": backup_id,
                    "success": True
                }

                self.update_history.append(update_record)
                self._save_update_history()

                # 发送更新完成事件
                self._send_update_event("update_completed", {
                    "update_id": update_id,
                    "from_version": old_version,
                    "to_version": new_version,
                    "backup_id": backup_id,
                    "success": True
                })

                logging.info(f"Successfully updated system from {old_version} to {new_version}")

                return update_record

            except Exception as e:
                error_msg = f"Error installing update: {str(e)}"
                self.error_handler.log_error("UpdateManager", error_msg)

                # 发送更新失败事件
                self._send_update_event("update_failed", {
                    "update_id": update_id,
                    "error": str(e),
                    "backup_id": backup_id
                })

                # 记录失败的更新历史
                if update_metadata:
                    fail_record = {
                        "update_id": update_id,
                        "from_version": self.current_version,
                        "to_version": update_metadata.get("version"),
                        "timestamp": datetime.now().isoformat(),
                        "backup_id": backup_id,
                        "success": False,
                        "error": str(e)
                    }

                    self.update_history.append(fail_record)
                    self._save_update_history()

                raise RuntimeError(error_msg)

            finally:
                self.is_updating = False

    def _execute_update_script(self, script_path: str, metadata: Dict[str, Any]):
        """执行更新脚本"""
        logging.info(f"Executing update script: {script_path}")

        # 创建临时环境变量
        env_vars = {
            "UPDATE_ID": metadata["update_id"],
            "FROM_VERSION": self.current_version,
            "TO_VERSION": metadata["version"],
            "UPDATE_DIR": os.path.dirname(script_path),
            "SYSTEM_DIR": os.path.abspath(".")
        }

        # 设置环境变量
        old_env = {}
        for key, value in env_vars.items():
            old_env[key] = os.environ.get(key)
            os.environ[key] = str(value)

        try:
            # 使用Python执行脚本
            import subprocess
            result = subprocess.run(["python", script_path], capture_output=True, text=True)

            if result.returncode != 0:
                raise RuntimeError(f"Update script failed with code {result.returncode}: {result.stderr}")

            logging.info(f"Update script executed successfully: {result.stdout}")

        finally:
            # 恢复环境变量
            for key, value in old_env.items():
                if value is None:
                    os.environ.pop(key, None)
                else:
                    os.environ[key] = value

    def _perform_default_update(self, update_path: str, metadata: Dict[str, Any]):
        """执行默认更新流程"""
        logging.info(f"Performing default update from {update_path}")

        # 查找并替换文件
        files_dir = os.path.join(update_path, "files")
        if os.path.exists(files_dir) and os.path.isdir(files_dir):
            # 遍历更新包中的所有文件和目录
            for root, dirs, files in os.walk(files_dir):
                # 计算相对路径
                rel_path = os.path.relpath(root, files_dir)

                # 创建目标目录
                if rel_path != ".":
                    target_dir = os.path.join(".", rel_path)
                    os.makedirs(target_dir, exist_ok=True)

                # 复制文件
                for file in files:
                    src_file = os.path.join(root, file)
                    if rel_path == ".":
                        dst_file = os.path.join(".", file)
                    else:
                        dst_file = os.path.join(".", rel_path, file)

                    # 备份原文件（如果存在）
                    if os.path.exists(dst_file):
                        backup_file = f"{dst_file}.bak"
                        shutil.copy2(dst_file, backup_file)

                    # 复制新文件
                    shutil.copy2(src_file, dst_file)
                    logging.info(f"Updated file: {dst_file}")
        else:
            logging.warning(f"No files directory found in update package: {update_path}")

        # 执行数据库迁移脚本（如果存在）
        migrate_script = os.path.join(update_path, "migrate.py")
        if os.path.exists(migrate_script):
            self._execute_update_script(migrate_script, metadata)

        # 执行后置脚本（如果存在）
        post_update_script = os.path.join(update_path, "post_update.py")
        if os.path.exists(post_update_script):
            self._execute_update_script(post_update_script, metadata)

    def rollback_update(self, update_id: str) -> Dict[str, Any]:
        """
        回滚指定的更新

        Args:
            update_id: 要回滚的更新ID

        Returns:
            Dict: 回滚结果
        """
        with self.update_lock:
            # 检查是否已在更新中
            if self.is_updating:
                raise RuntimeError("Another update is already in progress")

            self.is_updating = True

            try:
                # 查找更新记录
                update_record = None
                for record in reversed(self.update_history):
                    if record["update_id"] == update_id and record["success"]:
                        update_record = record
                        break

                if not update_record:
                    raise ValueError(f"No successful update record found for ID: {update_id}")

                # 检查是否有备份
                backup_id = update_record.get("backup_id")
                if not backup_id:
                    raise ValueError(f"No backup available for update: {update_id}")

                # 发送回滚开始事件
                self._send_update_event("rollback_started", {
                    "update_id": update_id,
                    "from_version": self.current_version,
                    "to_version": update_record["from_version"],
                    "backup_id": backup_id
                })

                # 从备份恢复
                restore_info = self.backup_service.restore_backup(backup_id)

                # 更新系统版本
                old_version = self.current_version
                self.current_version = update_record["from_version"]

                # 更新配置文件中的版本号
                self.config.set("system_version", self.current_version)

                # 记录回滚历史
                rollback_record = {
                    "update_id": update_id,
                    "from_version": old_version,
                    "to_version": self.current_version,
                    "timestamp": datetime.now().isoformat(),
                    "backup_id": backup_id,
                    "is_rollback": True,
                    "success": True
                }

                self.update_history.append(rollback_record)
                self._save_update_history()

                # 发送回滚完成事件
                self._send_update_event("rollback_completed", {
                    "update_id": update_id,
                    "from_version": old_version,
                    "to_version": self.current_version,
                    "backup_id": backup_id,
                    "success": True
                })

                logging.info(f"Successfully rolled back update {update_id} from {old_version} to {self.current_version}")

                return rollback_record

            except Exception as e:
                error_msg = f"Error rolling back update: {str(e)}"
                self.error_handler.log_error("UpdateManager", error_msg)

                # 发送回滚失败事件
                self._send_update_event("rollback_failed", {
                    "update_id": update_id,
                    "error": str(e)
                })

                raise RuntimeError(error_msg)

            finally:
                self.is_updating = False

    def _send_update_event(self, event_type: str, details: Dict[str, Any]):
        """发送更新相关事件"""
        event_msg = {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": "broadcast",
            "priority": "high" if event_type in ["update_failed", "rollback_failed"] else "normal",
            "type": "update_event",
            "payload": {
                "event_type": event_type,
                "timestamp": datetime.now().isoformat(),
                "details": details
            },
            "metadata": {}
        }

        self.message_bus.send_message(event_msg)

    def handle_update_request(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """处理更新请求消息"""
        try:
            action = message.get("payload", {}).get("action")
            if not action:
                return self._create_error_response(message, "No action specified in update request")

            if action == "check_for_updates":
                return self.handle_check_for_updates(message)

            elif action == "install_update":
                update_id = message.get("payload", {}).get("update_id")
                auto_backup = message.get("payload", {}).get("auto_backup", True)
                return self.handle_install_update(update_id, auto_backup, message)

            elif action == "rollback_update":
                update_id = message.get("payload", {}).get("update_id")
                return self.handle_rollback_update(update_id, message)

            elif action == "get_update_history":
                return self.handle_get_update_history(message)

            elif action == "set_auto_check":
                enabled = message.get("payload", {}).get("enabled")
                interval = message.get("payload", {}).get("interval")
                return self.handle_set_auto_check(enabled, interval, message)

            else:
                return self._create_error_response(message, f"Unknown action: {action}")

        except Exception as e:
            return self._create_error_response(message, f"Error processing update request: {str(e)}")

    def handle_check_for_updates(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理检查更新请求"""
        try:
            available_updates = self.check_for_updates()

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "update_response",
                "payload": {
                    "action": "check_for_updates",
                    "success": True,
                    "current_version": self.current_version,
                    "available_updates": available_updates,
                    "count": len(available_updates)
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_install_update(self, update_id: str, auto_backup: bool, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理安装更新请求"""
        if not update_id:
            return self._create_error_response(original_message, "No update ID provided")

        try:
            update_record = self.install_update(update_id, auto_backup)

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "update_response",
                "payload": {
                    "action": "install_update",
                    "success": True,
                    "update_id": update_id,
                    "update_record": update_record
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_rollback_update(self, update_id: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理回滚更新请求"""
        if not update_id:
            return self._create_error_response(original_message, "No update ID provided")

        try:
            rollback_record = self.rollback_update(update_id)

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "update_response",
                "payload": {
                    "action": "rollback_update",
                    "success": True,
                    "update_id": update_id,
                    "rollback_record": rollback_record
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_get_update_history(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理获取更新历史请求"""
        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "update_response",
            "payload": {
                "action": "get_update_history",
                "success": True,
                "current_version": self.current_version,
                "update_history": self.update_history,
                "count": len(self.update_history)
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def handle_set_auto_check(self, enabled: bool, interval: int, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理设置自动检查更新请求"""
        if enabled is None:
            return self._create_error_response(original_message, "No enabled value provided")

        old_enabled = self.auto_check_enabled
        old_interval = self.check_interval

        self.auto_check_enabled = enabled

        if interval:
            self.check_interval = interval

        # 如果从禁用变为启用，需要启动自动检查线程
        if not old_enabled and enabled:
            self._start_auto_check()

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "update_response",
            "payload": {
                "action": "set_auto_check",
                "success": True,
                "old_settings": {
                    "enabled": old_enabled,
                    "interval": old_interval
                },
                "new_settings": {
                    "enabled": self.auto_check_enabled,
                    "interval": self.check_interval
                }
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def _create_error_response(self, original_message: Dict[str, Any], error_message: str) -> Dict[str, Any]:
        """创建错误响应消息"""
        error_id = self.error_handler.log_error("UpdateManager", error_message)

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "high",
            "type": "update_response",
            "payload": {
                "success": False,
                "error": error_message,
                "error_id": error_id
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

# assembly_ctrl_system/modules/maintenance/integration_manager.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
集成管理器，负责系统的集成和管理
"""

import uuid
import logging
import json
import os
from typing import Dict, List, Optional, Union, Any

from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from utils.config import Config
from modules.maintenance.system_monitor import SystemMonitor
from modules.maintenance.backup_service import BackupService
from modules.maintenance.update_manager import UpdateManager
from modules.deploy_service.deployment_manager import DeploymentManager
from modules.deploy_service.cloud_service import CloudService
from modules.deploy_service.auto_scaling import AutoScaling

class IntegrationManager:
    """
    集成管理器
    负责协调系统各个模块的集成和管理
    提供统一的管理接口
    """

    def __init__(self, config: Config, message_bus: MessageBus):
        """初始化集成管理器"""
        self.module_id = f"integration_manager_{uuid.uuid4().hex[:8]}"
        self.config = config
        self.message_bus = message_bus
        self.error_handler = ErrorHandler()

        # 已注册的模块
        self.registered_modules = {}

        # 模块依赖关系
        self.module_dependencies = {}

        # 模块启动顺序
        self.startup_sequence = []

        # 注册模块
        ModuleRegistry().register_module(self.module_id, self)

        # 注册消息处理
        self.message_bus.register_handler(
            "integration_request",
            self.handle_integration_request
        )

        logging.info(f"IntegrationManager initialized with ID: {self.module_id}")

    def register_module(self, module_id: str, module_instance: Any, dependencies: List[str] = None):
        """
        注册模块到集成管理器

        Args:
            module_id: 模块ID
            module_instance: 模块实例
            dependencies: 模块依赖列表
        """
        self.registered_modules[module_id] = module_instance

        if dependencies:
            self.module_dependencies[module_id] = dependencies
        else:
            self.module_dependencies[module_id] = []

        logging.info(f"Registered module: {module_id} with dependencies: {dependencies}")

        # 更新启动顺序
        self._update_startup_sequence()

    def _update_startup_sequence(self):
        """更新模块启动顺序"""
        # 拓扑排序算法，考虑依赖关系
        visited = set()
        temp_visited = set()
        startup_sequence = []

        def visit(module_id):
            if module_id in temp_visited:
                # 检测到循环依赖
                raise ValueError(f"Circular dependency detected involving module: {module_id}")

            if module_id not in visited:
                temp_visited.add(module_id)

                # 先访问所有依赖
                for dependency in self.module_dependencies.get(module_id, []):
                    if dependency in self.registered_modules:
                        visit(dependency)

                temp_visited.remove(module_id)
                visited.add(module_id)
                startup_sequence.append(module_id)

        # 对每个模块执行拓扑排序
        for module_id in self.registered_modules:
            if module_id not in visited:
                visit(module_id)

        self.startup_sequence = startup_sequence
        logging.info(f"Updated module startup sequence: {self.startup_sequence}")

    def initialize_system(self):
        """
        按照依赖顺序初始化系统模块
        """
        logging.info("Starting system initialization")

        for module_id in self.startup_sequence:
            try:
                module = self.registered_modules[module_id]

                # 检查模块是否有初始化方法
                if hasattr(module, "initialize") and callable(getattr(module, "initialize")):
                    logging.info(f"Initializing module: {module_id}")
                    module.initialize()

            except Exception as e:
                error_msg = f"Error initializing module {module_id}: {str(e)}"
                self.error_handler.log_error("IntegrationManager", error_msg)
                logging.error(error_msg)

                # 发送初始化失败事件
                self._send_integration_event("module_init_failed", {
                    "module_id": module_id,
                    "error": str(e)
                })

                # 抛出异常，中断初始化
                raise RuntimeError(error_msg)

        logging.info("System initialization completed successfully")

        # 发送初始化完成事件
        self._send_integration_event("system_initialized", {
            "modules": self.startup_sequence
        })

    def shutdown_system(self):
        """
        按照依赖顺序反向关闭系统模块
        """
        logging.info("Starting system shutdown")

        # 反向遍历启动顺序进行关闭
        for module_id in reversed(self.startup_sequence):
            try:
                module = self.registered_modules[module_id]

                # 检查模块是否有关闭方法
                if hasattr(module, "shutdown") and callable(getattr(module, "shutdown")):
                    logging.info(f"Shutting down module: {module_id}")
                    module.shutdown()

            except Exception as e:
                error_msg = f"Error shutting down module {module_id}: {str(e)}"
                self.error_handler.log_error("IntegrationManager", error_msg)
                logging.error(error_msg)

                # 发送关闭失败事件
                self._send_integration_event("module_shutdown_failed", {
                    "module_id": module_id,
                    "error": str(e)
                })

        logging.info("System shutdown completed")

        # 发送关闭完成事件
        self._send_integration_event("system_shutdown", {})

    def get_system_status(self) -> Dict[str, Any]:
        """
        获取系统状态报告

        Returns:
            Dict: 系统状态报告
        """
        # 收集各模块状态
        module_statuses = {}

        for module_id, module in self.registered_modules.items():
            # 检查模块是否有获取状态方法
            if hasattr(module, "get_status") and callable(getattr(module, "get_status")):
                try:
                    module_statuses[module_id] = module.get_status()
                except Exception as e:
                    module_statuses[module_id] = {
                        "status": "error",
                        "error": str(e)
                    }
            else:
                module_statuses[module_id] = {
                    "status": "unknown",
                    "reason": "Module does not support status reporting"
                }

        # 检查是否有失败的模块
        has_failed = any(status.get("status") == "error" for status in module_statuses.values())

        return {
            "system_status": "degraded" if has_failed else "healthy",
            "modules": module_statuses,
            "module_count": len(self.registered_modules),
            "system_version": self.config.get("system_version", "1.0.0"),
            "startup_sequence": self.startup_sequence
        }

    def handle_integration_request(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """处理集成管理请求消息"""
        try:
            action = message.get("payload", {}).get("action")
            if not action:
                return self._create_error_response(message, "No action specified in integration request")

            if action == "get_system_status":
                return self.handle_get_system_status(message)

            elif action == "initialize_system":
                return self.handle_initialize_system(message)

            elif action == "shutdown_system":
                return self.handle_shutdown_system(message)

            elif action == "get_module_info":
                module_id = message.get("payload", {}).get("module_id")
                return self.handle_get_module_info(module_id, message)

            elif action == "get_startup_sequence":
                return self.handle_get_startup_sequence(message)

            else:
                return self._create_error_response(message, f"Unknown action: {action}")

        except Exception as e:
            return self._create_error_response(message, f"Error processing integration request: {str(e)}")

    def handle_get_system_status(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理获取系统状态请求"""
        try:
            status = self.get_system_status()

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "integration_response",
                "payload": {
                    "action": "get_system_status",
                    "success": True,
                    "status": status
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_initialize_system(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理初始化系统请求"""
        try:
            self.initialize_system()

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "integration_response",
                "payload": {
                    "action": "initialize_system",
                    "success": True,
                    "startup_sequence": self.startup_sequence
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_shutdown_system(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理关闭系统请求"""
        try:
            self.shutdown_system()

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "integration_response",
                "payload": {
                    "action": "shutdown_system",
                    "success": True
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_get_module_info(self, module_id: str, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理获取模块信息请求"""
        if not module_id:
            return self._create_error_response(original_message, "No module ID provided")

        if module_id not in self.registered_modules:
            return self._create_error_response(original_message, f"Module not found: {module_id}")

        try:
            module = self.registered_modules[module_id]
            dependencies = self.module_dependencies.get(module_id, [])

            # 获取模块信息
            module_info = {
                "module_id": module_id,
                "class": module.__class__.__name__,
                "dependencies": dependencies,
                "is_registered": True
            }

            # 检查模块是否有获取状态方法
            if hasattr(module, "get_status") and callable(getattr(module, "get_status")):
                try:
                    module_info["status"] = module.get_status()
                except Exception as e:
                    module_info["status"] = {
                        "status": "error",
                        "error": str(e)
                    }

            return {
                "message_id": uuid.uuid4().hex,
                "source": self.module_id,
                "destination": original_message.get("source"),
                "priority": "normal",
                "type": "integration_response",
                "payload": {
                    "action": "get_module_info",
                    "success": True,
                    "module_id": module_id,
                    "module_info": module_info
                },
                "metadata": {
                    "in_response_to": original_message.get("message_id")
                }
            }
        except Exception as e:
            return self._create_error_response(original_message, str(e))

    def handle_get_startup_sequence(self, original_message: Dict[str, Any]) -> Dict[str, Any]:
        """处理获取启动顺序请求"""
        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "normal",
            "type": "integration_response",
            "payload": {
                "action": "get_startup_sequence",
                "success": True,
                "startup_sequence": self.startup_sequence,
                "dependencies": self.module_dependencies
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

    def _send_integration_event(self, event_type: str, details: Dict[str, Any]):
        """发送集成相关事件"""
        event_msg = {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": "broadcast",
            "priority": "high" if event_type in ["module_init_failed", "module_shutdown_failed"] else "normal",
            "type": "integration_event",
            "payload": {
                "event_type": event_type,
                "timestamp": import("datetime").datetime.now().isoformat(),
                "details": details
            },
            "metadata": {}
        }

        self.message_bus.send_message(event_msg)

    def _create_error_response(self, original_message: Dict[str, Any], error_message: str) -> Dict[str, Any]:
        """创建错误响应消息"""
        error_id = self.error_handler.log_error("IntegrationManager", error_message)

        return {
            "message_id": uuid.uuid4().hex,
            "source": self.module_id,
            "destination": original_message.get("source"),
            "priority": "high",
            "type": "integration_response",
            "payload": {
                "success": False,
                "error": error_message,
                "error_id": error_id
            },
            "metadata": {
                "in_response_to": original_message.get("message_id")
            }
        }

# assembly_ctrl_system/main.py
"""
ASSEMBLY-CTRL 系统 - 第七阶段：部署与运维
主入口文件，负责系统的初始化和启动
"""

import os
import sys
import logging
import argparse
import json
from datetime import datetime

# 添加根目录到路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.config import Config
from core.message_bus import MessageBus
from core.module_registry import ModuleRegistry
from core.error_handler import ErrorHandler
from core.resource_manager import ResourceMonitor

# 导入第七阶段模块
from modules.deploy_service.deployment_manager import DeploymentManager
from modules.deploy_service.cloud_service import CloudService
from modules.deploy_service.auto_scaling import AutoScaling
from modules.maintenance.system_monitor import SystemMonitor
from modules.maintenance.backup_service import BackupService
from modules.maintenance.update_manager import UpdateManager
from modules.maintenance.integration_manager import IntegrationManager

# 导入其他阶段模块
from modules.assembly_ctrl.controller import AssemblyCtrl
from modules.nerve_hq.control_center import NerveHQ
from modules.brain_gpt.gpt_interface import BrainGPT
from modules.tech_claude.claude_interface import TechClaude
from modules.ui_center.ui_service import UIService
from modules.repair_backup.repair_service import RepairBackup
from modules.knowledge_core.knowledge_service import KnowledgeCore
from modules.train_local.training_service import TrainLocal
from modules.test_verify.test_service import TestVerify

def setup_logging(config):
    """配置日志系统"""
    log_dir = config.get("log_dir", "./logs")
    os.makedirs(log_dir, exist_ok=True)

    log_level = getattr(logging, config.get("log_level", "INFO"))
    log_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

    # 创建时间戳文件名
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = os.path.join(log_dir, f"assembly_ctrl_{timestamp}.log")

    # 配置日志
    logging.basicConfig(
        level=log_level,
        format=log_format,
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )

    logging.info(f"Logging initialized at level {config.get('log_level', 'INFO')}")
    logging.info(f"Log file: {log_file}")

def parse_arguments():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(description="ASSEMBLY-CTRL 系统启动器")

    parser.add_argument("--config", type=str, default="./config/system_config.json",
                        help="配置文件路径")
    parser.add_argument("--mode", type=str, default="production", choices=["development", "test", "production"],
                        help="运行模式")
    parser.add_argument("--debug", action="store_true",
                        help="开启调试模式")

    return parser.parse_args()

def load_config(config_path, mode):
    """加载配置文件"""
    try:
        # 确保配置目录存在
        os.makedirs(os.path.dirname(config_path), exist_ok=True)

        # 尝试加载配置文件
        if os.path.exists(config_path):
            with open(config_path, "r") as f:
                config_data = json.load(f)

            # 加载模式特定配置
            mode_config = config_data.get(mode, {})
            base_config = config_data.get("base", {})

            # 合并配置
            merged_config = {**base_config, **mode_config}

            # 创建配置对象
            config = Config(merged_config)
            config.set("run_mode", mode)

            return config
        else:
            # 创建默认配置
            default_config = {
                "system_name": "ASSEMBLY-CTRL System",
                "system_version": "1.0.0",
                "log_level": "INFO",
                "log_dir": "./logs",
                "data_dir": "./data",
                "backup_dir": "./data/backups",
                "update_dir": "./data/updates",
                "run_mode": mode
            }

            # 保存默认配置
            os.makedirs(os.path.dirname(config_path), exist_ok=True)
            with open(config_path, "w") as f:
                json.dump({"base": default_config}, f, indent=2)

            return Config(default_config)

    except Exception as e:
        logging.error(f"Error loading config: {str(e)}")
        sys.exit(1)

def initialize_core_components(config):
    """初始化核心组件"""
    # 创建消息总线
    message_bus = MessageBus()

    # 创建错误处理器
    error_handler = ErrorHandler()

    # 创建资源监控器
    resource_monitor = ResourceMonitor(config)

    return message_bus, error_handler, resource_monitor

def initialize_phase7_components(config, message_bus, resource_monitor):
    """初始化第七阶段组件"""
    # 创建系统监控模块
    system_monitor = SystemMonitor(config, message_bus, resource_monitor)

    # 创建备份服务
    backup_service = BackupService(config, message_bus)

    # 创建部署管理器
    deployment_manager = DeploymentManager(config, message_bus)

    # 创建云服务
    cloud_service = CloudService(config, message_bus)

    # 创建自动扩展模块
    auto_scaling = AutoScaling(config, message_bus, resource_monitor)

    # 创建更新管理器
    update_manager = UpdateManager(config, message_bus, backup_service)

    # 创建集成管理器
    integration_manager = IntegrationManager(config, message_bus)

    # 注册模块依赖关系
    integration_manager.register_module("system_monitor", system_monitor, [])
    integration_manager.register_module("backup_service", backup_service, [])
    integration_manager.register_module("deployment_manager", deployment_manager, [])
    integration_manager.register_module("cloud_service", cloud_service, ["deployment_manager"])
    integration_manager.register_module("auto_scaling", auto_scaling, ["deployment_manager", "system_monitor"])
    integration_manager.register_module("update_manager", update_manager, ["backup_service"])

    return integration_manager

def initialize_other_phases(config, message_bus, integration_manager):
    """初始化其他阶段组件"""
    # 第一阶段：基础框架
    # 注册已经创建的核心组件

    # 第二阶段：总控模块
    assembly_ctrl = AssemblyCtrl(config, message_bus)
    nerve_hq = NerveHQ(config, message_bus)

    # 第三阶段：AI模型集成
    brain_gpt = BrainGPT(config, message_bus)
    tech_claude = TechClaude(config, message_bus)

    # 第四阶段：用户界面及工具
    ui_service = UIService(config, message_bus)

    # 第五阶段：支持服务
    repair_backup = RepairBackup(config, message_bus)
    knowledge_core = KnowledgeCore(config, message_bus)
    train_local = TrainLocal(config, message_bus)

    # 第六阶段：测试与集成
    test_verify = TestVerify(config, message_bus)

    # 注册模块到集成管理器
    integration_manager.register_module("assembly_ctrl", assembly_ctrl, ["message_bus", "error_handler"])
    integration_manager.register_module("nerve_hq", nerve_hq, ["assembly_ctrl"])
    integration_manager.register_module("brain_gpt", brain_gpt, ["message_bus"])
    integration_manager.register_module("tech_claude", tech_claude, ["message_bus"])
    integration_manager.register_module("ui_service", ui_service, ["message_bus"])
    integration_manager.register_module("repair_backup", repair_backup, ["message_bus"])
    integration_manager.register_module("knowledge_core", knowledge_core, ["message_bus"])
    integration_manager.register_module("train_local", train_local, ["message_bus", "knowledge_core"])
    integration_manager.register_module("test_verify", test_verify, ["message_bus"])

    return integration_manager

def main():
    """主函数"""
    # 解析命令行参数
    args = parse_arguments()

    # 加载配置
    config = load_config(args.config, args.mode)

    # 设置调试模式
    if args.debug:
        config.set("log_level", "DEBUG")

    # 配置日志
    setup_logging(config)

    logging.info(f"Starting ASSEMBLY-CTRL System in {args.mode} mode")

    try:
        # 初始化核心组件
        message_bus, error_handler, resource_monitor = initialize_core_components(config)

        # 初始化第七阶段组件
        integration_manager = initialize_phase7_components(config, message_bus, resource_monitor)

        # 初始化其他阶段组件
        integration_manager = initialize_other_phases(config, message_bus, integration_manager)

        # 系统初始化
        integration_manager.initialize_system()

        # 获取系统状态
        system_status = integration_manager.get_system_status()
        logging.info(f"System status: {system_status['system_status']}")

        # 示例：发送控制消息
        control_message = {
            "message_id": f"ctrl_{uuid.uuid4().hex}",
            "source": "main",
            "destination": "assembly_ctrl",
            "priority": "high",
            "type": "control_command",
            "payload": {
                "command": "start_operation",
                "parameters": {
                    "mode": args.mode
                }
            },
            "metadata": {}
        }

        message_bus.send_message(control_message)

        # 在实际应用中，这里会有主事件循环或服务器启动代码
        logging.info("System is ready and running")

        # 示例：启动命令行交互界面
        if args.mode == "development":
            from modules.ui_center.console_ui import start_console_ui
            start_console_ui(message_bus, integration_manager)
        else:
            # 在生产模式下保持运行
            import time
            try:
                while True:
                    time.sleep(1)
            except KeyboardInterrupt:
                logging.info("Received shutdown signal")

    except Exception as e:
        logging.critical(f"Fatal error during startup: {str(e)}", exc_info=True)
        sys.exit(1)
    finally:
        # 系统关闭
        try:
            integration_manager.shutdown_system()
            logging.info("System shutdown completed")
        except Exception as e:
            logging.error(f"Error during shutdown: {str(e)}", exc_info=True)

if __name__ == "__main__":
    main()
